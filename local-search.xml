<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>点评的缓存问题</title>
    <link href="/2024/10/10/%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/10/10/%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存更新">缓存更新</h1><p><imgsrc="https://s3.bmp.ovh/imgs/2024/11/03/53c8371b2d78d0a9.png" /></p><ul><li>等redis内存满了自己淘汰</li><li>超时</li><li>主动更新</li></ul><h6 id="主动更新">主动更新</h6><ul><li>更新数据库时更新缓存</li><li>缓存与数据库整合</li><li>调用者只操作缓存，由其他线程异步将缓存持久化到数据库中，保证最终一致</li></ul><h5 id="先删缓存还是先操作数据库">先删缓存还是先操作数据库？</h5><p>先操作数据库，再更新缓存。</p><blockquote><p>缓存操作比数据库操作快；数据库读比写快：所以先删缓存，在数据库update完成前，可能会导致期间的查询不一致。</p></blockquote><h1 id="缓存穿透">缓存穿透</h1><blockquote><p>客户端的请求在缓存和数据库中<strong>都不存在</strong>，<strong>缓存永远不会生效</strong>，请求都会打到数据库上，次次查询数据库然后返回不存在。</p></blockquote><h3 id="解决方法">解决方法</h3><ul><li>布隆过滤器<ul><li>不存在就一定不存在，存在可能会误判</li><li>快速</li></ul></li><li>缓存空对象<ul><li>实现简单，但是内存消耗且可能不一致</li><li>需要给空对象设置TTL(Time To Live)</li></ul></li></ul><h1 id="缓存雪崩">缓存雪崩</h1><blockquote><p><strong>同一时段，大量缓存的有效期到期失效</strong>，或者redis宕机，导致大量请求短期内集中打到数据库。</p></blockquote><h3 id="解决方法-1">解决方法</h3><ul><li>TTL随机：N+n模式，n随机</li><li>集群</li><li>多级缓存</li></ul><h1 id="缓存击穿">缓存击穿</h1><blockquote><p>热点key问题，一个被<strong>高并发访问</strong>并且<strong>缓存重建复杂</strong>的key突然失效，在瞬间给数据库带来巨大压力。</p></blockquote><h3 id="解决方法-2">解决方法</h3><ul><li>互斥锁</li><li>逻辑过期</li></ul><p><imgsrc="https://s3.bmp.ovh/imgs/2024/11/03/44eddbc61753000c.png" /></p><h4 id="互斥锁业务流程">互斥锁业务流程</h4><p><imgsrc="https://s3.bmp.ovh/imgs/2024/11/03/0aaa594f1bfc8ee7.png" /></p><h4 id="逻辑过期业务流程">逻辑过期业务流程</h4><p><imgsrc="https://s3.bmp.ovh/imgs/2024/11/03/11e420ea7f4b894e.png" /></p><p>逻辑过期需要<strong>缓存预热</strong>：</p><p>注意到逻辑过期如果一开始缓存未命中，就会直接空。</p><p>因为是防止打到数据库，所以也不会因为缓存未命中而去查数据库。</p><p>所以需要<strong>缓存预热</strong>，一开始的缓存中需要存在所需的数据，否则就会一直缓存击穿未遂而返回空对象。</p><h1 id="缓存预热">缓存预热</h1><p>黑马的视频里没有，自己试着加了一个，与逻辑过期一起使用。</p><p>由于缓存预热的数据具有特殊性，所以不写在<code>CacheClient</code>这样的通用工具类中，而是写在<code>ShopServiceImpl</code>类里。</p><p>写好缓存预热方法如下，逻辑很简单，设置一个缓存标记，如果没有标记，证明缓存不存在，则预热：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 缓存预热</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">warmupCache</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询缓存内是否有内容</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_FLAG);<br>    <span class="hljs-comment">// 没有内容则预热缓存</span><br>    <span class="hljs-keyword">if</span>(StrUtil.isBlank(shopJson)) &#123;<br>        <span class="hljs-comment">// 先放flag</span><br>        stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_FLAG, RedisConstants.CACHE_SHOP_EXIST);<br>        List&lt;Shop&gt; shops = list();<br>        <span class="hljs-keyword">for</span>(Shop shop : shops) &#123;<br>            cacheClient.setWithLogicalExpire(CACHE_SHOP_KEY + shop.getId(), shop, <span class="hljs-number">30L</span>, TimeUnit.MINUTES);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后新建一个<code>CacheWarmupRunner</code>类，需要实现<code>ApplicationRunner</code>接口，加上<code>@Component</code>注解，然后注入<code>ShopService</code>，在类里面重写<code>run</code>方法，在<code>run</code>里调用<code>warmupCache</code>。</p><blockquote><p><code>ApplicationRunner</code>和<code>CommendLineRunner</code>：</p><p>CommandLineRunner 和 ApplicationRunner 都是 Spring Boot应用程序启动后要执行的接口，它们都允许我们在应用启动后执行一些自定义的初始化逻辑，例如缓存预热。</p><p><code>CommandLineRunner</code>和 <code>ApplicationRunner</code>区别如下：</p><p>方法签名不同</p><ul><li><code>CommandLineRunner</code>接口有一个<code>run(String... args)</code>方法，它接收命令行参数作为可变长度字符串数组。</li><li><code>ApplicationRunner</code>接口则提供了一个<code>run(ApplicationArguments args)</code>方法，它接收一个<code>ApplicationArguments</code>对象作为参数，这个对象提供了对传入的所有命令行参数（包括选项和非选项参数）的访问。</li></ul><p>参数解析方式不同</p><ul><li><code>CommandLineRunner</code>接口更简单直接，适合处理简单的命令行参数。</li><li><code>ApplicationRunner</code>接口提供了一种更强大的参数解析能力，可以通过<code>ApplicationArguments</code>获取详细的参数信息，比如获取选项参数及其值、非选项参数列表以及查询是否存在特定参数等。</li></ul><p>使用场景不同</p><ul><li>当只需要处理一组简单的命令行参数时，可以使用<code>CommandLineRunner</code>。</li><li>对于需要精细控制和解析命令行参数的复杂场景，推荐使用<code>ApplicationRunner</code>。</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>点评</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fw的碎碎念</title>
    <link href="/2024/10/10/fw%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <url>/2024/10/10/fw%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要看点评你想获得什么">为什么要看点评？你想获得什么？</h1><p>我想学习分布式的开发，想练习更多各种业务是如何实现的，是如何优化的。</p><p>可以记录下你写的过程中的问题，不一定要快，但是要学到学懂学透，能力最重要，得理解。</p><h1id="觉得点评烂大街做完也没什么用还得做另一个冷门的项目遥遥无期让你绝望从而拖延">觉得点评烂大街做完也没什么用，还得做另一个冷门的项目，遥遥无期让你绝望，从而拖延</h1><p>项目要学的都是业务，都是新的工具和技术，你现在学习分布式，学习redis如何使用，到了其他项目，你又得学mysql、mysqlplus、nacos、docker……各种工具和技术，五花八门，都是为业务服务。redis复杂，并且刚接触，所以耗时久。一步一个脚印，多写博客，记录学到的东西。增加动力。</p><h1 id="看不下去不想看">看不下去，不想看？</h1><p>没有认同感，没有价值感。</p><p>写博客有热情，因为觉得自己在输出，总会帮助到别人一点，最不济也能帮到以后的自己，有成就感，自己认为有价值。</p><p>但是看点评、外卖，烂大街，虽然确有其价值，但是自己无法认同，只是逼迫自己去看去学而已。</p><p>程序员是技术无产阶级，生产资料不是自己的。自己的生产资料，那就是自己运营的有偿服务了，代码属于自己，服务器属于自己，收入也属于自己。这很有价值感，开发的服务既利好了别人，同时也为自己创造了收入。还可以放弃收入开源，从而获得更大的价值感。</p><p>但是程序员大多开发内部软件，目的是给企业降低成本提高效率，最终目的呢？为资本家创造了更多的收益，让摸鱼的人变累。</p><p>该如何认同程序员呢？医生对着希波克拉底宣誓的时候，心里必然会有超越自我的无私和仁心，这种认同将帮助他们面对医院的鸡毛蒜皮和辛苦，他们这么累是在救人，是在不分高低贵贱地为人们减轻痛苦，很高尚，很有价值。但程序员呢？我是一个菜鸟，我没办法写出能够便利人们生活的产品，我对代码也没有原生的热情和喜爱，甚至我初始仅仅是闻着高薪的味儿来的。</p><p>我写这个有用吗？有什么价值吗？用搜索引擎搜了下，没有找到让我觉得成为一个程序员是一件有价值的事情的回答。"程序员挣很多钱让家人过得更好"，这当然是很高尚的理由，但我没法接受，这还不够有价值。</p><p>罢，程序员还是很有价值的，我还没理解到而已，让自己别这么菜，就有价值了，菜鸟当然没价值。</p><p>又浪费一个多小时。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github pages自定义域名失效解决</title>
    <link href="/2024/10/07/github-pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3/"/>
    <url>/2024/10/07/github-pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="问题背景">问题背景</h1><p>为GithubPages自定义域名后，总是隔三岔五地失效，其实是每次<code>hexo d</code>之后就会失效。</p><h1 id="原因">原因</h1><p>原因在于，当在<code>YOUR_NAME.github.io</code>这个仓库的设置里手动添加域名的时候，其实是在远程仓库(也就是github)新增了一个CNAME文件，里面装着自定义域名，可以失效后手动添加完去看看commit记录。</p><p>但是本地的博客源文件是没有这个CNAME文件的，所以每次<code>hexo d</code>都会覆盖掉github上的CNAME，导致域名失效。</p><h1 id="解决">解决</h1><p>所以，只需要在<code>source</code>文件夹下新建一个<code>CNAME</code>文件，往里面写入域名，然后再<code>hexo g -d</code>就好了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不是，哥们</title>
    <link href="/2024/09/25/%E4%B8%8D%E6%98%AF%EF%BC%8C%E5%93%A5%E4%BB%AC/"/>
    <url>/2024/09/25/%E4%B8%8D%E6%98%AF%EF%BC%8C%E5%93%A5%E4%BB%AC/</url>
    
    <content type="html"><![CDATA[<p><span class="math display">\[\begin{split}{}_\lambda\!\subset_\Pi^{:l} ?\\不是，哥们\end{split}\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>娱乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数模答辩小记</title>
    <link href="/2024/09/23/%E6%95%B0%E6%A8%A1%E7%AD%94%E8%BE%A9%E5%B0%8F%E8%AE%B0/"/>
    <url>/2024/09/23/%E6%95%B0%E6%A8%A1%E7%AD%94%E8%BE%A9%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>周六早上收到的答辩通知，是指导老师给负责人邮箱或者电话通知。紧张刺激地复习了一天论文和代码之后上场答辩。愿结果如意，小记一下过程，因为准备过程中看到了某pku✌的答辩记录，我也记一下，方便有缘人。(应该不会涉及泄密吧，泄密我就删了。。)</p><h1 id="时间线">时间线</h1><p>9月4日---9月7日：比赛</p><p>9月21日早晨：收到答辩通知</p><p>9月22日上午：前往西石油答辩</p><p>9月25日上午：问指导老师说会推上去的，但等级不定</p><p>10月5日早上：出省赛区拟推结果，拟推国二</p><h1 id="细节">细节</h1><ul><li><p>答辩是三个人都要到场，要带学生证和身份证，在进场前核验身份，但是进场后就不能暴露自己的学校，因为有其他学校的队伍也在那里答辩，ABCDE题的队伍都有，粗略估计应该有近百支队伍要参加答辩，可能整个成都甚至四川赛区的队伍都在这里了。</p></li><li><p>虽说3个人都要到齐(队里有几个来几个，不一定3个)，但是答辩可以一个人答，不会随机点某个人回答问题，我们队就是我主要做题，所以我全程答辩，队友站旁边适时补充(鞠躬)就行了。</p></li><li><p>答辩的主要目的是辨别论文是不是独立创作的，有没有抄袭。所以即使论文有错误也可以大方承认，关键要说出自己的思路和想法，毕竟这不是定级答辩而是鉴抄答辩。</p></li><li><p>答辩不需要PPT，会让打印两份论文，一份备案，一份给专家看，自己则看讲台电脑上的论文，会提前备好。</p></li><li><p>答辩是每队首先5分钟内陈述自己的思路，然后15分钟内的专家提问。前5分钟的叙述约等于念摘要吧，自己背着拉通陈述也行，我是自己凭记忆拉通讲了一遍思路。讲完思路之后，我们是评委直接让翻到xx页，然后开始提问</p></li><li><p>既然目的是鉴定抄袭，所以25分钟专家提问会问得比较深入，考察对论文的熟悉程度。我们主要被问了两个问题：</p><ul><li>第一个是评审故意下套说错，看你能不能根据自己的论文来驳倒错误，我成功地说服了评审。</li><li>但是第二个问题我好像失败了，第二个问题非常细，问我代码里面一个变量什么含义、为什么这样命名，我回答出了含义，但是为什么这样命名似乎没能说服评审。评审解释了为什么会问这种奇怪问题，因为我的这个变量名字和之前的一份论文的代码相似的位置变量名是一样的。这很巧合，我结合JAVA的constant变量命名规范、C/C++的常量宏定义规范解释了为什么这样命名，但好像没能说服。。</li></ul></li><li><p>评审应该<strong>只辨真伪，不会定级</strong>，所以主旨就是证明是自己原创的就行了，错了也别怕，解释怎么想的就可以。但是如果问到代码里某个变量什么意思答不出来，好像也有点嫌疑。。所以还是要认真复习复习。</p></li><li><p>着装没有要求，我们队就穿的常服，注意别穿短裤、凉拖鞋、背心等花里胡哨或者过于不整的就可以了</p></li></ul><p>具体细节一共就这么多</p><p>本文根据自己的实际经历和<ahref="https://lyh543.github.io/notes/mcm/cumcm-oral-defenses.html">数模国赛答辩相关| 小灰灰灰灰的博客</a>写作，如果泄密或者有更多问题可以联系我。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo上云记录(华为云)</title>
    <link href="/2024/08/30/hexo%E4%B8%8A%E4%BA%91%E8%AE%B0%E5%BD%95-%E5%8D%8E%E4%B8%BA%E4%BA%91/"/>
    <url>/2024/08/30/hexo%E4%B8%8A%E4%BA%91%E8%AE%B0%E5%BD%95-%E5%8D%8E%E4%B8%BA%E4%BA%91/</url>
    
    <content type="html"><![CDATA[<p>JAVA学不进去，焦虑无比，于是做点其他的，搞了个华为云的免费服务器Flexus，<del>好抠，只给一个月</del>，想着把githubpage上的这个静态博客放到云上玩玩。开帖记录一下过程，也方便以后再次上云。需要：</p><ul><li>服务器镜像：Ubuntu 20.04</li><li>已配置好的hexo博客</li></ul><h1 id="白嫖华为云">白嫖华为云</h1><p>首先来到<ahref="https://www.huaweicloud.com/special/ecs-xsfwq.html">华为云学生服务器</a>页面，每天9:30后能领个试用，注册华为账号，然后领取。</p><figure><img src="https://s3.bmp.ovh/imgs/2024/08/31/4c57cc38588ee8d8.png"alt="华为云真抠啊……" /><figcaption aria-hidden="true">华为云真抠啊……</figcaption></figure><p>买完一路点默认设置，最后来到Flexus实例控制台。跟着“应用搭建指引”设置好密码，在“配置安全组”那里添加一个规则，添加一个TCP的80端口。</p><h1 id="服务器配置">服务器配置</h1><h2 id="下载工具">下载工具</h2><p>通过cloudShell远程登录服务器，下载必要的工具：git、nginx、ssh</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install git-core<br>sudo apt-<span class="hljs-built_in">get</span> install nginx<br>sudo apt-<span class="hljs-built_in">get</span> install openssh-server<br></code></pre></td></tr></table></figure><blockquote><p>华为云好像初始有git和nginx，但也可以执行一下apt-get，不费事</p></blockquote><p>安装ssh后，查看ssh服务是否启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -e|grep ssh<br></code></pre></td></tr></table></figure><figure><img src="https://s3.bmp.ovh/imgs/2024/08/31/6fe396dcfbb2f1e8.png"alt="ssh服务" /><figcaption aria-hidden="true">ssh服务</figcaption></figure><h2 id="创建用户">创建用户</h2><p>创建一个系统用户，这里以"blog"为例。</p><p>创建一个名为<code>blog</code>的用户。接下来为<code>blog</code>添加文件的写权限：在<code>/etc/sudoers</code>中添加<code>blog    ALL=(ALL:ALL) ALL</code>，具体命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">visudo /etc/sudoers<br></code></pre></td></tr></table></figure><p>然后向下翻，找到</p><figure><img src="https://s3.bmp.ovh/imgs/2024/08/31/712404ad978ede8d.png"alt="用户权限" /><figcaption aria-hidden="true">用户权限</figcaption></figure><p>如上图编辑，在root下面添加一行<code>blog    ALL=(ALL:ALL) ALL</code>。<code>visudo</code>命令使用的是nano编辑器，使用Ctrl+X、y、Enter退出。</p><p>然后切换至<code>blog</code>用户，回退至根路径，在<code>/var/repo</code>下创建名为<code>hexo_static</code>的裸仓库(仓库名可自定义)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">su blog<br>cd /<br><br>sudo mkdir /var/repo/<br>sudo chown -R $USER:$USER /var/repo/<br>sudo chmod -R 755 /var/repo/<br><br>cd /var/repo/<br>git init --bare hexo_static.git<br></code></pre></td></tr></table></figure><p>创建完成后可进入<code>/var/repo</code>查看，应该有branches、config、HEAD、hooks等</p><p>创建<code>/var/www/hexo</code>目录，用于nginx托管，修改目录所有权和权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /var/www/hexo<br><br>sudo chown -R $USER:$USER /var/www/hexo<br>sudo chmod -R 755 /var/www/hexo<br></code></pre></td></tr></table></figure><h2 id="配置nginx服务默认路径">配置nginx服务默认路径</h2><p>如果<code>/etc/nginx</code>下有<code>sites-enabled</code>文件夹，则编辑其下的<code>default</code>文件</p><p>如果没有，则编辑<code>conf.d</code>文件夹下的<code>default.conf</code>，添加<code>root /var/www/hexo</code>，位置如下，再删掉location里的proxy的第一行<code>proxy_pass  http://127.0.0.1:9001</code>;，取消转发到9001端口。</p><blockquote><p>因为华为云默认安装一个wordpress的应用镜像，用dockerps就能看见，如果放着不管，直接访问ip会看见wordpress而不是自己的博客。可以禁掉docker，也可以取消掉这里的转发。</p></blockquote><p><imgsrc="https://s3.bmp.ovh/imgs/2024/08/31/6e31c0e536710814.png" /></p><p>如果有<code>sites-enabled</code>文件夹，在<code>default</code>中如下位置添加<code>root    /var/www/hexo</code></p><p><imgsrc="https://s3.bmp.ovh/imgs/2024/08/31/2827648b2496da59.png" /></p><blockquote><p>注意：nginx.conf里面得包含你写的default，写了就得include进去，如下：</p><p><imgsrc="https://s3.bmp.ovh/imgs/2024/08/31/21367481ad0f2bc1.png" /></p></blockquote><p>然后重启nginx服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl reload nginx<br></code></pre></td></tr></table></figure><h2 id="创建git钩子">创建Git钩子</h2><p>在之前的仓库的hooks文件夹下创建一个<code>post-receive</code>钩子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /var/repo/hexo_static.git/hooks/post-receive<br></code></pre></td></tr></table></figure><p>写入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>git --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f<br></code></pre></td></tr></table></figure><p>然后为该文件添加可执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x /var/repo/hexo_static.git/hooks/post-receive<br></code></pre></td></tr></table></figure><h2 id="拷贝密钥">拷贝密钥</h2><p>回到根路径创建<code>.ssh</code>目录，进入，创建<code>authorized_keys</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /<br>sudo mkdir .ssh<br>cd /.ssh<br><br>vim authorized_keys<br></code></pre></td></tr></table></figure><p>找到本地的<code>id_rsa.pub</code>文件，复制到这里，如果没权限可以进root再操作</p><h2 id="部署hexo项目">部署hexo项目</h2><p>编辑本地hexo的<code>_config.yml</code>文件，修改两处</p><ul><li>url改为服务器的公网ip</li><li>deploy的repo改为{用户名}<span class="citation"data-cites="公网ip">@公网ip</span>:/var/repo/hexo_static.git，branch改成实际的名字，main或者master</li></ul><p>然后<code>hexo g -d</code>上传，首次会要一个yes，然后输密码</p><p>上传后进入<code>/var/www/hexo</code>下查看，可以看到静态文件已经全部上传，就是本地的public文件夹里的内容。</p><p>r然后在浏览器输入ip就可以访问啦！</p><h1 id="后续问题">后续问题</h1><p>第一次上传成功，第二次上传出现</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-comment">remote: error: cannot update the ref &#x27;HEAD&#x27;: unable to append to &#x27;./logs/HEAD&#x27;: Permission denied</span><br></code></pre></td></tr></table></figure><p>通常是由于远程仓库中的分支或引用被锁定、权限问题，或者由于在远程仓库中有一些与本地仓库冲突的提交。但是这是个人博客，所以不会出现分支冲突，那就是权限问题，无脑加一轮权限即可简单解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span> -un  <span class="hljs-comment"># 获取当前用户名</span><br><span class="hljs-built_in">id</span> -gn  <span class="hljs-comment"># 获取当前用户组</span><br><br>sudo <span class="hljs-built_in">chown</span> -R YOUR_USER:YOUR_GROUP /var/repo/hexo_static.git <span class="hljs-comment">#增加权限</span><br><span class="hljs-built_in">rm</span> -f /var/repo/hexo_static.git/.git/refs/heads/main.lock <span class="hljs-comment">#删除仓库的锁</span><br><span class="hljs-comment"># 设置目录权限为755，允许所有者读写，组和其他用户只读</span><br>sudo <span class="hljs-built_in">chmod</span> -R 755 /var/www/hexo<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重命名项目</title>
    <link href="/2024/08/30/%E9%87%8D%E5%91%BD%E5%90%8D%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/08/30/%E9%87%8D%E5%91%BD%E5%90%8D%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>出于将苍穹外卖化为己有的阴暗目的，我决定将项目中的sky-take-out、sky、itcast、heima等字样统统修改，去除黑马元素和苍穹元素。此举可能造成一系列路径问题，故开帖记录</p><p>重命名基于黑马官方资料day01的后端初始代码，在跟完教程开发完成后开始重构。</p><h1 id="模块名">模块名</h1><p>首先，修改模块名，主模块sky-take-out改为my-take-out，idea显示的是模块所在文件夹的名称，所以还要修改文件夹名，修改之后就需要重新用IDEA打开项目。</p><p>然后，下面三个子模块的sky都改为my，此时refactor出现了重构选项，可以一键重构模块及其文件夹名，还能将所有位置的名字都修改了(先查找，然后修改全部)，子模块名主要存在于父模块的pom文件聚合工程中，以<code>&lt;module&gt;</code>包括。</p><p>至此模块名修改完成，注意<strong>重新加载maven</strong>，更新子模块的pom文件</p><h1 id="包名">包名</h1><p>双击shift搜索“sky”字样，注意到项目所有com包下级包名都是sky，都改成my</p><blockquote><p>为什么java项目的包要像域名翻转一样？</p><p>java诞生时，互联网域名系统已经很成熟，开发者使用所属组织域名可以防止重复，同时标识项目来源</p><p>com：commercial 商业组织、org：organization非盈利组织、gov、edu……</p><p>由含义来看，大包名下的小包名依次表示：所属组织、用途。所以com下的sky改为my可表示由自己开发，意义正确，符合规范</p></blockquote><p>重命名包时也会有全局重命名选项，此时不能勾选"在注释和字符串中搜索"，因为会有只读文件已经获取旧包名sky，类似于缓存，无法对其写。而不勾选"在注释和字符串中搜索"，意味着后续还需要全局搜索来修改残余的"sky"。</p><h1 id="groupid">groupId</h1><p>然后，修改pom文件中的groupId，由于groupId可以不与实际包名一致，所以不会报错。先修改父工程的pom其中的groupId，然后刷新maven时就会报三个子模块的错<code>&lt;parent&gt;</code>下的父工程指定出了问题，一个一个修改好。还需注意，server模块依赖了common和pojo模块，还需要改server的<code>&lt;dependency&gt;</code>中的groupId。</p><h1 id="其他">其他</h1><p>然后，<code>ctrl+shift+f</code>全局搜索，再接<code>ctrl+shift+r</code>全局替换，直接把所有sky全变成my。</p><blockquote><p>为什么不直接全局搜索替换？</p><p>得先改文件夹名，然后才能全局搜索替换，不然会出现三个my-xxx的空子模块，原来的模块还是用文件夹名，只是多了个my-xxx的别名，父工程的pom是找不到这三个子工程的。</p><p>包名也没办法全局替换，根本不会被搜索到，只能一个一个重命名，还得注意连带文件夹。</p><p>groupId部分可以跳过，直接全局替换</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八股集录</title>
    <link href="/2024/08/21/%E5%85%AB%E8%82%A1%E9%9B%86%E5%BD%95/"/>
    <url>/2024/08/21/%E5%85%AB%E8%82%A1%E9%9B%86%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="day1">day1</h1><h2 id="osi模型">OSI模型</h2><p>Open SystemInterconnect，OSI将计算机网络通信协议分为7层，分别是应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><h2 id="tcpip模型">TCP/IP模型</h2><p>应用层——应用、表示、会话：HTTP、SSH、FTP</p><p>传输层——传输：TCP、UDP</p><p>网络层——网络：IP</p><p>网络接口层——数据链路层、物理层：以太网、WIFI、MAC地址</p><blockquote><p>理解：TCP/IP更早，更实际、实用；OSI更偏向于理论研究，更细化，更通用</p></blockquote><h2 id="从输入url到页面展示的过程">从输入URL到页面展示的过程</h2><ol type="1"><li>输入URL，解析URL，准备发送HTTP请求</li><li>检查浏览器缓存，如果有则直接返回，如果没有则准备发送网络请求</li><li>发送网络请求前要进行DNS解析，获取域名的IP地址。如果请求协议是HTTPS，还要建立TLS连接。DNS解析从本地缓存、本地Host文件、路由器缓存、DNS服务器，一直查询域名直到根DNS服务器，直到找到为止。</li><li>TCP三次握手建立浏览器和服务器之间的TCP连接</li><li>连接建立后，客户端构建请求信息，发送HTTP请求，如果是HTTPS，还要加解密</li><li>服务器收到请求之后根据请求响应数据</li><li>TCP四次挥手断开连接</li><li>浏览器解析响应数据，展示出相应的页面</li></ol><blockquote><p>理解：刚开始检查用不用发请求，如果需要发请求，就先解析，然后三次握手，后端响应，四次挥手断开，最后前端展示</p></blockquote><h1 id="day2">day2</h1><h2id="http请求响应报文是怎样的有哪些常见的字段">HTTP请求、响应报文是怎样的，有哪些常见的字段</h2><p>请求报文： 由请求行、请求头、空行、请求体构成。请求行包括：</p><ul><li>方法：GET、POST、PUT、DELETE等</li><li>资源路径，也就是url</li><li>HTTP版本，使用的http协议，比如1.1、2.0</li></ul><p>请求头的字段比较多，常用的有：</p><ul><li>Host：请求的服务器的域名</li><li>Accept：客户端能够处理的媒体类型</li><li>Accept-Encoding：客户端能够解码的内容编码</li><li>Authorization：用于认证的凭证信息，比如token</li><li>Content-Length：请求体的长度</li><li>Content-Type：请求体的媒体类型</li><li>Cookie：存储在客户端的cookie数据</li><li>If-None-Match：资源的ETag值，用于缓存控制</li><li>Connection：管理连接的选项，如keep-alive</li></ul><p>空行是分隔请求头和请求体的空行</p><p>响应报文：服务器向客户端返回的数据格式，通常包含状态行、响应头、空行、响应体</p><p>状态行包含HTTP版本、状态码、状态信息，比如http/2.0 404 notFound</p><p>响应头的常见字段有：</p><ul><li>Content-Type：响应主体的媒介类型</li><li>Content-Length：响应主体的长度</li><li>Server：指定服务器的信息</li><li><strong>Expires</strong>：响应的过期时间</li><li><strong>ETag</strong>：响应体的实体标签，用于缓存和条件请求</li><li><strong>Last-Modified</strong>：资源最后被修改的日期和时间</li><li>Location：在重定向时指定新的资源位置</li><li>Set-Cookie：在重定向时指定新的资源位置</li></ul><blockquote><p>理解：行+头+空行分隔+体</p><p>行里基本配置信息，头里一堆字段，体里是数据</p></blockquote><h2 id="http有哪些请求方式">HTTP有哪些请求方式</h2><p>Get：<strong>请求</strong>指定的资源</p><p>Post：向指定资源<strong>提交</strong>数据进行处理</p><p>Put：<strong>更新</strong>资源</p><p>DELETE：<strong>删除</strong>资源</p><p>HEAD：获取报文首部，不返回报文主题(判断资源是否存在)</p><p>OPTIONS：查询服务器支持的请求方法(通过Allow头来判断)</p><p>PATCH：对资源进行部分更新</p><blockquote><p>理解：望文生意即可</p></blockquote><h2 id="get请求和post请求的区别">GET请求和POST请求的区别</h2><ul><li>get一般用来获取数据，post如其名用来提交数据</li><li>get参数放在路径里，而post的在请求体里</li><li>由于参数的位置，post相比get更安全，参数量也更大</li><li>get请求不会改变资源的状态，而post会改变，称为幂等性</li><li>get可以被缓存，而post默认不缓存</li></ul><blockquote><p>理解：仍然望文生义，注意最后一点</p></blockquote><h1 id="day3">day3</h1><h2 id="http中常见的状态码有哪些">HTTP中常见的状态码有哪些</h2><ul><li>200：客户端请求成功</li><li>201：创建了新资源</li><li>204：无内容，服务器成功处理了请求，但未返回内容</li></ul><hr /><ul><li>301：永久重定向</li><li>302：临时重定向</li><li>304：请求的内容未修改，浏览器使用缓存返回</li></ul><hr /><ul><li>401：需要身份验证</li><li>403：禁止访问</li><li>404：资源未找到</li></ul><hr /><ul><li>500：服务器内部错误</li><li>503：服务器刚启动，未准备好</li></ul><blockquote><p>理解：大体分四类，2开头为成功，3开头表示资源变化，4开头请求错误，5开头服务错误</p><p>整百读整百，其他单个读：500-伍佰、404-四零四</p></blockquote><h2 id="什么是强缓存和协商缓存">什么是强缓存和协商缓存</h2><p>强缓存：浏览器对之前请求过的资源进行缓存，下一次请求时不发送请求，而直接返回本地缓存的资源。</p><ul><li><p>在Http1.0版本中，通过<code>Expire</code>响应头来实现强制缓存，是一个时间点，表示资源过期时间。</p></li><li><p>在1.1版本中，引入了<code>Cache-Control</code>响应头，可以通过<code>max-age</code>设置最大生存时间</p></li><li><p>如果响应头中没有任何和缓存相关的字段，浏览器会采用启发式算法决定是否缓存资源。通常基于<code>Date</code>和<code>Last-modified</code>值计算</p></li></ul><blockquote><p>强缓存可能导致资源更新时的不一致，需要合理设置更新频率。</p></blockquote><hr /><p>协商缓存：浏览器和服务器通信以确认缓存资源是否有效。</p><p>主要涉及两组响应头字段</p><ul><li><code>ETag</code>/<code>If-None-Match</code>：浏览器第一次请求时，服务器会返回ETag，是该资源的唯一标识符，后续再请求，请求头中的<code>If-None_Match</code>就会携带<code>ETag</code>，服务器来判断该资源是否更新，如果未更新，则返回<code>304 Not Modified</code>，如果更新了则返回新的资源和ETag。</li><li><code>Last-Modified</code>/<code>If-Modified-Since</code>：服务器会返回资源和其最后修改时间<code>Last-Modified</code>，后续请求的请求头会携带<code>If-Modified-Since</code>，服务端检查是否过期。返回同上。</li></ul><blockquote><p>协商缓存确保获取最新资源，避免不必要的资源传输。</p></blockquote><hr /><blockquote><p>理解：强缓存应用于不常变动的静态资源，如图片，css，js等</p><p>协商缓存适用于变动频繁的资源</p></blockquote><h1 id="day4">day4</h1><h2 id="http-1.0和http-1.1的区别">HTTP 1.0和HTTP 1.1的区别</h2><ul><li><strong>持久连接</strong>：HTTP1.1默认持久连接，也就是一个TCP连接可以发送多个HTTP请求响应，减少了连接和关闭的开销。而HTTP1.0默认短连接，每次请求都需要建立一个TCP连接，通过Connection：keep-alive头来实现持久连接(可被拒绝)</li><li><strong>管道化</strong>：HTTP1.1支持管道化，允许客户端再第一个请求的响应到达前发送多个请求，减少等待时间。HTTP1.0不支持管道化。<u>管道化的前提是使用长连接</u></li><li><strong>缓存控制</strong>：HTTP1.0主要使用<code>If-Modified-Since</code>和<code>Expires</code>来缓存控制。HTTP1.1引入了<code>ETag/If-None-Match</code>等更多的缓存头来控制缓存</li><li>错误码：HTTP 1.1有更多错误响应码，如<code>426 Upgrade Required</code></li><li>Host字段：HTTP1.1加入了Host头，让客户端指定请求的主机名，可以在同一台服务器上托管多个域名。HTTP1.0没有这个字段</li><li>请求方法：HTTP1.1有更多请求方法，如OPTIONS、PUT、DELETE、HEAD、PATCH</li><li>带宽优化：HTTP1.1中可以部分请求资源，使用range头设定范围，返回码是206 PartialContent</li></ul><blockquote><p>理解：降低了原子性：持久、管道；加入了更多的功能</p></blockquote><h2 id="http-1.1和http-2.0的区别">HTTP 1.1和HTTP 2.0的区别</h2><ul><li><strong>二进制协议vs文本协议</strong>：HTTP 2.0采用二进制格式传输数据，解析高效还不容易出错。而HTTP1.1使用可读的文本格式，解析和处理都较慢</li><li><strong>多路复用</strong>：HTTP2.0支持多路复用，允许单个TCP连接上并行交错发送多个请求和响应，缓解了HTTP1.1中的队头阻塞问题。<strong>在丢包场景下还是会出现队头阻塞问题</strong></li><li><strong>头部压缩</strong>：HTTP2.0引入了HPACK压缩算法，对请求响应头压缩，减少了冗余头部信息的传输</li><li><strong>服务器推送</strong>：HTTP2.0允许服务器主动推送资源给客户端</li><li><strong>优先级和依赖</strong>：HTTP2.0允许客户端为请求设置优先级，并表达请求之间的依赖关系，让资源加载更有序。</li></ul><blockquote><p>理解：改进传输，实现双向，优先级</p></blockquote><h2 id="http-3.0">HTTP 3.0</h2><p>HTTP 3是HTTP的最新版本，基于QUIC协议，特点有：</p><ul><li>无队头阻塞：QUIC使用UDP来传输数据，一个连接上多个stream之间没有依赖，如果一个stream丢了一个UDP包，不会影响后面的stream，不存在队头阻塞的问题。</li><li><strong>零RTT连接建立</strong>：QUIC允许首次连接时进行零往返时间连接建立，QUIC协议通过将握手过程（包括加密握手）减少到一次往返（甚至为0-RTT），大大缩短了连接建立的时间。这意味着第一次与服务器连接时延迟显著降低，用户体验更加流畅。</li><li><strong>连接迁移</strong>：QUIC允许在网络切换(如从WIFI切到移动网络)，将连接迁移到新的IP地址，从而减少连接的中断时间。</li><li>向前纠错机制：每个数据包除了它本身的内容之外，还有其他包的数据，所以少量丢包可以用其他包的数据而不需要重新传。虽然降低了每个包的有效信息，但是减少了丢包数据重传。</li><li>安全性：HTTP 3.0默认TLS加密，确保了数据传输的安全</li></ul><blockquote><p>理解：从TCP变成了UDP，基于QUIC，所以少了一些TCP的问题：建立连接开销大、队头阻塞。</p><p>需要结合 层 来理解，看图</p></blockquote><h1 id="day-5">day 5</h1><h2 id="https-和-http-有什么区别">HTTPS 和 HTTP 有什么区别</h2><p>区别主要在于安全性和数据加密：</p><ul><li>加密层：HTTPS在HTTP的基础上增加了SSL/TLS(<strong>现代只使用TLS</strong>)协议作为加密层。HTTP是明文的</li><li>HTTP在TCP三次握手后开始报文传输，HTTPS在三次握手后还要SSL/TLS的握手才能进入加密报文传输。</li><li>端口：HTTPS通常使用443端口，HTTP使用80端口</li><li>HTTPS需要CA证书，来保证服务器身份可信</li></ul><blockquote><p>HTTPS的S就是Secure，所以主要区别在于安全性：多了TLS -&gt;多了TLS的握手;多了CA证书</p></blockquote><h2id="https的工作原理https建立连接的过程">HTTPS的工作原理(HTTPS建立连接的过程)</h2><p>过程如下：</p><ol type="1"><li>密钥交换：客户端发起HTTPS请求后，服务器会发送其公钥证书给客户端</li><li>证书验证：客户端会验证服务器的证书是否由CA签发，检查有效性</li><li>加密通信：证书验证通过，客户端生成一个随机的对称加密密钥，使用服务器的公钥加密该密钥，发送给服务器</li><li>建立安全连接：服务器使用自己的私钥解密得到对称加密密钥，此时客户端与服务端都有了相同的密钥，可加解密</li><li>数据传输：将所有数据对称加密传输</li><li>完整性校验：SSL/TLS协议还包括消息完整性校验，如消息认证码，确保数据在传输过程中未被篡改</li><li>结束连接：数据传输完成后，通信双方销毁密钥。</li></ol><blockquote><p>理解：公钥用于加密，私钥用于解密，只有对应的公私钥才能彼此加解密，通过非对称加密传递对称加密的密钥，实现对称加密。</p></blockquote><h2 id="tcp和udp的区别">TCP和UDP的区别</h2><ol type="1"><li>TCP需要在传输前建立可靠连接，UDP不需要建立连接</li><li>TCP保证数据包的顺序和完整，UDP不保证</li><li>TCP可根据网络状况调整传输速率，UDP传输速率固定</li><li>TCP通过滑动窗口进行流量控制，UDP没有流量控制</li><li>TCP能检测重传丢包，UDP没有</li><li>TCP报文头复杂，UDP报文头简单</li><li>TCP建立连接开销大，UDP简单开销小</li><li>TCP适用于可靠传输，UDP适用于实时性高的传输</li></ol><blockquote><p>理解：TCP稳定可靠，代价就是事儿多；UDP事儿不多，但是不稳定不可靠</p></blockquote><h1 id="day-6">day 6</h1><h2 id="tcp连接如何确保可靠性">TCP连接如何确保可靠性</h2><p>TCP通过这些机制来保证可靠性：</p><ul><li>序列号：每个TCP都有一个序列号，确保数据包的顺序正确</li><li>数据校验：TCP使用校验和来检测数据在传输过程中是否出现错误，如果错误，就会丢弃该包并等待重传</li><li>确认应答：接收方会发送ACK确认收到数据。</li><li>超时重传：如果发送方的定时器超时了还未收到ACK，会触发超时重传</li><li>流量控制：TCP通过滑动窗口进行流量控制，确保接收方能够处理发送方的数据量</li><li>拥塞控制：TCP通过慢启动、快重传、快恢复、拥塞避免等控制数据的发送速率，防止网络拥塞</li></ul><h2 id="拥塞控制如何实现的">拥塞控制如何实现的</h2><ul><li>慢启动：初始阶段，TCP发送方从小发送窗口开始，越成功窗口越大，指数级增长，称为慢启动。在开始时逐步增加速率，避免引起拥塞</li><li>拥塞避免：一旦达到一定的阈值，TCP发送方就会进入拥塞避免阶段：发送方以线性增加的方式增加发送窗口的大小。</li><li>快速重传：如果发送方连续收到相同的确认，会认为丢包，并快速重传未确认的包，而不等待超时。</li><li>快速恢复：发生快速重传后，发送方不会重新慢启动，而将慢启动阈值设置为当前窗口的一半，将拥塞窗口的大小设置为慢启动阈值加上已确认但未快速重传的包的数量。</li></ul><blockquote><p>理解：先慢后快，然后试探上限，过线就减半重来，目的就是在靠近上限的地方波动，保持总体较高的传输速率而不导致拥塞</p></blockquote><h2 id="tcp流量控制是怎么实现的">TCP流量控制是怎么实现的</h2><p>主要目的就是发送方不能太快，接收方来得及接受。这就需要动态地根据网络情况来调整传输速率。</p><ul><li>滑动窗口大小：每个TCP报文段都有一个窗口字段，提示发送方可以发送多少字节的数据而不等待确认。</li><li>接收方窗口大小：接收方通过该字段告诉发送方目前可接受的窗口大小，主要依据接收方缓冲区大小，如果接收方缓冲区快满，会减小窗口，或通知发送方暂停发送</li><li>发送方根据窗口的大小动态调整发送速率，根据ACK中的窗口字段获取最新的窗口大小</li></ul><blockquote><p>理解：每次ACK都是接收方告诉发送方当前速率是否合适</p></blockquote><h2 id="udp如何实现可靠传输">UDP如何实现可靠传输</h2><p>UDP（User DatagramProtocol）本身是一种无连接、不可靠的传输协议，不提供像 TCP那样的可靠性机制，如数据重传、数据包顺序控制、流量控制和拥塞控制。因此，UDP在设计上更适合需要低延迟或能够容忍一定数据丢失的应用，比如实时视频流、在线游戏和语音通信。</p><p>然而，在一些需要可靠传输的应用场景中，可以通过在应用层（即在 UDP之上）自行实现额外的可靠性机制来弥补 UDP 的不足。</p><ul><li>添加序列号</li><li>超时重传</li><li>向前纠错</li><li>错误校验</li><li>流量控制</li></ul><blockquote><p>理解：貌似TCP的特性加在UDP上就好了</p></blockquote><h1 id="day7">day7</h1><h2id="tcp三次握手的过程为什么是三次可以少或者多吗">TCP三次握手的过程，为什么是三次，可以少或者多吗</h2><p>三次握手的过程：</p><ul><li>第一次握手：客户端向服务端发送一个<code>SYN</code>(同步序列编号)报文，请求建立连接，客户端进入<code>SYN_SENT</code>状态</li><li>第二次握手：服务端收到SYN报文后，如果同意，则发送一个SYN_ACK(同步确认)报文作为响应，同时进入SYN_RCVD状态</li><li>第三次握手：客户端收到服务器的SYN_ACK报文后，会发送一个ACK确认报文作为最终响应，之后客户端和服务端都进入ESTABLISHED状态，连接建立成功。</li></ul><blockquote><p>三次正好可以确认双方的收发功能正常。多了冗余，少了不行。</p></blockquote><h2id="tcp四次挥手的过程为什么是四次">TCP四次挥手的过程，为什么是四次</h2><p>四次挥手的过程：</p><ul><li>第一次挥手：客户端发送<code>FIN</code>报文给服务端，表示要断开数据传送，报文中会指定一个序列号<code>(seq=x)</code>。然后，客户端进入<code>FIN-WAIT-1</code>状态。</li><li>第二次挥手：服务端收到<code>FIN</code>报文后，回复<code>ACK</code>报文给客户端，且把客户端的序列号+1，作为ACK报文的序列号<code>(seq=x+1)</code>。然后，服务端进入<code>CLOSE-WAIT(seq=x+1)</code>状态，客户端进入<code>FIN-WAIT-2</code>状态。</li><li>第三次挥手：服务端也要断开连接时，发送<code>FIN</code>给客户端，且指定序列号<code>(seq=y+1)</code>，随后服务端进入<code>LAST-ACK</code>状态。</li><li>第四次挥手：客户端收到<code>FIN</code>报文后，发出<code>ACK</code>应答，把服务端的序列号+1作为ACK序列号<code>(seq=y+2)</code>。此时，客户端进入<code>TIME-WAIT</code>状态。服务端收到客户端的<code>ACK</code>后进入<code>CLOSE</code>状态，如果客户端等待<code>2MSL</code>没有收到服务端的回复，则关闭连接。</li></ul><p>为什么四次：</p><p>TCP是全双工通信，双向传输数据，双方都可以提出释放连接的通知，让对方进入半关闭状态，待对方传输完毕后，发回连接释放通知，己方确认后才会完全关闭TCP连接。前两次让发起方发出通知和对方发出确认；后两次让对方做完最后的传输，发出同意，让己方收到确认，最终关闭。</p><blockquote><p>发起方提前预警，接收方开始准备断开，接收方准备完成，发起方收到确认放心断开</p></blockquote><h2id="http的keep-alive是什么tcp的keepalive是和http的keep-alive是一个东西吗">HTTP的Keep-Alive是什么？TCP的Keepalive是和HTTP的Keep-Alive是一个东西吗</h2><ul><li>HTTP的Keep-Alive，是由应用层实现的，称为HTTP长连接。HTTP短连接为：建立TCP连接-&gt; HTTP请求资源 -&gt; 响应资源 -&gt;释放连接。但是每次连接只能请求一次资源，所以HTTP的Keep-Alive实现了使用同一个TCP连接来发送接受多个HTTP的请求应答，减少多次连接建立和释放的开销。</li><li>TCP的Keepalive，由TCP层(内核态)实现的，称为TCP保活机制，是一种用在TCP连接上检测空闲状态的机制。当TCP连接建立后，如果一段时间没有数据传输，TCP的Keepalive会发送探测包来检查连接是否还有效。</li></ul><blockquote><p>HTTP的是长连接，TCP的是检测连接是否还有效。一个高层一个底层</p></blockquote><h1 id="day8">day8</h1><h2 id="dns查询过程">DNS查询过程</h2><p>DNS称为域名服务器(Domain NameSystem)，用于将主机名和域名转换为IP地址，一般查询过程为：</p><ul><li><strong>本地DNS缓存检查</strong>：首先查询本地的DNS缓存，如果缓存里有对应的IP，则直接返回结果</li><li><strong>本地的DNS服务器</strong>：通常是当地的ISP提供，向其发送DNS查询请求</li><li><strong>根DNS服务器</strong>：如果本地DNS服务器没有，则其会向根DNS服务器查询。根DNS服务器不负责具体的域名解析，但能够告诉本地NDS服务器应该向哪个顶级域的DNS服务器继续查询</li><li><strong>顶级域名DNS服务器</strong>：本地DNS服务器接着向顶级域名DNS服务器发出查询请求。顶级域名DNS服务器也不负责具体的域名解析，但会告诉本地DNS服务器应该前往哪个权威DNS服务器查询下一步信息。</li><li><strong>权威DNS服务器</strong>：本地DNS服务器最后向权威DNS服务器发送查询，权威DNS服务器会返回对应的IP地址</li><li>本地DNS解析器收到IP后返回给浏览器，并且缓存该解析结果。</li><li>浏览器获得IP后，与目标服务器建立连接。</li></ul><blockquote><p>本地-&gt;本地ISP的DNS-&gt;根-&gt;顶级域名-&gt;权威</p></blockquote><h2 id="cdn是啥有什么用">CDN是啥，有什么用</h2><p>CDN是内容分发网络(Content DeliveryNetwork)，通过将内容存储在分布式服务器上，使用户可以从距离较近的服务器获得所需的内容，加速互联网的内容传输。</p><ul><li>就近访问：CDN在服务范围内会部署多个服务器节点，用户的请求会送到最近的CDN节点，加速访问。</li><li>内容缓存：CDN会缓存静态资源(图片、CSS、Script)。当用户访问时，CDN会使用缓存，没有才去源服务器获取资源并缓存。这减少了源服务器的负载</li><li>可用性：一个节点出了问题，还可以被重定向到其他的节点</li></ul><blockquote><p>对于博客，这可太熟悉了，当分布式说吧</p></blockquote><h2 id="cookie和session是什么">Cookie和Session是什么</h2><p>Cookie和Session都用于管理用户的状态和身份，Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。</p><ul><li>cookie由服务器发给浏览器，浏览器保存cookie并在将来的请求中包含cookie，服务器收到后续请求后可以分析cookie从而确定身份。</li><li>Session时服务器把客户端信息处理后记录在本地，主要用于维护登陆状态、存储临时数据等。服务器为每个用户分配SessonID，通常存在cookie中发给客户端</li></ul><p>Cookie和Session的区别：</p><ul><li>存储位置：Cookie存在浏览器，Session存在服务器</li><li>数据容量：Cookie较小，Session较大</li><li>安全性：Cookie存在浏览器内，可以被篡改，而Session不会</li><li>生命周期：Cookie可设置过期时间，Session依赖于会话的持续时间或用户活动</li><li>传输方式：Cookie在每次HTTP请求中都会被自动发送给服务器，而SessionID由Cookie或URL传递参数给客户端</li></ul><blockquote><p>cookie浏览器拿着，有信息；session防止被改，自己拿着，但容易拿不下</p></blockquote><h1 id="day9">day9</h1><h2 id="进程和线程的区别">进程和线程的区别</h2><p><strong>进程是资源分配和调度的最小单位</strong></p><p><strong>线程是程序执行的最小单位</strong></p><ul><li><p>线程是进程内的子任务，一个进程中的多个线程共享内存空间，进程之间内存空间独立。进程切换、创建、销毁的开销都大于线程。</p></li><li><p>进程之间通信需要一些机制：管道、消息队列、共享内存等。但线程可以直接访问共享数据。</p></li><li><p>进程相互隔离，而线程的错误可能会影响其他线程，影响整个进程的稳定性。</p></li></ul><blockquote><p>今天都是操作系统的基础，老考点了</p></blockquote><h2 id="并行和并发的区别">并行和并发的区别</h2><p>并行是真正意义上的同时进行，同一时刻有多个在执行。而并发是在短时间内相继执行大量任务，在宏观上看起来像同时发生，实际上仍然是交替执行的。</p><blockquote><p>老考点了，可以结合实例讲</p></blockquote><h2id="解释用户态和内核态什么情况下会发生切换">解释用户态和内核态，什么情况下会发生切换</h2><p>用户态和内核态是操作系统为了保护系统资源和权限控制而设计的两种不同的CPU运行级别，可以<strong>控制进程或程序对计算机硬件资源的访问权限和操作范围</strong>。</p><ul><li>用户态：进程和程序只能访问受限的资源和执行受限的指令集，不能直接访问OS的核心部分，也不能直接访问硬件资源。</li><li>核心态：OS的特权级别，允许进程或程序执行特权指令和访问操作系统的核心部分。在核心态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。</li></ul><p>发生切换的场景：</p><ul><li>系统调用</li><li>异常</li><li>中断</li></ul><blockquote><p>也是经典知识点，看看就行了，已经知道了</p></blockquote><h1 id="day10">day10</h1><h2 id="什么是死锁如何避免">什么是死锁，如何避免</h2><p>死锁就是系统中两个或多个进程在执行过程中，因争夺资源而造成的一种僵局。当每个进程都持有一定的资源并等待其他进程释放他们的所需的资源时，这些资源都被其他进程占据却不释放，就导致了死锁。</p><p>死锁的条件有四个：</p><ul><li>互斥</li><li>请求保持</li><li>不可剥夺</li><li>循环等待</li></ul><p>所以可以通过破坏除互斥之外的三个条件之一来预防死锁。也可以通过银行家算法等检测死锁，可以通过挂起或终止某些进程来解除死锁。</p><blockquote><p>老知识点，思路就是：预防(破坏条件)-检测(银行家)-解除(挂起，暴力终止)</p></blockquote><h2 id="介绍一下几种典型的锁">介绍一下几种典型的锁</h2><ul><li><strong>互斥锁</strong>：最常见的锁类型。任何时刻只允许一个线程持有，其他线程必须等待。</li><li>自旋锁：基于忙等待的锁，线程在尝试获取锁时会不断轮询，直到锁被释放。</li></ul><p>其他的锁都是基于这两个锁的：</p><ul><li>读写锁：允许多个线程同时读写和共享资源，只允许一个线程进行写操作。分为读(共享)和写(排他)两种状态。</li><li>悲观锁：认为多线程同时修改资源的可能性比较高，所以访问共享资源时要上锁。</li><li>乐观锁：多线程能够同时访问和修改，但是如果修改前后原资源发生变化，证明出现同时修改，则放弃本次操作。</li></ul><h2 id="讲一讲你理解的虚拟内存">讲一讲你理解的虚拟内存</h2><p>虚拟内存不是真实存在，而通过映射与实际物理地址空间对应。使每个进程看起来有连续的地址空间。</p><p>需要虚拟内存的原因：</p><ul><li>内存扩展：虚拟内存使得程序能够使用比实际内存更大的存储空间</li><li>内存隔离：虚拟地址空间让进程之间的地址空间相隔离</li><li>物理内存管理：虚拟内存允许操作系统动态地将数据和程序离散地加载到物理内存中，并且可以将不常用的数据或程序移到硬盘上，从而释放内存供其他进程使用。</li><li>页面交换：物理内存不足时，可以通过页面交换将外存作为虚拟内存使用，虚拟地扩大了内存空间。</li></ul><h1 id="day11">day11</h1><h2 id="线程同步的方式有哪些">线程同步的方式有哪些</h2><p>线程同步是多线程编程中，保证线程间互不干扰的一种机制，常见的线程同步机制有以下几种：</p><ul><li>互斥锁</li><li>条件变量：用于线程间通信，允许一个线程等待某个条件满足，其他线程可以发出信号通知等待线程，通常与互斥锁一起使用。</li><li>读写锁：允许多个读，只允许一个写</li><li>信号量</li></ul><h2 id="有哪些页面置换算法">有哪些页面置换算法</h2><ul><li>OPT最佳置换算法</li><li>FIFO先进先出</li><li>LRU最近最久未使用</li><li>LFU最不经常使用</li><li>CLOCK轮转</li></ul><blockquote><p>比较基础，很八股</p></blockquote><h1 id="day12">day12</h1><h2 id="熟悉哪些linux命令">熟悉哪些linux命令</h2><p><code>ls</code>、<code>cd</code>、<code>pwd</code>、<code>rm</code>、<code>touch</code>、<code>cat</code>、<code>vi/vim</code>、<code>chmod</code>、<code>chown</code>、<code>ping</code>、<code>ssh</code>、<code>ps</code>、<code>kill</code>、<code>apt-get</code>、<code>netstart</code>、<code>grep、awk、sed</code></p><blockquote><p>作用就不写了，太基础了，除了最后的三剑客，其他不会就搜搜吧</p></blockquote><h2id="linux如何查看进程杀进程看端口">Linux如何查看进程、杀进程、看端口</h2><ul><li>看进程：ps aux：列出所有进程和信息</li><li>杀进程：kill -9 pid：强制杀死这个pid</li><li>看端口：<code>lsof -i:端口号</code>查看特定端口占用。或者用<code>netstat -tulnp | grep 端口号</code>显示监听在该端口的服务及其进程ID。</li></ul><h2 id="说一下selectpollepoll">说一下select、poll、epoll</h2><p>I/O多路复用通常通过select、poll、epoll等系统调用实现</p><ul><li>select：最古老的I/O多路复用机制，可以监视多个文件描述符的可读、可写和错误状态。然而select的效率可能随着监视的文件描述符数量的增加而降低。</li><li>poll：poll是select的一种改进，使用轮询检查多个文件描述符</li><li>epoll：Linux特有的IO多路复用机制，相较于select和poll，在处理大量文件描述符时更高效。使用事件通知的方式，只有在文件描述符就绪时才会通知应用程序，而不使用轮询。</li></ul><p>尚未学习……</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day9(补)</title>
    <link href="/2024/08/18/leetcode-day9/"/>
    <url>/2024/08/18/leetcode-day9/</url>
    
    <content type="html"><![CDATA[<h1 id="找出字符串中第一个匹配项的下标"><ahref="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">找出字符串中第一个匹配项的下标</a></h1><blockquote><p>文章视频讲解：<ahref="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">代码随想录| 实现strStr()</a></p></blockquote><p>在母串中寻找子串，最优的算法就是KMP算法，十分经典，也很复杂，笔者从大一程序设计课上初接触到KMP到今天，已经写过4次KMP了，而这一次尝试纯手撕，仍然花了两个小时，最后还是倒在next数组求法上。功不唐捐，希望下一次再见KMP，能直接手撕出来。<strong>以下是个人偏感性理解，仅作参考</strong></p><h2 id="kmp更快的原因">KMP更快的原因</h2><p>暴力匹配就是把子串的头从0号一个一个往前加到m -n号，不匹配就加一。</p><p>而KMP不是无脑加一，会像动态规划那样记录，从而实现最优的最远的后移，最大程度减少匹配次数。</p><p>KMP像会记住之前已经匹配到了什么作为基业，在遇到挫折之后就不必从头开始，而是吃老本从基业再开始，直到把基业亏光再从头开始或者成功匹配。## KMP怎样记住哪些已经匹配过呢KMP用到了最长公共前后缀来记录哪些已经匹配过了。代码随想录里的说法是前缀表next[]### 什么是最长公共前后缀一个string的前缀就是除开最后一个元素的所有子串</p><p>后缀就是除开第一个元素的所有子串</p><p>比如对于<code>aacaab</code>来说：</p><p>前缀从长到短有：<code>aacaa</code>,<code>aaca</code>,<code>aac</code>,<code>aa</code>,<code>a</code></p><p>后缀从长到短有：<code>acaab</code>,<code>caab</code>,<code>aab</code>,<code>ab</code>,<code>b</code></p><p>最长公共前后缀就是前后缀里面相同的里面最长那一个</p><h3 id="什么是前缀表">什么是前缀表</h3><p>个人理解：</p><p>对于string来说，它的前缀表肯定和它的长度相同，前缀表的每一个值代表<strong>以当前位置结束的子串的最长公共前后缀长度</strong>。</p><p>比如对于串<code>aabaac</code>来说，其前缀表第一位就代表子串<code>a</code>的最长公共前后缀长度，即为0，因为只有一个，去掉第一个或者最后一个之后就没了；</p><p>其前缀表第二位就是1，代表子串<code>aa</code>的最长公共前后缀长度，因为去掉头尾之后都是<code>a</code>，而长度为1</p><p>所以<code>aabaac</code>的前缀表就为0 1 0 1 2 0</p><p><strong>一个特点</strong></p><p>如果子串的头尾都不相同，那么其最长公共前后缀长度肯定是0，因为其所有的前缀都有"头"，所有的后缀都有"尾"，肯定不会相同。</p><h3 id="前缀表怎么用呢">前缀表怎么用呢</h3><p>之前说到KMP记住之前匹配过哪些，失败之后不用从头开始，而是从"基业"开始，这里的"基业"就是公共前后缀。</p><p>如果匹配失败，失败这一位之前都是成功的，将视野缩小到已经匹配上的子串上面，这个子串的后缀是可以匹配上的，那么如果存在相同的前缀，则可以把相同的前缀往前移到后缀的位置，必定仍然匹配，这样就一下子提前了很多位，实现了"保底"</p><p>以上是抽象感性说法，下面上严谨代码：</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(haystack.<span class="hljs-built_in">size</span>() &lt; needle.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; prefix = <span class="hljs-built_in">next</span>(needle);<br>        <span class="hljs-type">int</span> m = haystack.<span class="hljs-built_in">size</span>(), n = needle.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= m;) &#123;<br>            <span class="hljs-keyword">if</span>(j == n) &#123;<br>                ans = i - n;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(haystack[i] == needle[j]) &#123;<br>                j++;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>)&#123;<br>                j = prefix[j - <span class="hljs-number">1</span>];<span class="hljs-comment">//回退吃老本</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>                j = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(s.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br><span class="hljs-comment">/*这一行可太妙了*/</span><span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) j = next[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(s[i] == s[j]) j++;<br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="重复的子字符串"><ahref="https://leetcode.cn/problems/repeated-substring-pattern/description/">重复的子字符串</a></h1><blockquote><p>文章视频讲解：<ahref="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">代码随想录| 重复的子字符串</a></p></blockquote><p>对于前缀表的深入理解和应用，建议打印出测试用例的前缀表，一看便知：重复子串第一次出现地方全是0，后面单调递增1、2、3、4……</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; pre = <span class="hljs-built_in">next</span>(s);<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(pre[len - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span> &amp;&amp; len % (len - pre[len - <span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(s.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++ )&#123;<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) j = ans[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(s[i] == s[j]) j++;<br>            ans[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深悼首次数模</title>
    <link href="/2024/08/07/%E6%B7%B1%E6%82%BC%E9%A6%96%E6%AC%A1%E6%95%B0%E6%A8%A1/"/>
    <url>/2024/08/07/%E6%B7%B1%E6%82%BC%E9%A6%96%E6%AC%A1%E6%95%B0%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="问题总结">问题总结</h1><p>首先总结此次数模的问题：</p><ol type="1"><li>Matlab语法文盲，包括但不限于：<ul><li>不关注数据类型，无意中把行向量当列向量计算</li><li>盲从GPT不自己看代码和参数，让GPT调整不合理参数，越调越不合理</li><li>粒子群的参数拿去跑遗传算法</li><li>不知道matlab文件后缀名含义</li><li>不知道figure可以直接选中调整，去一点一点调语句里的参数😅</li></ul></li><li>数学建模基础薄弱，包括但不限于：<ul><li>听不懂啥是多目标分析，以及其他各种名词</li><li>不知道啥是数学模型，只知道套算法模板和调库</li></ul></li><li>题目没看明白就走了很远，做完了发现初始参数都错了</li><li>跟队友交接混乱，一股脑把文件往群里丢，没有打包和说明文件结构</li><li>算法掌握模糊，忘记普通的Floyd是返回路径长度，需要的却是路径本身，浪费时间修改代码</li><li>思考不足，逻辑不顺，过于依赖网上的思路</li><li>数据不及时保存，文件结构混乱</li></ol><h1 id="踩过的坑">踩过的坑</h1><ol type="1"><li>行向量转列向量是：<code>vector = vector(:);</code>或者<code>v = v';</code>，</li></ol><p>注意：单引号可以将列向量再转为行向量的；冒号不管是行向量还是列向量，最终转换的结果都将是列向量</p><ol start="2" type="1"><li>matlab定义矩阵的方法：<code>matrix = zeros(row, col);</code>，初始化一个<spanclass="math inline">\(row\)</span>行<spanclass="math inline">\(col\)</span>列的零矩阵</li><li>存放不等长向量的方法：用单元数组来求，<code>a = cell(i, j);</code>初始化一个<spanclass="math inline">\(i\)</span>行，每行<spanclass="math inline">\(j\)</span>个元素的单元数组，单元里可以是任何变量</li><li>行向量为某个值赋值方法：<code>a(i) = y;</code>将<spanclass="math inline">\(y\)</span> 赋给行向量<spanclass="math inline">\(a\)</span> 的第<spanclass="math inline">\(i\)</span> 列</li></ol><ul><li><p>使用<code>a(1,:)=[1 1 1]</code>方式对矩阵一行进行赋值</p></li><li><p>各种赋值方法见：<ahref="http://t.csdnimg.cn/FoVl3">csdn博客</a></p></li></ul><ol start="5" type="1"><li>matlab各种括号访问规则：<ahref="http://t.csdnimg.cn/DF1Gx">csdn博客</a></li><li>matlab的rand()返回的是0到1之间的一个数</li><li>多去mathworks搜方法重载和参数含义😭</li></ol><h1 id="下次要做">下次要做</h1><ol type="1"><li>预备在python上重演被语法暴捶</li><li>准备好方便的手册，方便脱离GPT翻阅</li><li>保存所有的图表和数据，丰富附件</li><li>做好文件结构管理，和队友交接的时候打包整个环境</li><li>也许可以冲一个chatGPT Plus。。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)</title>
    <link href="/2024/08/02/org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found/"/>
    <url>/2024/08/02/org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found/</url>
    
    <content type="html"><![CDATA[<h1id="org.apache.ibatis.binding.bindingexception-invalid-bound-statement-not-found">org.apache.ibatis.binding.BindingException:Invalid bound statement (not found)</h1><h2 id="种可能的原因">10种可能的原因</h2><ol type="1"><li>namespace与实际接口的全限定名不一致</li><li>XML文件头出错，一般是复制错或者打错字</li><li>SQL语句id出错，id与实际的接口方法名不一致</li><li>没写对resultType中实体类的全限定名</li><li>resources文件夹下的包实际上没有分层次，只是加了点</li><li>target里面没有XML，没有构造进去</li><li>用成了mybatis-plus，配置的却是mybatis</li><li>XML文件和接口的所在的包名路径以及名称不一致，而mybatis-location又没有配置好。比如XML和接口都放在了java文件夹下，而又没有配置@MapperScan或者mybatis-location</li><li>启动类没有加@MapperScan或接口没有加<span class="citation"data-cites="Mapper注解">@Mapper注解</span></li><li><del>mybatis.type-aliases-type没有配置或配置错误</del>(实证没配置也行)</li><li>你以为的XML文件实际没有后缀名</li></ol><h2 id="问题展示">问题展示</h2><p><strong>XML文件</strong></p><figure><img src="https://s3.bmp.ovh/imgs/2024/08/01/0ca92b962e2eb7f7.png"alt="xml文件" /><figcaption aria-hidden="true">xml文件</figcaption></figure><p><strong>项目结构</strong></p><figure><img src="https://s3.bmp.ovh/imgs/2024/08/01/6593aa3aa346b24f.png"alt="目录树" /><figcaption aria-hidden="true">目录树</figcaption></figure><p><strong>target目录</strong></p><figure><img src="https://s3.bmp.ovh/imgs/2024/08/01/cf97150d678f2c27.png"alt="target目录树" /><figcaption aria-hidden="true">target目录树</figcaption></figure><p><strong>application.properties文件</strong></p><p><img src = 'https://s3.bmp.ovh/imgs/2024/08/02/2f72df281337396e.png' ></p><p><strong>Mapper接口</strong></p><p><img src = 'https://s3.bmp.ovh/imgs/2024/08/01/29ab84bc2404350f.png' ></p><p><strong>启动类</strong></p><p><img src = 'https://s3.bmp.ovh/imgs/2024/08/01/18df1d05ea3ca0f1.png' ></p><p><strong>报错信息</strong></p><p><img src = 'https://s3.bmp.ovh/imgs/2024/08/01/dd32ece0648c3d1f.png' ></p><h2 id="问题描述">问题描述</h2><p>问题在于XML没有跟Mapper接口关联上，通过注解开发是有效的，但换成XML映射就报错。</p><p>已经检查过id、namespace、resultType、XML文件头等是否出现打错。</p><p>配置了mybatis的实体类位置、xml位置、添加了@Mapper注解、为启动类添加了@MapperScan注解、检查了target中有没有XML、检查了是否用成了mybatis-plus。</p><p>MybatisX插件已经匹配上了，出现红蓝鸟标识。</p><p>最终仍然没用，增删改查接口没一个能用。</p><h2 id="解决过程">解决过程</h2><p>尝试了能搜到的所有方法仍无效后。</p><p>我在项目中新建了一个模块：</p><ul><li>创建了mapper包和一个pojo包</li><li>复制了一个实体类和一个select * 的查询接口过来</li><li>复制了application.properties的连接数据库的配置</li><li>在resources下新建包，又创建了一个XML，填好内容后编写了一个简单测试方法来调用这个select*接口。</li></ul><p>成功了，xml成功与接口关联并且select *了。证明是可以实现XML与接口关联的。</p><p>加上controller层、service层，仍然可以映射，访问成功。</p><p>于是开两个窗口与新建的模块仔细对比，发现除了模块名完全没区别，那么区别就只能在IDE上看不到的位置。</p><p>最后发现了，就是原因5，实际文件夹没有按点dot分层设置，实际文件结构是这样的:com--newyear--goovermanege<strong>.</strong>mapper</p><p>前两级目录分开了，但是最后一层目录名却是<code>goovermanage.mapper</code>，于是手动拆分，再次测试，成功。</p><p>原来是这么小一个BUG。。真是菜啊，查了两天下午才查出来😅</p><h2 id="预防措施">预防措施</h2><p>在resourses下创建分级目录时，不要打点，打"/"。比如com.ABC.mapper就打成com/ABC/mapper。</p><p>这样实际的文件就会分层，而不是简单地在文件名里加点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些算法小记录</title>
    <link href="/2024/07/30/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/07/30/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="同余定理">同余定理</h1><p>给定一个正整数<span class="math inline">\(m\)</span>，如果两个整数<span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 满足 <spanclass="math inline">\((a-b)\)</span> 能够被m整除，即 <spanclass="math inline">\((a-b)/m\)</span> 得到一个整数，那么就称整数 <spanclass="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 对模 <spanclass="math inline">\(m\)</span> 同余，记作 <spanclass="math inline">\(a≡b(mod\ m)\)</span>。</p><p>两个整数<spanclass="math inline">\(a、b\)</span>，若它们除以整数<spanclass="math inline">\(m\)</span>的余数相等，则称整数 <spanclass="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 对模 <spanclass="math inline">\(m\)</span> 同余，记作 <spanclass="math inline">\(a≡b(mod\ m)\)</span>。</p><p>即 <span class="math display">\[(a-b)\ mod\ m = 0\ ⇔\ a\ mod\ m\ =\ b\ mod\ m\]</span> 定理适用于对一个表达式取模时拆括号。</p><h1 id="费马小定理">费马小定理</h1><p>整数 <span class="math inline">\(a\)</span> 和素数 <spanclass="math inline">\(p\)</span>，有： <span class="math display">\[a^{p-1}\ \equiv 1\ (mod\ p)\]</span> ps. latex恒等于符号使用<code>\equiv</code>，这部分latex代码没写过，可以看源码复习复习</p><p>定理适用于对幂取模时快速计算，如取<spanclass="math inline">\(2^{100}\)</span>模<spanclass="math inline">\(13\)</span>： <span class="math display">\[\begin{aligned}2^{100}&amp; \equiv 2^{12\times8+4} \\&amp; \equiv (2^{12})^8\cdot2^4 \\&amp; \equiv 1^8\cdot16 \\&amp; \equiv 16 \\&amp; \equiv 3 \pmod{13}\end{aligned}\]</span> 余数就是<span class="math inline">\(3\)</span>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>完结撒花</title>
    <link href="/2024/07/27/%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1/"/>
    <url>/2024/07/27/%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1/</url>
    
    <content type="html"><![CDATA[<p>🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉</p><p>五月末在b站评论抽奖，意外抽中了随想录的名额。之前也偶尔跟着随想录刷过题，觉得随想录的题解写得很易懂，而且难度对于我这种算法小菜来说也比较合适。</p><p>虽然算法群的热度只持续了不到一个月，但是这种集体感比一个人写题要好得多🤗，每天有任务，也可以假想其他录友在监督自己，到后期打卡人数越来越少，自己能跟上进度也有一点小骄傲😎。自律不行就靠他律，比起之前断断续续的刷题，这次能够坚持两个月刷题已是巨大进步。为了打卡还搞了一个个人博客玩。中间也落下过几次，期末考试更是落下一周，让我知道原来只是坚持每天3道题都是如此艰难，但是最后还是跟上来了。这两个月对我的影响不仅是更会写力扣题，也让我知道了规律地坚持做一件事就是改变的方法💪。</p><p>刷题的最大障碍是偷懒和遗忘：遇到难题不去思考，哪怕看答案都不想去看，这是不行的；刷过题后不去复习重刷，时间一久等于没刷，再一次遇到，倒是知道自己做过，但是写不出来了。两数之和在一个月后再写都写得磕磕绊绊，一刷还是远远不够的，毕竟dp刷100题才算入门，总量刷到500题才能够说算法入门。今后继续刷题，也会二刷三刷随想录来巩固。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day64</title>
    <link href="/2024/07/25/leetcode-day64/"/>
    <url>/2024/07/25/leetcode-day64/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0097.小明逛公园.html">Floyd</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0126.骑士的攻击astar.html">A*</a></li></ul><h1 id="floyd">Floyd</h1><h3 id="题目"><strong>题目</strong></h3><p>一个公司在全国有 <code>n</code>个分部，它们之间有的有道路连接。一开始，所有分部通过这些道路两两之间互相可以到达。</p><p>公司意识到在分部之间旅行花费了太多时间，所以它们决定关闭一些分部（<strong>也可能不关闭任何分部</strong>），同时保证剩下的分部之间两两互相可以到达且最远距离不超过<code>maxDistance</code> 。</p><p>两个分部之间的 <strong>距离</strong> 是通过道路长度之和的<strong>最小值</strong> 。</p><p>给你整数 <code>n</code> ，<code>maxDistance</code> 和下标从<strong>0</strong> 开始的二维整数数组 <code>roads</code> ，其中<code>roads[i] = [ui, vi, wi]</code> 表示一条从 <code>ui</code> 到<code>vi</code> 长度为 <code>wi</code>的 <strong>无向</strong>道路。</p><p>请你返回关闭分部的可行方案数目，满足每个方案里剩余分部之间的最远距离不超过<code>maxDistance</code>。</p><p><strong>注意</strong>，关闭一个分部后，与之相连的所有道路不可通行。</p><p><strong>注意</strong>，两个分部之间可能会有多条道路。</p><h3 id="思路"><strong>思路</strong></h3><p>枚举每种关闭方案，使用Floyd求最短路，然后判断是否合法。</p><p>详见代码注释</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//跟敲学习，行行注释</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberOfSets</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> maxDistance, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrix</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, INT_MAX / <span class="hljs-number">2</span>));<span class="hljs-comment">//floyd需要的邻接矩阵</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; road : roads) &#123;<span class="hljs-comment">//根据roads，初始化邻接矩阵</span><br>            <span class="hljs-type">int</span> x = road[<span class="hljs-number">0</span>], y = road[<span class="hljs-number">1</span>], weight = road[<span class="hljs-number">2</span>];<span class="hljs-comment">//路径两端xy，weight为路的权重</span><br>            matrix[x][y] = <span class="hljs-built_in">min</span>(matrix[x][y], weight);<br>            matrix[y][x] = <span class="hljs-built_in">min</span>(matrix[y][x], weight);<span class="hljs-comment">//无向图，视作两条有向边</span><br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n);<span class="hljs-comment">//去掉一些节点后的邻接矩阵</span><br>        <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> s) -&gt; <span class="hljs-type">bool</span> &#123;<span class="hljs-comment">//lambda表达式，相当于bool check(int s)&#123;&#125;，同时外部变量都可访问</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<span class="hljs-comment">//参数s的前n位代表是否取这一个节点</span><br>                <span class="hljs-keyword">if</span>((s &gt;&gt; i) &amp; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//若s的i位为1，则取</span><br>                    f[i] = matrix[i];<span class="hljs-comment">//只将保留的节点信息保存，去掉的都变成了无穷</span><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k &lt; n;k++) &#123;<span class="hljs-comment">//遍历n个节点，进行插值</span><br>                <span class="hljs-keyword">if</span>(((s &gt;&gt; k) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//若s的k位为0，不选</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<span class="hljs-comment">//k位为1，选择该节点，下一步遍历整个图，检查最优值是否发生变化</span><br>                    <span class="hljs-keyword">if</span>(((s &gt;&gt; i) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//若s的i位为0，不选</span><br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<span class="hljs-comment">//检查从i到其他所有节点的最短路是否变化</span><br>                        f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][k] + f[k][j]);<span class="hljs-comment">//维护</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//检查s对应的选择情况，是否满足条件</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>                <span class="hljs-keyword">if</span>(((s &gt;&gt; i) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//没选，跳过</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; i;j++) &#123;<span class="hljs-comment">//无向图，靠后的节点覆盖靠前的节点，邻接矩阵变三角矩阵</span><br>                    <span class="hljs-keyword">if</span>((s &gt;&gt; j) &amp; <span class="hljs-number">1</span> &amp;&amp; f[i][j] &gt; maxDistance) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;s &lt; (<span class="hljs-number">1</span> &lt;&lt; n);s++) &#123;<span class="hljs-comment">//枚举子集</span><br>            ans += <span class="hljs-built_in">check</span>(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="a-star">A-star</h1><h3 id="题目-1"><strong>题目</strong></h3><p>在象棋中，马和象的移动规则分别是“马走日”和“象走田”。现给定骑士的起始坐标和目标坐标，要求根据骑士的移动规则，计算从起点到达目标点所需的最短步数。</p><p>棋盘大小 1000 x 1000（棋盘的 x 和 y 坐标均在 [1, 1000]区间内，包含边界）</p><h6 id="输入描述">输入描述</h6><p>第一行包含一个整数 n，表示测试用例的数量，1 &lt;= n &lt;= 100。</p><p>接下来的 n 行，每行包含四个整数 a1, a2, b1,b2，分别表示骑士的起始位置 (a1, a2) 和目标位置 (b1, b2)。</p><h6 id="输出描述">输出描述</h6><p>输出共 n行，每行输出一个整数，表示骑士从起点到目标点的最短路径长度。</p><h6 id="提示信息">提示信息</h6><p>骑士移动规则如图，红色是起始位置，黄色是骑士可以走的地方。</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20240626104833.png"alt="盗链随想录" /><figcaption aria-hidden="true">盗链随想录</figcaption></figure><h3 id="思路-1"><strong>思路</strong></h3><p>推荐看随想录的图： <ahref="https://www.programmercarl.com/kamacoder/0126.骑士的攻击astar.html#思路">代码随想录| A-star</a></p><p>A*是启发式搜索，一开始知道要去的地方在哪里，所以根据终点位置，和具体的题目情景，选择合适的距离计算方式(曼哈顿、欧拉、切比雪夫、信息熵……)，根据距离来选择下一步怎么走。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> moves[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> dir[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>&#125;;<br><span class="hljs-type">int</span> b1, b2;<br><span class="hljs-comment">// F = G + H</span><br><span class="hljs-comment">// G = 从起点到该节点路径消耗</span><br><span class="hljs-comment">// H = 该节点到终点的预估消耗</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Knight</span>&#123;<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-type">int</span> g,h,f;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Knight &amp; k) <span class="hljs-type">const</span>&#123;  <span class="hljs-comment">// 重载运算符， 从小到大排序</span><br>     <span class="hljs-keyword">return</span> k.f &lt; f;<br>    &#125;<br>&#125;;<br><br>priority_queue&lt;Knight&gt; que;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Heuristic</span><span class="hljs-params">(<span class="hljs-type">const</span> Knight&amp; k)</span> </span>&#123; <span class="hljs-comment">// 欧拉距离</span><br>    <span class="hljs-keyword">return</span> (k.x - b1) * (k.x - b1) + (k.y - b2) * (k.y - b2); <span class="hljs-comment">// 统一不开根号，这样可以提高精度</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">astar</span><span class="hljs-params">(<span class="hljs-type">const</span> Knight&amp; k)</span></span><br><span class="hljs-function"></span>&#123;<br>    Knight cur, next;<br>que.<span class="hljs-built_in">push</span>(k);<br><span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cur=que.<span class="hljs-built_in">top</span>(); que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(cur.x == b1 &amp;&amp; cur.y == b2)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>&#123;<br>next.x = cur.x + dir[i][<span class="hljs-number">0</span>];<br>next.y = cur.y + dir[i][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span>(next.x &lt; <span class="hljs-number">1</span> || next.x &gt; <span class="hljs-number">1000</span> || next.y &lt; <span class="hljs-number">1</span> || next.y &gt; <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(!moves[next.x][next.y])<br>&#123;<br>moves[next.x][next.y] = moves[cur.x][cur.y] + <span class="hljs-number">1</span>;<br><br>                <span class="hljs-comment">// 开始计算F</span><br>next.g = cur.g + <span class="hljs-number">5</span>; <span class="hljs-comment">// 统一不开根号，这样可以提高精度，马走日，1 * 1 + 2 * 2 = 5</span><br>                next.h = <span class="hljs-built_in">Heuristic</span>(next);<br>                next.f = next.g + next.h;<br>                que.<span class="hljs-built_in">push</span>(next);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, a1, a2;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; b1 &gt;&gt; b2;<br>        <span class="hljs-built_in">memset</span>(moves,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(moves));<br>        Knight start;<br>        start.x = a1;<br>        start.y = a2;<br>        start.g = <span class="hljs-number">0</span>;<br>        start.h = <span class="hljs-built_in">Heuristic</span>(start);<br>        start.f = start.g + start.h;<br><span class="hljs-built_in">astar</span>(start);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) que.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 队列清空</span><br>cout &lt;&lt; moves[b1][b2] &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day63</title>
    <link href="/2024/07/25/leetcode-day63/"/>
    <url>/2024/07/25/leetcode-day63/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li>SPFA<ul><li><ahref="https://www.programmercarl.com/kamacoder/0094.城市间货物运输I-SPFA.html#背景">无负权回路SPFA</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0095.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93II.html">负权回路SPFA</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0096.城市间货物运输III.html#思路">单源有限最短路SPFA</a></li></ul></li></ul><h1 id="无负权回路spfa">无负权回路SPFA</h1><h3 id="题目"><strong>题目</strong></h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1到 n的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本-政府补贴</strong>。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>请找出从城市 1 到城市 n的所有可能路径中，综合政府补贴后的最低运输成本。如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。</p><p><strong>城市 1 到城市 n之间可能会出现没有路径的情况，同时保证道路网络中不存在任何负权回路。</strong></p><h6 id="输入描述">输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达t 号城市，道路权值为 v （单向图）。</p><h6 id="输出描述">输出描述</h6><p>如果能够从城市 1 到连通到城市 n，请输出一个整数，表示运输成本。如果该整数是负数，则表示实现了盈利。如果从城市1 没有路径可达城市 n，请输出 "unconnected"。</p><h3 id="思路"><strong>思路</strong></h3><p>昨天使用Bellman_ford求解了该问题，SPFA为Bellman_ford的队列优化版。</p><p>上集提到，对全部边松弛一次，相当于对起点出发一条边的距离求了一次最短路。</p><p>那么在第二次全边松弛的时候，就可以不用再对起点出发一条边松弛了，直接拿结果即可。</p><p>所以，<strong>只需要对上一次松弛时更新过的节点作为出发点所连接的边进行松弛</strong>（carl说法）</p><p>就是继承上一次已经确定下来的点，再出发一条边。</p><p>优化的点在于，如果不使用队列优化，就按顺序去松弛，很容易松弛到未计算过节点延申出的边。而使用队列，则保证了在队列(是个数据结构能存就行，没有顺序要求)中的一定是计算过的节点，避免了无用的"松弛"</p><p>事实上，在未计算过的节点的延申边做的松弛无效，以初始的minDist举例比较好理解，如果节点未计算过，则其minDist为INT_MAX，如果对该点的边计算，结果肯定是有问题的。</p><p>所以，松弛n次得到距离n的点的最短路，已经不适用这里了，因为松弛已经不针对全图，次数的标准变得模糊。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, val;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; val;<br>        grid[x].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(y, val));<br>    &#125;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>    minDist[start] = <span class="hljs-number">0</span>;<br>    <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;e : grid[cur]) &#123;<br>            <span class="hljs-type">int</span> x = cur, y = e.first, wt = e.second;<br>            <span class="hljs-keyword">if</span>(minDist[y] &gt; minDist[x] + wt) &#123;<br>                minDist[y] = minDist[x] + wt;<span class="hljs-comment">//更新更短的路径</span><br>                q.<span class="hljs-built_in">push</span>(y);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">&quot;unconnected&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="负权回路spfa">负权回路SPFA</h1><h3 id="题目-1"><strong>题目</strong></h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1到 n的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本-政府补贴</strong>。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>然而，在评估从城市 1 到城市 n的所有可能路径中综合政府补贴后的最低运输成本时，存在一种情况：<strong>图中可能出现负权回路。</strong>负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。为了避免货物运输商采用负权回路这种情况无限的赚取政府补贴，算法还需检测这种特殊情况。</p><p>请找出从城市 1 到城市 n的所有可能路径中，综合政府补贴后的最低运输成本。同时能够检测并适当处理负权回路的存在。</p><p><strong>城市 1 到城市 n 之间可能会出现没有路径的情况</strong></p><h6 id="输入描述-1">输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达t 号城市，道路权值为 v。</p><h6 id="输出描述-1">输出描述</h6><p>如果没有发现负权回路，则输出一个整数，表示从城市 <code>1</code>到城市 <code>n</code>的最低运输成本（包括政府补贴）。如果该整数是负数，则表示实现了盈利。如果发现了负权回路的存在，则输出"circle"。如果从城市 1 无法到达城市 n，则输出 "unconnected"。</p><h3 id="思路-1"><strong>思路</strong></h3><p>n-1次松弛就能找到所有点的最短路径，存在负权回路，当且仅当第n次松弛得到更短的路径。</p><p>所以只需要多松弛一次，如果出现更短，则有回路，如果没有，则没有负权回路。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, val;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; val;<br>        grid[x].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(y, val));<br>    &#125;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>    minDist[start] = <span class="hljs-number">0</span>;<br>    <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//新增代码，记录节点加入队列几次</span><br>    count[start]++;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;e : grid[cur]) &#123;<br>            <span class="hljs-type">int</span> x = cur, y = e.first, wt = e.second;<br>            <span class="hljs-keyword">if</span>(minDist[y] &gt; minDist[x] + wt) &#123;<br>                minDist[y] = minDist[x] + wt;<span class="hljs-comment">//更新更短的路径</span><br>                q.<span class="hljs-built_in">push</span>(y);<br>                count[y]++;<span class="hljs-comment">//新增代码</span><br>                <span class="hljs-keyword">if</span>(count[y] == n) &#123;<span class="hljs-comment">//如果有节点加入队列超过n-1次，说明有负权回路</span><br>                    flag = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//清空队列</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag) cout &lt;&lt; <span class="hljs-string">&quot;circle&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">&quot;unconnected&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单源有限最短路spfa">单源有限最短路SPFA</h1><h3 id="题目-2"><strong>题目</strong></h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1到 n的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本-政府补贴。</strong>权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>请计算在最多经过 k 个城市的条件下，从城市 src 到城市 dst的最低运输成本。</p><h6 id="输入描述-2">输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达t 号城市，道路权值为 v。</p><p>最后一行包含三个正整数，src、dst、和 k，src 和 dst 为城市编号，从 src到 dst 经过的城市数量限制。</p><h6 id="输出描述-2">输出描述</h6><p>输出一个整数，表示从城市 src 到城市 dst的最低运输成本，如果无法在给定经过城市数量限制下找到从 src 到 dst的路径，则输出 "unreachable"，表示不存在符合条件的运输方案。</p><h3 id="思路-2"><strong>思路</strong></h3><p>题目的不同点在于，有了途径城市数量限制。也就是从一个点出发几条边有限制，也就是松弛次数有限制，那么针对次数过少，就得找到n-1次松弛前多种可能中最短的一条；次数过多，就得多走负权回路降本。</p><p>控制次数，可以使用层序的思想(或者叫写法)，而且还需要控制minDist的更新，由于SPFA的原写法可能在一个循环内更新了多次同一个值，这就无法控制中间节点数量了，得每一次都完全依赖前一轮循环的计算结果，避免超限；而选择更短的路，可以直接使用SPFA的原写法逻辑。</p><p>优化：对于同一层的节点，可能会有相互通的道路，这条路可以走，但是对于已经处理过的同一层节点就不需要重复入队了。开一个boolused数组记录本层哪些节点已经处理过，但是松弛仍需进行，只是不再入队。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, wt;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; wt;<br>        grid[x].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(y, wt));<br>    &#125;<br>    <span class="hljs-type">int</span> start, end, limit;<br>    cin &gt;&gt; start &gt;&gt; end &gt;&gt; limit;<br>    limit++;<span class="hljs-comment">//经过限制-&gt;步数限制</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">copy</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    minDist[start] = <span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">while</span>(limit-- &amp;&amp; !q.<span class="hljs-built_in">empty</span>()) &#123;<br>        copy = minDist;<br>        size = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">while</span>(size--) &#123;<br>            <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp; e : grid[cur]) &#123;<br>                <span class="hljs-type">int</span> y = e.first;<br>                <span class="hljs-type">int</span> wt = r.second;<br>                <span class="hljs-keyword">if</span>(minDist[y] &gt; minDist[cur] + wt) &#123;<br>                    minDist[y] = minDist[cur] + wt;<br>                    <span class="hljs-keyword">if</span>(used[y]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//跳过同层已处理节点</span><br>                    used[y] = <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(y);<br>                &#125;<br>                <br>&#125;<br>&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">&quot;unconnctable&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day62</title>
    <link href="/2024/07/23/leetcode-day62/"/>
    <url>/2024/07/23/leetcode-day62/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0047.%E5%8F%82%E4%BC%9Adijkstra%E5%A0%86.html">Dijkstra堆优化版</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I.html">Bellman_ford</a></li></ul><h1 id="dijkstra堆优化版">Dijkstra堆优化版</h1><h3 id="题目"><strong>题目</strong></h3><p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p><p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p><p>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个正整数，第一个正整数 N 表示一共有 N个公共汽车站，第二个正整数 M 表示有 M 条公路。</p><p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p><h6 id="输出描述">输出描述</h6><p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p><h3 id="思路"><strong>思路</strong></h3><p>朴素版dijkstra两次遍历寻找当前点的最近点，以点为中心。堆优化以边的角度出发，直接排序边，然后从边的小顶堆中取出最短边，即是距离源点最近的点所需的边，点和边权都拿到了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmp</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.second &lt; b.second;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">g</span>(N + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; M;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, wt;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; wt;<br>        g[x].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(y, wt));<br>    &#125;<br>    <br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, cmp&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, INT_MAX / <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <br>    minDist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">if</span>(used[cur.first]) <span class="hljs-keyword">continue</span>;<br>        <br>        <span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; e : g[cur.first]) &#123;<br>            <span class="hljs-keyword">if</span>(minDist[e.first] &gt; cur.second + e.second) &#123;<br>                minDist[e.first] = cur.second + e.second;<br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(e.first, minDist[e.first]));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(minDist.<span class="hljs-built_in">back</span>() != INT_MAX / <span class="hljs-number">2</span>)cout &lt;&lt; minDist.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="bellman_ford">Bellman_ford</h1><h3 id="题目-1"><strong>题目</strong></h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1到 n的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本-政府补贴</strong>。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>请找出从城市 1 到城市 n的所有可能路径中，综合政府补贴后的最低运输成本。如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。</p><p><strong>城市 1 到城市 n之间可能会出现没有路径的情况，同时保证道路网络中不存在任何负权回路。</strong></p><h6 id="输入描述-1">输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达t 号城市，道路权值为 v （单向图）。</p><h6 id="输出描述-1">输出描述</h6><p>如果能够从城市 1 到连通到城市 n，请输出一个整数，表示运输成本。如果该整数是负数，则表示实现了盈利。如果从城市1 没有路径可达城市 n，请输出 "unconnected"。</p><h3 id="思路-1"><strong>思路</strong></h3><p>初次接触单源负权图最短路，跟敲学习。</p><p>由于有负权道路，所以不能dijkstra，需要采取“松弛”操作。</p><p>“松弛”理解为：如果通过 A 到 B这条边可以获得更短的到达B节点的路径，就更新<code>minDist[B] = minDist[A] + value</code>的过程。要点在于：</p><ul><li>松弛是对边的操作，对边进行“松弛”</li><li>对所有边松弛一次，相当于计算起点出发走一条边的节点的最短距离</li><li>由于n个点的图，起点终点最多n-1条边，所以松弛n-1次绝对可求出最短距离，所有点到起点的最短距离都能求。</li></ul><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, wt;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; wt;<br>        grid.<span class="hljs-built_in">emplace_back</span>(std::initializer_list&lt;<span class="hljs-type">int</span>&gt;&#123;x, y, wt&#125;);<br>    &#125;<span class="hljs-comment">//用push_back就可以直接大括号，但是emplace_back就必须传初始化器</span><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX / <span class="hljs-number">2</span>)</span></span>;<br>    minDist[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;<br>        <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp; e : grid) &#123;<br>            <span class="hljs-type">int</span> from = e[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> to = e[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> wt = e[<span class="hljs-number">2</span>];<br>            <br>            <span class="hljs-keyword">if</span>(minDist[from] != INT_MAX / <span class="hljs-number">2</span> &amp;&amp; minDist[to] &gt; minDist[from] + wt)<br>                minDist[to] = minDist[from] + wt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(minDist.<span class="hljs-built_in">back</span>() == INT_MAX / <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;unconnected&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist.<span class="hljs-built_in">back</span>();<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day61</title>
    <link href="/2024/07/22/leetcode-day61/"/>
    <url>/2024/07/22/leetcode-day61/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://kamacoder.com/problempage.php?pid=1191">软件构建 |拓扑排序</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0117.软件构建.html">参加科学大会| dij</a></li></ul><h1 id="软件构建-拓扑排序">软件构建 | 拓扑排序</h1><h3 id="题目"><strong>题目</strong></h3><p>某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N -1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 &lt;= A, B &lt;= N -1）。请编写一个算法，用于确定文件处理的顺序。</p><h6 id="输入描述">输入描述</h6><p>第一行输入两个正整数 N, M。表示 N 个文件之间拥有 M 条依赖关系。</p><p>后续 M 行，每行两个正整数 S 和 T，表示 T 文件依赖于 S 文件。</p><h6 id="输出描述">输出描述</h6><p>输出共一行，如果能处理成功，则输出文件顺序，用空格隔开。</p><p>如果不能成功处理（相互依赖），则输出 -1。</p><h3 id="思路"><strong>思路</strong></h3><p>拓扑排序不是关键路径，别学混了。拓扑排序很简单，每次找入度为0的点就行。实现的时候注意代码细节。<del>竟然WA了4发，丢人啊</del></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    <span class="hljs-keyword">if</span>(N == <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(N == <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">rely</span>(N);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(N, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; M;i++) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        inDegree[b]++;<br>        rely[a].<span class="hljs-built_in">emplace_back</span>(b);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(N, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(;ans.<span class="hljs-built_in">size</span>() &lt; N;) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; N;j++) &#123;<br>            <span class="hljs-keyword">if</span>(inDegree[j] == <span class="hljs-number">0</span> &amp;&amp; !used[j]) &#123;<br>                ans.<span class="hljs-built_in">emplace_back</span>(j);<br>                used[j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">while</span>(!rely[j].<span class="hljs-built_in">empty</span>()) &#123;<br>                    inDegree[rely[j].<span class="hljs-built_in">back</span>()]--;<br>                    rely[j].<span class="hljs-built_in">pop_back</span>();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<span class="hljs-comment">//这里就是细节，如果想一次完全遍历找到所有入度0</span><br>                <span class="hljs-comment">//有点不好实现，没想出来，一直试，都是在这个地方错，最后摆烂了</span><br>                <span class="hljs-comment">//放弃一轮找多个，见好就收。</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == N - <span class="hljs-number">1</span>) &#123;<br>                cout &lt;&lt; <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i++) &#123;<br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>    cout &lt;&lt; ans.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参加科学大会-dij">参加科学大会 | dij</h1><h3 id="题目-1"><strong>题目</strong></h3><p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p><p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p><p>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</p><h6 id="输入描述-1">输入描述</h6><p>第一行包含两个正整数，第一个正整数 N 表示一共有 N个公共汽车站，第二个正整数 M 表示有 M 条公路。</p><p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p><h6 id="输出描述-1">输出描述</h6><p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p><h3 id="思路-1"><strong>思路</strong></h3><p>dijkstra算法的思想就是，维护一个最近距离表，dijkstra算法应用于单源最短路场景，所以只需要一行，记录源点到其他点的最短距离，最后一个点就是终点。一个一个点标记访问，一开始无法到达的点距离设为<spanclass="math inline">\(\infty\)</span>，能够到达的点就更新距离。每次选取最近的点标记访问，同时依据这个点更新源点到其他点的最近距离。</p><p>参照carl的三部曲：</p><ul><li>第一步，选源点到哪个节点近且该节点未被访问过</li><li>第二步，该最近节点被标记访问过</li><li>第三步，更新非访问节点到源点的距离（即更新minDist数组）</li></ul><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(N + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N + <span class="hljs-number">1</span>, INT_MAX / <span class="hljs-number">2</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; M;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, wt;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; wt;<br>        g[x][y] = wt;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(N, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, INT_MAX / <span class="hljs-number">2</span>)</span></span>;<br>    minDist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> minVal = INT_MAX / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= N;j++) &#123;<br>            <span class="hljs-keyword">if</span>(minDist[j] &lt; minVal &amp;&amp; !used[j]) &#123;<br>                minVal = minDist[j];<br>                cur = j;<br>            &#125;<br>        &#125;<br>        used[cur] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= N;j++) &#123;<br>            <span class="hljs-keyword">if</span>(!used[j] &amp;&amp; g[cur][j] != INT_MAX / <span class="hljs-number">2</span> &amp;&amp;minVal + g[cur][j] &lt; minDist[j]) &#123;<br>                minDist[j] = minVal + g[cur][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(minDist.<span class="hljs-built_in">back</span>() != INT_MAX / <span class="hljs-number">2</span>)cout &lt;&lt; minDist.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>前几天有一道题也是dij，可以回去看看。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day59</title>
    <link href="/2024/07/20/leetcode-day59/"/>
    <url>/2024/07/20/leetcode-day59/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://kamacoder.com/problempage.php?pid=1053">寻宝</a></li><li><ahref="https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/description/">将石头分散到网格的最少移动次数</a><span class="label label-warning">medium</span></li></ul><h1 id="寻宝">寻宝</h1><h2 id="题目"><strong>题目</strong></h2><p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p><p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将所有岛屿联通起来（注意：这是一个无向图）。</p><p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个整数V 和 E，V代表顶点数，E代表边数。顶点编号是从1到V。例如：V=2，一个有两个顶点，分别是1和2。</p><p>接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2为边的起点和终点，val代表边的权值。</p><h6 id="输出描述">输出描述</h6><p>输出联通所有岛屿的最小路径总距离。</p><h2 id="思路"><strong>思路</strong></h2><p>Prim和Kruskal都是求最小生成树的算法。</p><h3 id="prim算法">Prim算法</h3><p>Prim是每次往树中加节点，第一个节点随便选，然后：</p><ol type="1"><li>获取其他点距离树的最短距离</li><li>选取距离树最近的点加入树中</li><li>更新其他点距离树的最近距离</li></ol><p>使用used数组判断点是否加入，只需选取 <spanclass="math inline">\(n-1\)</span> 次点即可构成最小生成树。</p><h2 id="kruskal算法">Kruskal算法</h2><p>Kruskal是每次往树中加边，只要不是树内的边，都可以往里加，从小到大：</p><ol type="1"><li>获取图内最短边</li><li>若该边不在树内，则加入树内，否则跳过</li></ol><p>具体代码实现要注意，不能像Prim那样直接使用used数组判断是否将所有点加入树，Kruskal中途是不连通的，需要使用并查集来判断是否连通，否则会缺边。</p><h2 id="代码">代码</h2><h3 id="prim">Prim</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> V, E;<br>    cin &gt;&gt; V &gt;&gt; E;<br>    vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(V + <span class="hljs-number">1</span>, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; E;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, wt;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; wt;<br>        grid[x].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(y, wt));<br>        grid[y].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(x, wt));<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(V + <span class="hljs-number">1</span>, INT_MAX / <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(V + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    visited[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    minDist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; V;i++)&#123;<br>        <span class="hljs-comment">//更新minDist</span><br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= V;j++) &#123;<br>            <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; minDist[j] &lt; minVal) &#123;<br>                cur = j;<br>                minVal = minDist[j];<br>            &#125;<br>        &#125;<br>         <br>        visited[cur] = <span class="hljs-literal">true</span>;<br>         <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= V;j++) &#123;<br>            <span class="hljs-keyword">if</span>(!visited[j]) &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; [y, wt] : grid[cur]) &#123;<br>                    <span class="hljs-keyword">if</span>(y == j &amp;&amp; minDist[j] &gt; wt) minDist[j] = wt;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= V; i++) &#123; <span class="hljs-comment">// 不计第一个顶点，因为统计的是边的权值，v个节点有 v-1条边</span><br>        result += minDist[i];<br>    &#125;<br>    cout &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kruskal">Kruskal</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>  <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; f;<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) &#123;<br>        f.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) f[i] = i;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(u != f[u]) &#123;<br>            f[u] = <span class="hljs-built_in">find</span>(f[u]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[u];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        f[<span class="hljs-built_in">find</span>(u)] = <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(u) == <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> V, E;<br>    cin &gt;&gt; V &gt;&gt; E;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(E, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; E;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>;j++)<br>        cin &gt;&gt; grid[i][j];<br>    &#125;<br>    <span class="hljs-keyword">auto</span> cmp = [&amp;](vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, vector&lt;<span class="hljs-type">int</span>&gt; &amp; b) -&gt; <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>] &lt; b[<span class="hljs-number">2</span>];<br>    &#125;;<br>    <span class="hljs-built_in">sort</span>(grid.<span class="hljs-built_in">begin</span>(), grid.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(V + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= V;i++) &#123;<br>        <span class="hljs-comment">//find the shortest and not in the tree</span><br>        <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp; e : grid) &#123;<br>            <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isSame</span>(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>])) <span class="hljs-keyword">continue</span>;<br>            result += e[<span class="hljs-number">2</span>];<br>            uf.<span class="hljs-built_in">join</span>(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; result;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1id="将石头分散到网格的最少移动次数">将石头分散到网格的最少移动次数</h1><blockquote><p>题比较少，所以记录一下每日一题，半小时纯自主AC🎉</p></blockquote><h2 id="题目-1"><strong>题目</strong></h2><p>给你一个大小为 <code>3 * 3</code> ，下标从 <strong>0</strong>开始的二维整数矩阵 <code>grid</code>，分别表示每一个格子里石头的数目。网格图中总共恰好有 <code>9</code>个石头，一个格子里可能会有 <strong>多个</strong> 石头。</p><p>每一次操作中，你可以将一个石头从它当前所在格子移动到一个至少有一条公共边的相邻格子。</p><p>请你返回每个格子恰好有一个石头的 <strong>最少移动次数</strong> 。</p><p><strong>示例 1：</strong></p><figure><img src="https://assets.leetcode.com/uploads/2023/08/23/example1-3.svg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>输入：grid = [[1,1,0],[1,1,1],[1,2,1]]<br />输出：3<br />解释：让每个格子都有一个石头的一个操作序列为：<br />1 - 将一个石头从格子 (2,1) 移动到 (2,2) 。<br />2 - 将一个石头从格子 (2,2) 移动到 (1,2) 。<br />3 - 将一个石头从格子 (1,2) 移动到 (0,2) 。<br />总共需要 3 次操作让每个格子都有一个石头。<br />让每个格子都有一个石头的最少操作次数为 3 。</p></blockquote><h2 id="思路-1"><strong>思路</strong></h2><p>1不用动，只需知道0的位置和大于1的位置。之后不能简单地为每个0寻找最近的大于1，或者为每个最近的大于1寻找0。可轻易地举出反例，比如：</p><figure><img src="https://s3.bmp.ovh/imgs/2024/07/20/1fe8ae87392a8b8c.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>若先遍历到了居中的0，那么[0,1]位的2会被分给居中0，左下2就会分给右上0。局部最优不能得到整体最优。可抽象为：</p><blockquote><p>第一个大于1到所有0的距离为：[1, 1]</p><p>第二个大于1到所有0的距离为：[2, 4]</p><p>要从[[1,1],[2,4]]中每个数组取一个数字，且每个数组取的地方不能相同，最后总和最小。</p></blockquote><p>这就变成了全排列问题，可制定流程为：</p><ol type="1"><li>获得全部0和大于1的位置，注意大于1的位置需要多次加入保证总数</li><li>计算上述矩阵，即每个多余的1到0的距离</li><li>枚举所有排列，取最小总和</li></ol><p>流程没错，代码有点慢。只能击败不到10%...，也许是暴力回溯比不上next_permutation的缘故，读者可以帮忙测试一下👍</p><blockquote><p><ahref="%5B2850.%20将石头分散到网格图的最少移动次数%20-%20力扣（LeetCode）%5D(https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/solutions/2844232/jiang-shi-tou-fen-san-dao-wang-ge-tu-de-b4xos/?envType=daily-question&amp;envId=2024-07-20)">官方题解</a></p></blockquote><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> dis(x, y, i, j) (abs(x - i) + abs(y - j))</span><br><span class="hljs-comment">//曼哈顿距离</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> res = INT_MAX;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumMoves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; zero;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; more;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">3</span>;j++) &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>;k &lt;= grid[i][j];k++) more.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(i, j));<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[i][j] &lt; <span class="hljs-number">1</span>) zero.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(i, j));<br>            &#125;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dist</span>(more.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(zero.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; more.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; zero.<span class="hljs-built_in">size</span>();j++) &#123;<br>                dist[i][j] = <span class="hljs-built_in">dis</span>(more[i].first, more[i].second, zero[j].first, zero[j].second);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(dist.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtrack</span>(used, dist, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">bool</span>&gt; &amp; used, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp; dist, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> step)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(step == dist.<span class="hljs-built_in">size</span>()) res = <span class="hljs-built_in">min</span>(res, sum);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; dist.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(used[i]) <span class="hljs-keyword">continue</span>;<br>            sum += dist[step][i];<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtrack</span>(used, dist, sum, step + <span class="hljs-number">1</span>);<br>            sum -= dist[step][i];<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day58</title>
    <link href="/2024/07/19/leetcode-day58/"/>
    <url>/2024/07/19/leetcode-day58/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0108.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html">冗余连接</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0109.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.html">冗余连接II</a></li></ul><h1 id="冗余连接">冗余连接</h1><h3 id="题目"><strong>题目</strong>：</h3><p>树可以看成是一个图（拥有 n 个节点和 n - 1条边的连通无环无向图）。</p><p>现给定一个拥有 n 个节点（节点标号是从 1 到 n）和 n条边的连通无向图，请找出一条可以删除的边，删除后图可以变成一棵树。</p><h6 id="输入描述">输入描述</h6><p>第一行包含一个整数 N，表示图的节点个数和边的个数。</p><p>后续 N 行，每行包含两个整数 s 和 t，表示图中 s 和 t之间有一条边。</p><h6 id="输出描述">输出描述</h6><p>输出一条可以删除的边。如果有多个答案，请删除标准输入中最后出现的那条边。</p><h3 id="思路"><strong>思路</strong>：</h3><p>并查集模板，直接套</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; f;<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) &#123;<br>        f.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            f[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(u != f[u]) &#123;<br>            f[u] = <span class="hljs-built_in">find</span>(f[u]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[u];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        f[<span class="hljs-built_in">find</span>(u)] = <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(u) == <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isSame</span>(a, b)) &#123;<br>            cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> uf.<span class="hljs-built_in">join</span>(a, b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="冗余连接ii">冗余连接II</h1><h3 id="题目-1"><strong>题目</strong>：</h3><p>有向树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。有根树拥有n 个节点和 n - 1 条边。</p><p>输入一个有向图，该图由一个有着 n 个节点(节点编号 从 1 到 n)，n条边，请返回一条可以删除的边，使得删除该条边之后该有向图可以被当作一颗有向树。</p><h6 id="输入描述-1">输入描述</h6><p>第一行输入一个整数 N，表示有向图中节点和边的个数。</p><p>后续 N 行，每行输入两个整数 s 和 t，代表 s 节点有一条连接 t节点的单向边</p><h6 id="输出描述-1">输出描述</h6><p>输出一条可以删除的边，若有多条边可以删除，请输出标准输入中<strong>最后出现的一条边</strong>。</p><h3 id="思路-1"><strong>思路</strong>：</h3><h5 id="个人错误思路">个人错误思路</h5><p>并查集本身也是有向的，可直接按顺序加入边来模拟建树，需要考虑以下两种非法情况：</p><ol type="1"><li>含圈：检查新加入的边两端是否同根<code>find(u) == find(v)</code>，若相同，则删除该边</li><li>入度大于1：检查新加入的边两端是否已经加入树中<code>u != find(u)</code>，若不等，说明u已经在树中作为子，不可再作为子。</li></ol><p>需要注意并查集加入边的顺序，输入<code>2 1</code>，则使<code>f[1] = 2</code>。</p><blockquote><p>问题描述：</p><p>思路是错的，代码能过因为用例太弱。对于用例：</p><p>4<br />2 1<br />3 1<br />1 4<br />4 2</p><p>正解是删去2 1，若采用上面的思路，则遇到3 1时就会输出31，因为1已经被用过了，3 1和2 1肯定有一个会被删掉，删除靠后的3 1。</p><p>但整体来看，满足了入度条件却忽略了后面的圈条件，所以并不能按顺序模拟建树。</p><p>于是，我将入度非法的输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isSame</span>(a,b)) &#123;<span class="hljs-comment">//如果a -&gt; b的b已经被占用</span><br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b;<span class="hljs-comment">//按照题意，直接删去这条</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>改为输出已被占用的子和对应的父：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isVisited</span>(b)) &#123;<span class="hljs-comment">//如果a -&gt; b的b已经被占用</span><br>cout &lt;&lt; uf.<span class="hljs-built_in">find</span>(b) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b;<span class="hljs-comment">//输出之前输入的 占用b的边</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>即当遇到3 1时，输出21，这显然违背了题意(输出靠后的边)，<strong>但是能AC</strong>，说明用例中只有这一个能够反按顺序建树的思路。</p><p>同类型用例可概括为"一个圈加圈外的一条指向圈的边"：</p><figure><img src="https://s3.bmp.ovh/imgs/2024/07/19/721fb7b01d80c426.png"alt="带尾巴的圈" /><figcaption aria-hidden="true">带尾巴的圈</figcaption></figure><p>输入时只需将圈外边先于整个圈输入即可越过检查，如：</p><p>5 | 1 2 | 2 3 | 5 3 | 4 1 | 3 4 |</p><figure><img src="https://s3.bmp.ovh/imgs/2024/07/19/73a20d7842640d56.png"alt="图例" /><figcaption aria-hidden="true">图例</figcaption></figure><p>正解应该删去2 3，但我的代码输出3 1。将1 2和2 3交换顺序，则会输出13。(甚至路径压缩的错误都出来了……)</p><p>具体错误应该在于判断非法后默认输出当前边。自以为满足了靠后输出的要求，实际上却忽视了整体。应该像Carl那样判断应该删那一条边。</p></blockquote><h5 id="正确思路">正确思路</h5><p><ahref="%5B代码随想录%20(programmercarl.com)%5D(https://www.programmercarl.com/kamacoder/0109.冗余连接II.html#思路)">代码随想录| 冗余连接II</a></p><h2 id="代码-1">代码</h2><p>错误代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<span class="hljs-comment">//并查集类</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; f;<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) &#123;<br>        f.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            f[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(u != f[u]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(f[u]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[u];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<span class="hljs-comment">//u做根</span><br>        f[<span class="hljs-built_in">find</span>(v)] = <span class="hljs-built_in">find</span>(u);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isVisited</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> v != <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(u) == <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isSame</span>(a,b)) &#123;<span class="hljs-comment">//判圈</span><br>            cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b;<span class="hljs-comment">//有圈，直接删当前</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isVisited</span>(b)) &#123;<span class="hljs-comment">//判入度</span><br>            cout &lt;&lt; uf.<span class="hljs-built_in">find</span>(b) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b;<span class="hljs-comment">//有重，直接删当前的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> uf.<span class="hljs-built_in">join</span>(a, b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>carl哥的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span> <span class="hljs-params">(<span class="hljs-number">1001</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ;<br>    father[v] = u;<br>&#125;<br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-comment">// 在有向图里找到删除的那条边，使其变成树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getRemoveEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>(); <span class="hljs-comment">// 初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 遍历所有的边</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">same</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) &#123; <span class="hljs-comment">// 构成有向环了，就是要删除的边</span><br>            cout &lt;&lt; edges[i][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; edges[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 删一条边之后判断是不是树</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTreeAfterRemoveEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, <span class="hljs-type">int</span> deleteEdge)</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>(); <span class="hljs-comment">// 初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == deleteEdge) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">same</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) &#123; <span class="hljs-comment">// 构成有向环了，一定不是树</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> s, t;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edges;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录节点入度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        inDegree[t]++;<br>        edges.<span class="hljs-built_in">push_back</span>(&#123;s, t&#125;);<br>    &#125;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; vec; <span class="hljs-comment">// 记录入度为2的边（如果有的话就两条边）</span><br>    <span class="hljs-comment">// 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[edges[i][<span class="hljs-number">1</span>]] == <span class="hljs-number">2</span>) &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isTreeAfterRemoveEdge</span>(edges, vec[<span class="hljs-number">0</span>])) &#123;<br>            cout &lt;&lt; edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理情况三</span><br>    <span class="hljs-comment">// 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了</span><br>    <span class="hljs-built_in">getRemoveEdge</span>(edges);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day57</title>
    <link href="/2024/07/18/leetcode-day57/"/>
    <url>/2024/07/18/leetcode-day57/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0107.%E5%AF%BB%E6%89%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E8%B7%AF%E5%BE%84.html">寻找存在的路径</a></li><li><ahref="https://leetcode.cn/problems/accounts-merge/description/">721.账户合并</a> <span class="label label-warning">medium</span></li></ul><h1 id="寻找存在的路径">寻找存在的路径</h1><h4 id="题目"><strong>题目：</strong></h4><p>给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n）。</p><p>你的任务是判断是否有一条从节点 source 出发到节点 destination的路径存在。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个正整数 N 和 M，N 代表节点的个数，M 代表边的个数。</p><p>后续 M 行，每行两个正整数 s 和 t，代表从节点 s 与节点 t之间有一条边。</p><p>最后一行包含两个正整数，代表起始节点 source 和目标节点destination。</p><h6 id="输出描述">输出描述</h6><p>输出一个整数，代表是否存在从节点 source 到节点 destination的路径。如果存在，输出 1；否则，输出 0。</p><h4 id="思路"><strong>思路：</strong></h4><p>并查集模板题，只需要建一个并查集，然后判断source和destination是不是同源。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Union</span>&#123;<span class="hljs-comment">//并查集</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; f;<br>    <span class="hljs-built_in">Union</span>(<span class="hljs-type">int</span> n) &#123;<br>        f.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            f[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(f[u] != u) &#123;<br>            <span class="hljs-keyword">return</span> f[u] = <span class="hljs-built_in">find</span>(f[u]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[u];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        f[<span class="hljs-built_in">find</span>(u)] = <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(u) == <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    <span class="hljs-function">Union <span class="hljs-title">uf</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; M;i++) &#123;<span class="hljs-comment">//建立并查集</span><br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        uf.<span class="hljs-built_in">join</span>(a, b);<br>    &#125;<br>    <span class="hljs-type">int</span> s, d;<br>    cin &gt;&gt; s &gt;&gt; d;<br>    cout &lt;&lt; uf.<span class="hljs-built_in">isSame</span>(s, d);<span class="hljs-comment">//判断</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="账户合并">721. 账户合并</h1><h4 id="题目-1"><strong>题目：</strong></h4><p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code>是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code> 是 <em>名称(name)</em>，其余元素是 <strong><em>emails</em></strong>表示该账户的邮箱地址。</p><p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p><p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是<strong>按字符 ASCII 顺序排列</strong> 的邮箱地址。账户本身可以以<strong>任意顺序</strong> 返回。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：accounts = [[<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;johnsmith@mail.com&quot;</span>, <span class="hljs-string">&quot;john00@mail.com&quot;</span>], [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;johnnybravo@mail.com&quot;</span>], [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;johnsmith@mail.com&quot;</span>, <span class="hljs-string">&quot;john_newyork@mail.com&quot;</span>], [<span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-string">&quot;mary@mail.com&quot;</span>]]<br>输出：[[<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&#x27;john00@mail.com&#x27;</span>, <span class="hljs-string">&#x27;john_newyork@mail.com&#x27;</span>, <span class="hljs-string">&#x27;johnsmith@mail.com&#x27;</span>],  [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;johnnybravo@mail.com&quot;</span>], [<span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-string">&quot;mary@mail.com&quot;</span>]]<br>解释：<br>第一个和第三个 <span class="hljs-symbol">John</span> 是同一个人，因为他们有共同的邮箱地址 <span class="hljs-string">&quot;johnsmith@mail.com&quot;</span>。 <br>第二个 <span class="hljs-symbol">John</span> 和 <span class="hljs-symbol">Mary</span> 是不同的人，因为他们的邮箱地址没有被其他帐户使用。<br>可以以任何顺序返回这些列表，例如答案 [[<span class="hljs-string">&#x27;Mary&#x27;</span>，<span class="hljs-string">&#x27;mary@mail.com&#x27;</span>]，[<span class="hljs-string">&#x27;John&#x27;</span>，<span class="hljs-string">&#x27;johnnybravo@mail.com&#x27;</span>]，<br>[<span class="hljs-string">&#x27;John&#x27;</span>，<span class="hljs-string">&#x27;john00@mail.com&#x27;</span>，<span class="hljs-string">&#x27;john_newyork@mail.com&#x27;</span>，<span class="hljs-string">&#x27;johnsmith@mail.com&#x27;</span>]] 也是正确的。<br></code></pre></td></tr></table></figure><h4 id="思路-1"><strong>思路：</strong></h4><blockquote><p>由于今天并查集专题开始，只有一道模板题，所以将前天的力扣每日一题记录，正好也是并查集，提前学过就是快。</p></blockquote><ul><li>给所有的邮箱名编号，方便加入并查集，同时将邮件和名字关联，建立map&lt;email,name&gt;</li><li>根据每个账户的邮箱的编号，为每个账户建立并查集，以每个账户的第一个邮箱作为root</li><li>遍历所有的邮箱，建立"邮箱-&gt;编号"的映射，实现：能够根据一个邮箱得到邮箱所有者的全部邮箱<ul><li>得到该邮箱的root编号，建立map&lt;index,email<strong>s</strong>&gt;，将该邮箱放入root编号对应的邮箱集中</li></ul></li><li>遍历所有邮箱集，此时邮箱集已经完成合并，排序，通过第一步的邮箱-&gt;名字映射得到姓名，合并成一个数组加入答案，并返回。</li></ul><p>详见代码注释，可学习其中对于map的遍历简洁写法:<code>auto [e,_] : map</code></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<br><br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) &#123;<br>        parent.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> index1, <span class="hljs-type">int</span> index2)</span> </span>&#123;<br>        parent[<span class="hljs-built_in">find</span>(index1)] = <span class="hljs-built_in">find</span>(index2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (parent[index] != index) &#123;<br>            parent[index] = <span class="hljs-built_in">find</span>(parent[index]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[index];<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">accountsMerge</span>(vector&lt;vector&lt;string&gt;&gt;&amp; accounts) &#123;<br>        <span class="hljs-comment">//原来是并查集，没学过，现在学了</span><br>        <span class="hljs-comment">//首先给邮件编号方便加入并查集</span><br>        map&lt;string, <span class="hljs-type">int</span>&gt; emailToIndex;<br>        <span class="hljs-comment">//把邮件和名字关联起来</span><br>        map&lt;string, string&gt; emailToName;<br>        <span class="hljs-type">int</span> emailIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; account : accounts) &#123;<br>            string &amp; name = account[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> size = account.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; size;i++) &#123;<br>                string &amp; email = account[i];<br>                <span class="hljs-keyword">if</span>(!emailToIndex.<span class="hljs-built_in">count</span>(email)) &#123;<br>                    emailToIndex[email] = emailIndex++;<br>                    emailToName[email] = name;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//构建并查集</span><br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(emailIndex)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; account : accounts) &#123;<br>            string &amp; first = account[<span class="hljs-number">1</span>];<span class="hljs-comment">//第一个email作根</span><br>            <span class="hljs-type">int</span> root = emailToIndex[first];<br>            <span class="hljs-type">int</span> size = account.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt; size;i++) &#123;<br>                string &amp; email = account[i];<br>                <span class="hljs-type">int</span> index = emailToIndex[email];<br>                uf.<span class="hljs-built_in">join</span>(index, root);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将同一个人的emails统一起来</span><br>        map&lt;<span class="hljs-type">int</span>, vector&lt;string&gt;&gt; indexToEmails;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; [email, _] : emailToIndex) &#123;<br>            <span class="hljs-type">int</span> index = uf.<span class="hljs-built_in">find</span>(emailToIndex[email]);<span class="hljs-comment">//得到该email的根</span><br>            vector&lt;string&gt;&amp; emails = indexToEmails[index];<span class="hljs-comment">//得到这个根下已经有的emails</span><br>            emails.<span class="hljs-built_in">emplace_back</span>(email);<span class="hljs-comment">//将当前email加入这个根下的emails</span><br>            indexToEmails[index] = emails;<span class="hljs-comment">//放回去</span><br>        &#125;<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; [_, emails] : indexToEmails) &#123;<br>            <span class="hljs-built_in">sort</span>(emails.<span class="hljs-built_in">begin</span>(), emails.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//按ASCII排序</span><br>            string &amp; name = emailToName[emails[<span class="hljs-number">0</span>]];<br>            vector&lt;string&gt; account;<br>            account.<span class="hljs-built_in">emplace_back</span>(name);<span class="hljs-comment">//名字打头</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; email : emails) &#123;<br>                account.<span class="hljs-built_in">emplace_back</span>(email);<span class="hljs-comment">//后跟email</span><br>            &#125;<br>            ans.<span class="hljs-built_in">emplace_back</span>(account);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day56</title>
    <link href="/2024/07/17/leetcode-day56/"/>
    <url>/2024/07/17/leetcode-day56/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0110.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%A5%E9%BE%99.html">字符串接龙</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0105.%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%AE%8C%E5%85%A8%E5%8F%AF%E8%BE%BE%E6%80%A7.html">有向图的完全可达性</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0106.%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF.html">岛屿的周长</a></li></ul><h1 id="字符串接龙">字符串接龙</h1><h5 id="题目"><strong>题目：</strong></h5><p>字典 strList 中从字符串 beginStr 和 endStr的转换序列是一个按下述规格形成的序列：</p><ol type="1"><li>序列中第一个字符串是 beginStr。</li><li>序列中最后一个字符串是 endStr。</li><li>每次转换只能改变一个字符。</li><li>转换过程中的中间字符串必须是字典 strList中的字符串，且strList里的每个字符串只用使用一次。</li></ol><p>给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr到 endStr 的最短转换序列中的字符串数目。如果不存在这样的转换序列，返回0。</p><h6 id="输入描述">输入描述</h6><p>第一行包含一个整数 N，表示字典 strList 中的字符串数量。第二行包含两个字符串，用空格隔开，分别代表 beginStr 和 endStr。 后续 N行，每行一个字符串，代表 strList 中的字符串。</p><h6 id="输出描述">输出描述</h6><p>输出一个整数，代表从 beginStr 转换到 endStr需要的最短转换序列中的字符串数量。如果不存在这样的转换序列，则输出0。</p><h5 id="思路"><strong>思路：</strong></h5><p><strong>注意</strong>：无向图搜索，最好用BFS</p><p>beginStr和endStr作为起始点，字典中的作为中间点，求最短路，即无向图求最短路。</p><p>但是这里并不是具体的点，而是字符串，路也需要判断</p><p>如果直接遍历所有字符串，根据差异直接建图，首先就会有<spanclass="math inline">\(O(n^2)\)</span>的复杂度（<em>还没算比较字符串差异的复杂度</em>），然后还需要BFS，容易超时</p><p>carl利用字符串中只有小写字母的特点(题目并未提及只有小写字母，难以想到)，可以手动模拟所有的路，然后在已有的路中匹配，降低复杂度为常数26和在set、map中查找数据复杂度之积，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; <span class="hljs-number">26</span>; j++) &#123;<span class="hljs-comment">//遍历26个字母</span><br>    newWord[i] = j + <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (newWord == endStr) &#123; <span class="hljs-comment">// 发现替换字母后，字符串与终点字符串相同</span><br>        cout &lt;&lt;  path + <span class="hljs-number">1</span> &lt;&lt; endl; <span class="hljs-comment">// 找到了路径 </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 字符串集合里出现了newWord，并且newWord没有被访问过</span><br>    <span class="hljs-keyword">if</span> (strSet.<span class="hljs-built_in">find</span>(newWord) != strSet.<span class="hljs-built_in">end</span>()<br>            &amp;&amp; visitMap.<span class="hljs-built_in">find</span>(newWord) == visitMap.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-comment">// 添加访问信息，并将新字符串放到队列中</span><br>        visitMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(newWord, path + <span class="hljs-number">1</span>));<br>        que.<span class="hljs-built_in">push</span>(newWord);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br>    string beginStr, endStr;<br>    cin &gt;&gt; beginStr &gt;&gt; endStr;<br>    unordered_set&lt;string&gt; set;<br>    string temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        cin &gt;&gt; temp;<br>        set.<span class="hljs-built_in">insert</span>(temp);<br>    &#125;<br>    queue&lt;string&gt; q;<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; map;<br>    q.<span class="hljs-built_in">push</span>(beginStr);<br>    map[beginStr] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        string word = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> path = map[word];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; word.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">26</span>;j++) &#123;<br>                string newWord = word;<br>                newWord[i] = j + <span class="hljs-string">&#x27;a&#x27;</span>;<br> <br>                <span class="hljs-keyword">if</span>(newWord == endStr) &#123;<br>                    cout &lt;&lt; path + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(newWord) != set.<span class="hljs-built_in">end</span>() &amp;&amp; map.<span class="hljs-built_in">find</span>(newWord) == map.<span class="hljs-built_in">end</span>()) &#123;<br>                        map[newWord] = path + <span class="hljs-number">1</span>;<br>                        q.<span class="hljs-built_in">push</span>(newWord);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="有向图的完全可达性">有向图的完全可达性</h1><h5 id="题目-1"><strong>题目：</strong></h5><p>给定一个有向图，包含 N 个节点，节点编号分别为 1，2，...，N。现从 1号节点开始，如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出-1。</p><h6 id="输入描述-1">输入描述</h6><p>第一行包含两个正整数，表示节点数量 N 和边的数量 K。 后续 K行，每行两个正整数 s 和 t，表示从 s 节点有一条边单向连接到 t 节点。</p><h6 id="输出描述-1">输出描述</h6><p>如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p><h5 id="思路-1"><strong>思路：</strong></h5><p>不用传统dfs或bfs，既然是有向图可达，联想并查集路径压缩的思想，不断将路径压缩，随后如果还存在起点不是1号的路径，则输出-1。具体过程如下：</p><ol type="1"><li>统计所有直接与1相通的点，<spanclass="math inline">\(s[i]\)</span>代表1号节点能否到达节点i</li><li>其他边另成集，起点不断与s比较，若s[起点]=true，则删除这条边，同时更新s[终点]为true</li><li>循环删除“其他边”，以冒泡排序思想检测本轮遍历是否有删除，若没有删除操作，则检查"其他边"，若仍存在，输出-1，若空，输出1</li></ol><p>这种写法类似于BFS，每次只走一步。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//统计所有1出发的边，其他边另成集</span><br><span class="hljs-comment">//不断将其他边融合进1出发，如1，2  2，4 融合为1，4</span><br><span class="hljs-comment">//最后如果剩余有不可融合的边，则-1</span><br><span class="hljs-comment">//1出发边构建为s[101]表示从1到101的边是否存在</span><br><span class="hljs-comment">//其他边统计为vec&lt;pair&lt;int,int&gt;&gt; 如果起点与s重合则删除，并更新s</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, K;<br>    cin &gt;&gt; N &gt;&gt; K;<br>    <span class="hljs-type">bool</span> s[<span class="hljs-number">110</span>] = &#123;<span class="hljs-literal">false</span>&#125;;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; edge;<br>    <span class="hljs-type">int</span> a, b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; K;i++) &#123;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span>) s[b] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> edge.<span class="hljs-built_in">push_back</span>(&#123;a, b&#125;);<br>    &#125;<br>    <span class="hljs-type">bool</span> changed = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span>(!edge.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; edge.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[edge[i].first]) &#123;<br>                s[edge[i].second] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">swap</span>(edge[i], edge[edge.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]);<br>                edge.<span class="hljs-built_in">pop_back</span>();<br>                changed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(changed == <span class="hljs-literal">false</span> &amp;&amp; !edge.<span class="hljs-built_in">empty</span>()) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        changed = <span class="hljs-literal">false</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="岛屿的周长">岛屿的周长</h1><h5 id="题目-2"><strong>题目：</strong></h5><p>给定一个由 1（陆地）和0（水）组成的矩阵，岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。</p><p>你可以假设矩阵外均被水包围。在矩阵中恰好拥有一个岛屿，假设组成岛屿的陆地边长都为1，请计算岛屿的周长。岛屿内部没有水域。</p><h6 id="输入描述-2">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-2">输出描述</h6><p>输出一个整数，表示岛屿的周长。</p><h5 id="思路-2"><strong>思路：</strong></h5><p>由于地块都是方块，所以问题转化为小学生的数周长问题，公式为：</p><p><span class="math inline">\(周长=块数*4-重合边数\)</span></p><p>那么可以统计块数和重合边数，最后求解答案即可。</p><p>也可以遍历所有地块，统计所有海岸长度。</p><p>还需注意岛屿问题的经典坑——全是陆地没有水。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//每块四面，重合最少1最多4，遍历所有块计算每个的重合</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; M;j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; M;j++) &#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-literal">false</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k &lt; <span class="hljs-number">4</span>;k++) &#123;<br>                <span class="hljs-type">int</span> x = i + dir[k][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> y = j + dir[k][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= N || y &lt; <span class="hljs-number">0</span> || y &gt;= M || grid[x][y] == <span class="hljs-literal">false</span>) ans++;<br>            &#125;<br>        &#125;   <br>    &#125;<br>    <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">2</span>*(N+M);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day55</title>
    <link href="/2024/07/16/leetcode-day55/"/>
    <url>/2024/07/16/leetcode-day55/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0101.%E5%AD%A4%E5%B2%9B%E7%9A%84%E6%80%BB%E9%9D%A2%E7%A7%AF.html">孤岛的总面积</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0102.%E6%B2%89%E6%B2%A1%E5%AD%A4%E5%B2%9B.html">沉没孤岛</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0103.%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98.html">水流问题</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0104.%E5%BB%BA%E9%80%A0%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF.html">建造最大岛屿</a></li></ul><h1 id="孤岛的总面积">孤岛的总面积</h1><p><strong>题目：</strong></p><p>给定一个由 1（陆地）和0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p><p>现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M个数字，数字为 1 或者 0。</p><h6 id="输出描述">输出描述</h6><p>输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。</p><p><strong>思路：</strong></p><p>先绕地图边缘遍历，遇到陆地就搜索，把整块地都变成水，然后再遍历地图，得到的就全是孤岛，计算总面积。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">55</span>;<span class="hljs-comment">//题目限制最大50，开个55</span><br> <br><span class="hljs-type">int</span> n, m;<span class="hljs-comment">//长宽</span><br><span class="hljs-type">int</span> cnt;<span class="hljs-comment">//计数器</span><br><span class="hljs-type">int</span> g[N][N];<span class="hljs-comment">//地图</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//方向</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span></span><br><span class="hljs-function"></span>&#123;<br>    g[sx][sy] = <span class="hljs-number">0</span>;<span class="hljs-comment">//直接变水</span><br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<span class="hljs-comment">//四个方向</span><br>    &#123;<br>        <span class="hljs-type">int</span> a = sx + dx[i], b = sy + dy[i];<br>        <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (g[a][b] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        g[a][b] = <span class="hljs-number">0</span>;<span class="hljs-comment">//变水</span><br>        cnt++;<span class="hljs-comment">//计数孤岛</span><br>        <span class="hljs-built_in">dfs</span>(a, b);<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>            cin &gt;&gt; g[i][j];<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (g[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>);  <span class="hljs-comment">//左边</span><br>        <span class="hljs-keyword">if</span> (g[i][m - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(i, m - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 右边</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (g[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, i); <span class="hljs-comment">// 上边</span><br>        <span class="hljs-keyword">if</span> (g[n - <span class="hljs-number">1</span>][i] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(n - <span class="hljs-number">1</span>, i); <span class="hljs-comment">// 下边</span><br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-number">1</span>)<br>            &#123;<br>                cnt = <span class="hljs-number">1</span>;<span class="hljs-comment">//记录当前</span><br>                <span class="hljs-built_in">dfs</span>(i, j);<br>                res += cnt;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="沉默孤岛">沉默孤岛</h1><p><strong>题目：</strong></p><p>给定一个由 1（陆地）和0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p><p>现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。</p><h6 id="输入描述-1">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p><p>之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-1">输出描述</h6><p>输出将孤岛“沉没”之后的岛屿矩阵。 注意：每个元素后面都有一个空格</p><p><strong>思路：</strong></p><p>溜边遍历，把靠边的陆地全变成2，再遍历一次，把不是2的都变水，就能够沉掉孤岛。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = a;i &lt; b;i++)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    grid[x][y] *= <span class="hljs-number">2</span>;<span class="hljs-comment">//0就0，1就2</span><br>    <span class="hljs-keyword">if</span>(!grid[x][y]) <span class="hljs-keyword">return</span> ;<span class="hljs-comment">//已经遇到水了，不用继续走了</span><br>    <span class="hljs-built_in">rep</span>(k, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-type">int</span> i = x + dir[k][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> j = y + dir[k][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= grid.<span class="hljs-built_in">size</span>() || j &lt; <span class="hljs-number">0</span> || j &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>            grid[i][j] = <span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">dfs</span>(grid, i, j);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; M;j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N) &#123;<span class="hljs-comment">//溜左右</span><br>        <span class="hljs-built_in">dfs</span>(grid, i, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">dfs</span>(grid, i, M<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, M) &#123;<span class="hljs-comment">//溜上下</span><br>        <span class="hljs-built_in">dfs</span>(grid, <span class="hljs-number">0</span>, i);<br>        <span class="hljs-built_in">dfs</span>(grid, N<span class="hljs-number">-1</span>, i);<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N) &#123;<span class="hljs-comment">//溜全图</span><br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">0</span>, M) &#123;<br>            cout &lt;&lt; (<span class="hljs-type">int</span>)(grid[i][j] &gt; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">//是2才输出</span><br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="水流问题">水流问题</h1><p><strong>题目：</strong></p><p>现有一个 N × M的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。</p><p>矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。</p><h6 id="输入描述-2">输入描述</h6><p>第一行包含两个整数 N 和 M，分别表示矩阵的行数和列数。</p><p>后续 N 行，每行包含 M 个整数，表示矩阵中的每个单元格的高度。</p><h6 id="输出描述-2">输出描述</h6><p>输出共有多行，每行输出两个整数，用一个空格隔开，表示可达第一组边界和第二组边界的单元格的坐标，输出顺序任意。</p><p><strong>思路：</strong></p><p>不能暴力，要优化，仍然溜边，分别记录一组边界和二组边界上每个边点能够去到的地方，即一组边界和二组边界都有着一张图，上面true的地方能作上游，false的地方不能。</p><p>最后再遍历全图，如果一组边界和二组边界都能将其作为上游，那么就是目标点，输出。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (visited[x][y]) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//走过，不用再走</span><br><br>    visited[x][y] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= n || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= m) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (grid[x][y] &gt; grid[nextx][nexty]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 注意：这里是从低向高遍历，逆流而上</span><br><br>        <span class="hljs-built_in">dfs</span> (grid, visited, nextx, nexty);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 标记从第一组边界上的节点出发，可以遍历的节点</span><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">firstBorder</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-comment">// 标记从第一组边界上的节点出发，可以遍历的节点</span><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">secondBorder</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-comment">// 从最上和最下行的节点出发，向高处遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">dfs</span> (grid, firstBorder, i, <span class="hljs-number">0</span>); <span class="hljs-comment">// 遍历最左列，接触第一组边界</span><br>        <span class="hljs-built_in">dfs</span> (grid, secondBorder, i, m - <span class="hljs-number">1</span>); <span class="hljs-comment">// 遍历最右列，接触第二组边界</span><br>    &#125;<br><br>    <span class="hljs-comment">// 从最左和最右列的节点出发，向高处遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-built_in">dfs</span> (grid, firstBorder, <span class="hljs-number">0</span>, j); <span class="hljs-comment">// 遍历最上行，接触第一组边界</span><br>        <span class="hljs-built_in">dfs</span> (grid, secondBorder, n - <span class="hljs-number">1</span>, j); <span class="hljs-comment">// 遍历最下行，接触第二组边界</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-comment">// 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果</span><br>            <span class="hljs-keyword">if</span> (firstBorder[i][j] &amp;&amp; secondBorder[i][j]) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="建造最大岛屿">建造最大岛屿</h1><p><strong>题目：</strong></p><p>给定一个由 1（陆地）和0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。</p><p>岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。</p><h6 id="输入描述-3">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-3">输出描述</h6><p>输出一个整数，表示最大的岛屿面积。如果矩阵中不存在岛屿，则输出0。</p><p><strong>思路：</strong></p><p>不能暴力，先遍历全图，用不同的mark标记不同的岛屿，开个map记录标号mark-面积count的序对[mark,count]，最后再遍历全图，对每个水地块计算其周围四格邻接的不同岛屿的面积总和，取最大值。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = a;i &lt; b;i++)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> N,M;<br><span class="hljs-type">int</span> cnt;<span class="hljs-comment">//单个岛屿计数器</span><br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> mark)</span> </span>&#123;<br>    grid[x][y] = mark;<span class="hljs-comment">//用mark覆盖，相当于着色</span><br>    cnt++;<br>    <span class="hljs-built_in">rep</span>(m, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-type">int</span> i = x + dir[m][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> j = y + dir[m][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= N || j &lt; <span class="hljs-number">0</span> || j &gt;= M || grid[i][j] != <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(grid, i, j, mark);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N) &#123;<br>        <span class="hljs-built_in">rep</span>(j ,<span class="hljs-number">0</span>, M) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//先遍历地图记录岛屿-面积</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>    <span class="hljs-type">int</span> mark = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N) &#123;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">0</span>, M) &#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                cnt = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">dfs</span>(grid, i, j, mark);<br>                map[mark] = cnt;<br>                mark++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//遍历海洋，计算相邻岛屿面积之和，取最大值</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N) &#123;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">0</span>, M) &#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//将相邻的不同岛屿面积相加,unordered_set去重岛屿</span><br>            unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>            temp = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">rep</span>(m, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-type">int</span> x = i + dir[m][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> y = j + dir[m][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= N || y &lt; <span class="hljs-number">0</span> || y &gt;= M || grid[x][y] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(grid[x][y]) != set.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    temp += map[grid[x][y]];<br>                    set.<span class="hljs-built_in">insert</span>(grid[x][y]);<br>                &#125;<br>            &#125;<br>            ans = ans &gt; temp ? ans : temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>) cout&lt;&lt; N * M;<span class="hljs-comment">//没水全是地，直接返回地图大小</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day54</title>
    <link href="/2024/07/15/leetcode-day54/"/>
    <url>/2024/07/15/leetcode-day54/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E6%B7%B1%E6%90%9C.html">99.岛屿数量</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0100.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.html">100.岛屿的最大面积</a></li></ul><h1 id="岛屿数量">岛屿数量</h1><p><strong>题目：</strong></p><p>给定一个由 1（陆地）和0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p><p>后续 N 行，每行包含 M 个数字，数字为 1 或者 0。</p><h6 id="输出描述">输出描述</h6><p>输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。</p><p><strong>思路：</strong></p><p>遍历整个图，如果遇到没走过的1，就计数，并把其相邻的所有1都走一遍，如果遇到走过的1或0就跳过，最后返回计数。</p><h2 id="代码">代码</h2><p>dfs版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = a;i &lt; b;i++)</span><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; map, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= (<span class="hljs-type">int</span>)map.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= (<span class="hljs-type">int</span>)map[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || visited[nextx][nexty] || map[nextx][nexty] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            visited[nextx][nexty] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(map, visited, nextx, nexty);<br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">map</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M));<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N) &#123;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">0</span>, M) &#123;<br>            cin &gt;&gt; map[i][j];<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">visited</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-literal">false</span>));<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N)&#123;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">0</span>, M) &#123;<br>            <span class="hljs-keyword">if</span>(map[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[i][j]) &#123;<br>                visited[i][j] = <span class="hljs-literal">true</span>;<br>                ans ++;<br>                <span class="hljs-built_in">dfs</span>(map, visited, i, j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>bfs版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    que.<span class="hljs-built_in">push</span>(&#123;x, y&#125;);<br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列，立刻标记</span><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        pair&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span>) &#123;<br>                que.<span class="hljs-built_in">push</span>(&#123;nextx, nexty&#125;);<br>                visited[nextx][nexty] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列立刻标记</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br> <br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br> <br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                result++; <span class="hljs-comment">// 遇到没访问过的陆地，+1</span><br>                <span class="hljs-built_in">bfs</span>(grid, visited, i, j); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>            &#125;<br>        &#125;<br>    &#125;<br> <br> <br>    cout &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="岛屿的最大面积">岛屿的最大面积</h1><p><strong>题目：</strong></p><p>给定一个由 1（陆地）和0（水）组成的矩阵，计算岛屿的最大面积。岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p><h6 id="输入描述-1">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。后续 N 行，每行包含 M个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-1">输出描述</h6><p>输出一个整数，表示岛屿的最大面积。如果不存在岛屿，则输出 0。</p><p><strong>思路：</strong></p><p>采用和上一道题相同的思路，只是不计数岛屿数量，改为在遍历岛屿时计数面积(格子数)，从中选出一个最大的面积返回。</p><h2 id="代码-1">代码</h2><p>dfs版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">// 四个方向</span><br><br><span class="hljs-type">int</span> island = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++) &#123;<br>        <span class="hljs-type">int</span> _x = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> _y = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(_x &lt; <span class="hljs-number">0</span> || _x &gt;= grid.<span class="hljs-built_in">size</span>() || _y &lt; <span class="hljs-number">0</span> || _y &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || grid[_x][_y] == <span class="hljs-number">0</span> || visited[_x][_y] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            visited[_x][_y] = <span class="hljs-literal">true</span>;<br>            island++;<br>            <span class="hljs-built_in">dfs</span>(grid, visited, _x, _y);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; visited[i][j] == <span class="hljs-literal">false</span>) &#123;<br>                island = <span class="hljs-number">1</span>;<br>                visited[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j);<br>                max = max &gt;= island ? max : island;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; max;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="小结注意">小结&amp;注意</h1><p>在bfs时，入队即为走过，需要立即将其状态visited置位，否则会重复遍历超时。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day52</title>
    <link href="/2024/07/13/leetcode-day52/"/>
    <url>/2024/07/13/leetcode-day52/</url>
    
    <content type="html"><![CDATA[<p>今日内容：图论首日，内容较简单，离散数学和数据结构课上都学完了</p><ul><li><ahref="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">797.所有可达路径</a></li></ul><h1 id="所有可达路径">797. 所有可达路径</h1><p><strong>题目：</strong></p><p>给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点n-1 的路径并输出（不要求按特定顺序）</p><p>graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点graph[i][j]存在一条有向边）。</p><figure><img src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg"alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>输入：graph = [[1,2],[3],[3],[]]<br />输出：[[0,1,3],[0,2,3]]<br />解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</p><p><strong>思路：</strong></p><p>简单的回溯dfs，实践一下邻接表和邻接矩阵的存法。首次写没有用这两种，直接把edge存一起了，由于每次都要从头找出度，所以会慢一点</p><h2 id="代码">代码</h2><p>carl的邻接表写法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 1节点到终点的路径</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (x == n) &#123; <span class="hljs-comment">// 找到符合条件的一条路径</span><br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : graph[x]) &#123; <span class="hljs-comment">// 找到 x指向的节点</span><br>        path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>        <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span><br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br><br>    &#125;<br><br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 无论什么路径已经是从0节点出发</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, n); <span class="hljs-comment">// 开始遍历</span><br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;pa : result) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            cout &lt;&lt; pa[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; pa[pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]  &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> carl的邻接矩阵 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 1节点到终点的路径</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 当前遍历的节点x 到达节点n </span><br>    <span class="hljs-keyword">if</span> (x == n) &#123; <span class="hljs-comment">// 找到符合条件的一条路径</span><br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 遍历节点x链接的所有节点</span><br>        <span class="hljs-keyword">if</span> (graph[x][i] == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 找到 x链接的节点</span><br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>            <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br> <br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br> <br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的</span><br>        graph[s][t] = <span class="hljs-number">1</span>;<br>    &#125;<br> <br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 无论什么路径已经是从0节点出发</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, n); <span class="hljs-comment">// 开始遍历</span><br> <br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;pa : result) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            cout &lt;&lt; pa[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; pa[pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]  &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>直接存边：慢50%左右 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-type">int</span> N, M;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; edge, <span class="hljs-type">int</span> cur)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(cur == N) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; (<span class="hljs-type">int</span>)edge.<span class="hljs-built_in">size</span>();i++) &#123;<br>        <span class="hljs-keyword">if</span>(edge[i].first != cur) <span class="hljs-keyword">continue</span>;<br>        path.<span class="hljs-built_in">push_back</span>(edge[i].second);<br>        <span class="hljs-built_in">backtrack</span>(edge, edge[i].second);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.first &lt; b.first;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">edge</span>(M);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; M;i++) &#123;<br>        cin &gt;&gt; edge[i].first &gt;&gt; edge[i].second;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(edge.<span class="hljs-built_in">begin</span>(), edge.<span class="hljs-built_in">end</span>(), cmp);<br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">backtrack</span>(edge, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">empty</span>()) cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; (<span class="hljs-type">int</span>)ans.<span class="hljs-built_in">size</span>();i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; ans[i].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;j++) &#123;<br>            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; ans[i].<span class="hljs-built_in">back</span>();<br>        <span class="hljs-keyword">if</span>(i != ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day51</title>
    <link href="/2024/07/12/leetcode-day51/"/>
    <url>/2024/07/12/leetcode-day51/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/trapping-rain-water/description/">42.接雨水</a> <span class="label label-danger">hard</span></li><li><a href="">84. 柱状图中最大的矩形</a> <span class="label label-danger">hard</span></li></ul><h1 id="接雨水">42. 接雨水</h1><p><strong>题目：</strong></p><p>给定 n 个非负整数表示每个宽度为 1的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure><imgsrc="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png"alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br />输出：6<br />解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1]表示的高度图，在这种情况下，可以接 6个单位的雨水（蓝色部分表示雨水）。</p><p><strong>思路：</strong></p><p>由木桶效应，水量由最短板决定，所以这里每一格的水量由左右两边最低的柱子决定，同时还要减去自己的高度。</p><p>那么就需要知道每一格左右两边的最高柱子，取其小作为水面高度，减去自身高度即为水深。</p><p><strong>求左右两边的某最值，且为一维数组，就尝试用单调栈。</strong></p><p><strong>个人版</strong>：设左右两个栈，底到顶递增，由于左右两柱子不接水，从左到右遍历就左栈只入栈最左柱，右栈入栈[2:size- 1]，然后取两个栈顶中较小的。</p><p>计算完当前柱，要把当前柱入栈左栈，注意维护大小关系，若当前高度等于右栈的栈底最大值，则要移除右栈的栈底。故数据结构用deque</p><p><strong>carl版</strong>：一个栈就够了，栈规则相同递增，如果遇到比栈顶大的，就逐个出栈计算值，直到栈空或遇到左高柱。一次取当前柱(右柱)，栈顶柱(凹陷)，栈次顶柱(左柱)，算中间凹陷的水量。</p><ul><li>另有双指针版，两个数组left、right分别表示heights[i]对应的左边最大值left[i]和右边最大值right[i]，初始先从左到右遍历得到left，从右到左遍历得到right，再遍历整个计算水量。需要注意维护和初始化</li></ul><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(height.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        deque&lt;<span class="hljs-type">int</span>&gt; left, right;<br>        left.<span class="hljs-built_in">push_front</span>(height[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt; height.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">while</span>(!right.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; right.<span class="hljs-built_in">back</span>()) &#123;<br>                right.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            right.<span class="hljs-built_in">push_back</span>(height[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i++) &#123;<br>            <span class="hljs-type">int</span> l = left.<span class="hljs-built_in">front</span>(), r = right.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">min</span>(l, r) - height[i] &gt; <span class="hljs-number">0</span>) ans += <span class="hljs-built_in">min</span>(l, r) - height[i];<br>            <span class="hljs-keyword">while</span>(!left.<span class="hljs-built_in">empty</span>() &amp;&amp; left.<span class="hljs-built_in">back</span>() &lt; height[i]) &#123;<br>                left.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            left.<span class="hljs-built_in">push_back</span>(height[i]);<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">1</span> &amp;&amp; right.<span class="hljs-built_in">front</span>() == height[i]) right.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>carl版： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (height.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 可以不加</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">// 存着下标，计算的时候用下标对应的柱子高度</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (height[i] &lt; height[st.<span class="hljs-built_in">top</span>()]) &#123;     <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">if</span> (height[i] == height[st.<span class="hljs-built_in">top</span>()]) &#123;  <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 注意这里是while</span><br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[st.<span class="hljs-built_in">top</span>()], height[i]) - height[mid];<br>                        <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意减一，只求中间宽度</span><br>                        sum += h * w;<br>                    &#125;<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure> # 84. 柱状图中最大的矩形</p><p><strong>题目：</strong></p><p>给定 n个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><figure><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>输入：heights = [2,1,5,6,2,3]<br />输出：10<br />解释：最大的矩形为图中红色区域，面积为 10</p><p><strong>思路：</strong></p><p>要么追求高度，要么追求宽度，都得兼顾，每次计算都算包含当前柱的矩形面积，需要知道<strong>左边不小于自己的最远的柱子，右边不小于自己的最远的柱子</strong>。</p><p><strong>单调栈</strong>：不小于自己的最远柱，那么入栈不小于的，<strong>碰到比栈顶小的就说明不能再贪宽度了</strong>，否则就损失高度了，此时逐个出栈计算面积，刚开始高窄，后面矮宽，总有一个最大，直到栈空或比栈顶大。</p><p><strong>双指针</strong>：</p><p>左右都遍历，与上面相同的顺序，只是每次循环内要再循环一次往找过的地方针对当前柱找<strong>不小于的最远柱</strong>，可以利用已经计算的left和right数组跳跃寻找。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heights.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> heights[<span class="hljs-number">0</span>];<br>        &#125;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        heights.<span class="hljs-built_in">insert</span>(heights.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);<br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; heights.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[st.<span class="hljs-built_in">top</span>()] &gt; heights[i]) &#123;<br>                <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                    <span class="hljs-type">int</span> right = i;<br>                    <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">top</span>();<br>                    ans = <span class="hljs-built_in">max</span>(ans, heights[mid] * (right - left - <span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>双指针： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-comment">//左边大于自己的最远的，右边大于自己的最远的</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(heights.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(heights.size(), heights.size())</span></span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; heights.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-type">int</span> t = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(t &gt;= <span class="hljs-number">0</span> &amp;&amp; heights[t] &gt;= heights[i]) t = left[t];<br>            left[i] = t;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = heights.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-type">int</span> t = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(t &lt; heights.<span class="hljs-built_in">size</span>() &amp;&amp; heights[t] &gt;= heights[i]) t = right[t];<br>            right[i] = t;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; heights.<span class="hljs-built_in">size</span>();i++) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, heights[i] * (right[i] - left[i] - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="小结">小结</h1><p>单调栈适用于找一维数组上，每个元素左右最大最小之类的最值。</p><p>设定好规则后，只需入栈符合规则的，遇到违背规则的就逐个出栈处理，直到符合规则，注意初始化以使栈内元素都能得到处理，防止漏解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day50</title>
    <link href="/2024/07/11/leetcode-day50/"/>
    <url>/2024/07/11/leetcode-day50/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/daily-temperatures/description/">739.每日温度</a> <span class="label label-warning">medium</span></li><li><a href="">496.下一个更大元素 I</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/next-greater-element-ii/description/">503.下一个更大元素II</a><span class="label label-warning">medium</span></li></ul><h1 id="每日温度">739. 每日温度</h1><h2 id="题目"><strong>题目：</strong></h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer，其中 answer[i] 是指对于第 i天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用0 来代替。</p><p>示例 1: 输入: temperatures = [73,74,75,71,69,72,76,73]<br />输出: [1,1,4,2,1,1,0,0]<br />示例 2:<br />输入: temperatures = [30,40,50,60]<br />输出: [1,1,1,0]<br />示例 3:<br />输入: temperatures = [30,60,90]<br />输出: [1,1,0]</p><h2 id="思路"><strong>思路：</strong></h2><h3 id="首次思路">首次思路</h3><p>既然是单调栈专题，之前遇到过单调栈，但只有模糊的认识：单调栈就是有一个特殊入栈出栈规则的栈，这个规则构成了单调。</p><p>于是“照虎画猫”，开一个栈，使其从栈底到栈顶非递减，即：<br />- 元素比栈顶小或相等，入栈 - 元素比栈顶大，不断出栈直至比栈顶小或空</p><p>遍历到最后栈内的都是没有升高的，在初始化时就置零，之后就不用管了直接返回。</p><p>写的时候就能悟到，栈里面存下标要方便得多，于是写出下面的<ahref="#自己的-每日温度">代码</a></p><h3 id="carl思路">carl思路</h3><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。</strong></p><ul><li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况:入栈</li><li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况：入栈</li><li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况：不断出栈到不大于或空</li></ul><p>栈内存下标。</p><h2 id="代码">代码</h2><h3 id="自己的-每日温度">自己的-每日温度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; temperatures.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>()) &#123;<br>                st.<span class="hljs-built_in">push</span>(i);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[st.<span class="hljs-built_in">top</span>()] &lt; temperatures[i]) &#123;<br>                    ans[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl的-每日温度">carl的-每日温度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; T)</span> </span>&#123;<br>        <span class="hljs-comment">// 递增栈</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(T.size(), <span class="hljs-number">0</span>)</span></span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; T.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (T[i] &lt; T[st.<span class="hljs-built_in">top</span>()]) &#123;                       <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T[i] == T[st.<span class="hljs-built_in">top</span>()]) &#123;               <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; T[i] &gt; T[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况三</span><br>                    result[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="下一个更大元素-i">496.下一个更大元素 I</h1><p><strong>题目：</strong></p><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的第一个 比 x 大的元素。</p><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0开始计数，其中nums1 是 nums2 的子集。</p><p>对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j]的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</p><p>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i]是如上所述的 下一个更大元素 。</p><p>示例 1：<br />输入：nums1 = [4,1,2], nums2 = [1,3,4,2].<br />输出：[-1,3,-1]<br />解释：nums1 中每个值的下一个更大元素如下所述：<br />- 4 ，用加粗斜体标识，nums2 =[1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br />- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。<br />- 2 ，用加粗斜体标识，nums2 =[1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br />示例 2： 输入：nums1 = [2,4], nums2 = [1,2,3,4].<br />输出：[3,-1]<br />解释：nums1 中每个值的下一个更大元素如下所述：<br />- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。 - 4，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1。<br />提示：<br />- <span class="math inline">\(1 &lt;= nums1.length &lt;= nums2.length&lt;= 1000\)</span><br />- <span class="math inline">\(0 &lt;= nums1[i], nums2[i] &lt;=10^4\)</span><br />- nums1和nums2中所有整数 互不相同<br />- nums1 中的所有整数同样出现在 nums2 中</p><h2 id="思路-1"><strong>思路：</strong></h2><h3 id="首次思路-1">首次思路</h3><p>俩for循环暴力搜索，我自己用单调栈好像也没优化到哪里去……</p><h3 id="carl的思路">carl的思路</h3><p>用map记忆化遍历，再遍历nums2，这样就不用在外面套一层nums1</p><h2 id="代码-1">代码</h2><h3 id="自己的-下一个最大元素i">自己的-下一个最大元素I</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums1.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-type">int</span> next = <span class="hljs-number">-1</span>;<span class="hljs-comment">//还没找到，先设置-1</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; nums2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums2[j] == nums1[i]) &#123;<br>                    next = nums2[j];<span class="hljs-comment">//找到了，开始找大</span><br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(next == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//没找到继续找</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums2[j] &gt; next) &#123;<br>                    ans[i] = nums2[j];<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl的-下一个最大元素i">carl的-下一个最大元素I</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums1.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">// key:下标元素，value：下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            umap[nums1[i]] = i;<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">count</span>(nums2[st.<span class="hljs-built_in">top</span>()]) &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 看map里是否存在这个元素</span><br>                    <span class="hljs-type">int</span> index = umap[nums2[st.<span class="hljs-built_in">top</span>()]]; <span class="hljs-comment">// 根据map找到nums2[st.top()] 在 nums1中的下标</span><br>                    result[index] = nums2[i];<br>                &#125;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="下一个更大元素ii">503.下一个更大元素II</h1><h2 id="题目-1"><strong>题目：</strong></h2><p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0]），返回 nums 中每个元素的 下一个更大元素 。</p><p>数字 x 的 下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出-1 。<br />示例 1:<br />输入: nums = [1,2,1]<br />输出: [2,-1,2]<br />解释: 第一个 1 的下一个更大的数是 2；<br />数字 2 找不到下一个更大的数；<br />第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br />示例 2:<br />输入: nums = [1,2,3,4,3]<br />输出: [2,3,4,-1,4]<br />提示:<br /><span class="math inline">\(1 &lt;= nums.length &lt;=10^4\)</span><br /><span class="math inline">\(-10^9 &lt;= nums[i] &lt;=10^9\)</span><br />## <strong>思路：</strong> ### 我的思路</p><p>循环走就行，栈底的肯定最先被再次访问到，如果再次访问到栈底，那就退出，但是栈底还得用一次来挤出靠后的小元素，所以出循环得放在处理元素的后面。</p><p>既然要访问栈底，那用deque模拟栈。剩下的和之前如出一辙。</p><p>运行下来好像我的更快一点点，吼吼吼。 ### carl的思路</p><p>妙哉，把nums倍增一段，就算循环了，可以物理上直接倍增nums，也可以循环的时候把for的次数改成nums.size()*2，下标取模算法倍增。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[dq.<span class="hljs-built_in">back</span>()] &lt; nums[i]) &#123;<br>                ans[dq.<span class="hljs-built_in">back</span>()] = nums[i];<br>                dq.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; i == dq.<span class="hljs-built_in">front</span>()) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//不能放while开头，会少处理</span><br>            <span class="hljs-keyword">if</span>(ans[i] == <span class="hljs-number">-1</span>) dq.<span class="hljs-built_in">push_back</span>(i);<br>            i = (i+<span class="hljs-number">1</span>) % n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>carl的 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">// 模拟遍历两边nums，注意一下都是用i % nums.size()来操作</span><br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="hljs-built_in">size</span>()] &gt; nums[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                result[st.<span class="hljs-built_in">top</span>()] = nums[i % nums.<span class="hljs-built_in">size</span>()];<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day49</title>
    <link href="/2024/07/10/leetcode-day49/"/>
    <url>/2024/07/10/leetcode-day49/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/palindromic-substrings/description/">647.回文子串</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516.最长回文子序列</a> <span class="label label-warning">medium</span></li></ul><h1 id="回文子串">647. 回文子串</h1><p><strong>题目：</strong></p><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p><strong>思路：</strong></p><ol type="1"><li>确定dp含义<br />dp[i][j]表示区间s[i:j]是不是回文串<br /></li><li>确定状态转移<br /></li></ol><ul><li>s[i] == s[j]<ul><li>j - i &lt;= 1，i和j相同或挨着，dp[i][j] = true;</li><li>else，dp[i][j] = dp[i+1][j-1]，看内部是不是回文串</li></ul></li><li>s[i] != s[j]：对不上，s[i:j]不可能是回文串了，false<br /></li></ul><ol start="3" type="1"><li>初始化<br />全false</li></ol><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; s.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j]) &#123;<br>                    <span class="hljs-keyword">if</span>(i == j || i + <span class="hljs-number">1</span> == j || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                        ans++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="双指针写法">双指针写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">//复习双指针写法</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            ans += <span class="hljs-built_in">count</span>(s, i, i);<br>            ans += <span class="hljs-built_in">count</span>(s, i, i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> mid1, <span class="hljs-type">int</span> mid2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(mid2 &gt;= s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = mid1, right = mid2;<br>        <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(s[left] == s[right]) res++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            left--, right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最长回文子串">516. 最长回文子串</h1><p><strong>题目：</strong></p><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong><br />- 输入：s = "bbbab" - 输出：4 - 解释：一个可能的最长回文子序列为 "bbbb"。</p><p><strong>提示：</strong><br />- 1 &lt;= s.length &lt;= 1000 - s 仅由小写英文字母组成</p><p><strong>思路：</strong></p><ol type="1"><li>确定dp含义：<br />dp[i][j]表示区间s[i:j]内的最长回文子串长度<br /></li><li>确定状态转移：<br /></li></ol><ul><li>s[i] == s[j]<ul><li>i == j，dp[i][j]=1</li><li>dp[i][j] = dp[i-1][j-1]+2</li></ul></li><li>s[i] != s[j]: max(dp[i-1][j], dp[i][j-1])</li></ul><ol start="3" type="1"><li>初始化<br />相等的ij就置1</li></ol><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) dp[i][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;j &lt; s.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j]) &#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="其他">其他</h1><p>动态规划跟着carl刷完了，提亮看起来貌似也有这么多，但其中过半都不是自己独立做出来的，看一半题解再做、看了一半还是不会于是全抄……动态规划仍然有很多要学，仍然要多做题，今天的两道题都没有做出来，找其他的回文题仍然不会。</p><p>在做dp专题时其实有很多题的难点是想到要用dp，而做专题本身就已经告诉你每道题都可以用dp，而且carl的题安排精妙，相邻的题很多都是相同的套路，如果单拿出来做，我大概率是做不出出来的，上周周赛的Q4很像完全背包专题中的一道题，但写出来不是TLE就是WA，看评论才发现不能直接dp，所以刷题之路任重道远，戒骄戒躁，不能太依赖题解，要多自己独立思考，更不能潜移默化地被评论、tag提示。不能3分钟没思路就跑去看题解了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day48</title>
    <link href="/2024/07/09/leetcode-day48/"/>
    <url>/2024/07/09/leetcode-day48/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/distinct-subsequences/description/">115.不同的子序列</a> <span class="label label-danger">hard</span></li><li><a href="">583. 两个字符串的删除操作</a> <span class="label label-warning">medium</span></li><li><a href="">72. 编辑距离</a> <span class="label label-warning">medium</span></li></ul><h1 id="不同的子序列">115. 不同的子序列</h1><p><strong>题目：</strong></p><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在<code>s</code> 的 子序列 中 <code>t</code> 出现的个数，结果需要对 <spanclass="math inline">\(10^9 + 7\)</span> 取模。</p><blockquote><p><strong>示例 1：</strong></p><p><strong>输入：</strong> <code>s</code> = <code>"rabbbit"</code>,<code>t</code> = <code>"rabbit"</code></p><p><strong>输出：</strong> 3</p><p><strong>解释：</strong></p><p>如下所示, 有 3 种可以从 <code>s</code> 中得到 <code>"rabbit"</code>的方案。 - <u>rabb</u>b<u>it</u> - <u>ra</u>b<u>bbit</u> -<u>rab</u>b<u>bit</u></p></blockquote><p><strong>思路：</strong></p><ol type="1"><li><p>明确dp数组含义：两个子序列，仍然按照之前的老办法，二维dp，大小比串长度多1，方便初始化，<spanclass="math inline">\(dp[i][j]\)</span>含义为：在<spanclass="math inline">\(s[0:i-1]\)</span>中，<spanclass="math inline">\(t[0:j-1]\)</span>出现的个数。</p></li><li><p>建立状态转移方程：整体分为两种情况：</p><ul><li><span class="math inline">\(s[i-1] ==t[j-1]\)</span>：此时最新的s[i-1]和t[j-1]相同：<ul><li><p>如果算上<span class="math inline">\(s[i-1]\)</span>，<spanclass="math inline">\(t\)</span>就会被消耗一个，此时子序列个数就为<spanclass="math inline">\(dp[i-1][j-1]\)</span>，表示<code>s[0:i-1]中t[0:j-1]出现次数</code></p></li><li><p>但根据示例可看出：即使<spanclass="math inline">\(s[i-1]==t[j-1]\)</span>，<spanclass="math inline">\(s[i-1]\)</span>也可以不用于匹配，这时子序列个数就为<spanclass="math inline">\(dp[i-1][j]\)</span>，表示<code>s[0:i-2]</code>中<code>t[0:j-1]</code>出现次数</p></li></ul></li><li><span class="math inline">\(s[i-1] ≠t[j-1]\)</span>：此时最新的<spanclass="math inline">\(s[i-1]\)</span>和<spanclass="math inline">\(t[j-1]\)</span>不相同，意味着s中未出现新的t，所以只继承前面的结果<spanclass="math inline">\(dp[i-1][j]\)</span>，表示<code>s[0:i-2]</code>中<code>t[0:j-1]</code>出现的次数</li></ul><p>由此可构建出状态转移方程：</p></li></ol><p><span class="math display">\[dp[i][j]\ =\begin{cases}1, &amp; \text{$j=0,\ i&gt;0$} \\0, &amp; \text{$i=0,\ j&gt;0$} \\dp[i-1][j-1]+dp[i-1][j], &amp; \text{$s[i-1]=t[j-1],\ i,\ j&gt;0$} \\dp[i-1][j], &amp; \text{$s[i-1]=t[j-1],\ i,\ j&gt;0$}\end{cases}\]</span></p><p>根据状态转移方程可知需由左上遍历到右下</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt; (t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= t.<span class="hljs-built_in">size</span>();j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= s.<span class="hljs-built_in">size</span>();i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= t.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<span class="hljs-comment">//</span><br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)dp[s.<span class="hljs-built_in">size</span>()][t.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="两个字符串的删除操作">583. 两个字符串的删除操作</h1><p><strong>题目：</strong></p><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得<code>word1</code> 和 <code>word2</code>相同所需的最小步数。</p><p>每步可以删除任意一个字符串中的一个字符。</p><p><strong>示例 1：</strong></p><ul><li>输入: <code>word1</code> = <code>"sea"</code>, <code>word2</code> =<code>"eat"</code></li><li>输出: 2</li><li>解释: 第一步将 <code>"sea"</code> 变为 <code>"ea"</code> ，第二步将<code>"eat "</code>变为 <code>"ea"</code></li></ul><p><strong>思路：</strong></p><p>二维dp：</p><ol type="1"><li>确定dp数组以及下标含义</li></ol><p><span class="math inline">\(dp[i][j]\)</span>表示<spanclass="math inline">\(word1[0:i-1]\)</span>和<spanclass="math inline">\(word2[0:j-1]\)</span>达到相等需要的最小步数</p><ol start="2" type="1"><li>确定递推公式</li></ol><ul><li><span class="math inline">\(word1[i-1] ==word2[j-1]\)</span>时，无需删除，直接继承之前状态</li><li><span class="math inline">\(word1[i-1] ≠ word2[j-1]\)</span>时：<ul><li>删<span class="math inline">\(word1[i-1]\)</span>，步数为<spanclass="math inline">\(dp[i-1][j]+1\)</span></li><li>删<span class="math inline">\(word2[j-1]\)</span>，步数为<spanclass="math inline">\(dp[i][j-1]+1\)</span></li><li>都删了，步数为<span class="math inline">\(dp[i-1][j-1]+2 =dp[i-1][j] + 1\)</span>，和前两种情况相同</li></ul></li></ul><p>状态转移方程为：</p><p><span class="math display">\[dp[i][j]\ =\begin{cases}i, &amp; \text{$i&gt;0,j=0$} \\j, &amp; \text{$j&gt;0,i=0$} \\min(dp[i-1][j], dp[i][j-1])+1, &amp; \text{$i,\ j&gt;0,\word_1[i]≠word_2[j]$} \\dp[i-1][j-1], &amp; \text{else}\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= word2.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= word2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-built_in">size</span>()][word2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="编辑距离">72. 编辑距离</h1><p><strong>题目：</strong></p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将<code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>思路：</strong></p><p>经过前几题，这题要理解到插入其实相当于删除，在一个串中插入，就相当于在另一个串中删除</p><ol type="1"><li>确定dp数组以及下标含义</li></ol><p><span class="math inline">\(dp[i][j]\)</span>表示<spanclass="math inline">\(word1[0:i-1]\)</span>和<spanclass="math inline">\(word2[0:j-1]\)</span>达到相等需要的最小操作数</p><ol start="2" type="1"><li>确定递推公式</li></ol><ul><li><span class="math inline">\(word1[i-1] ==word2[j-1]\)</span>时，无需操作，直接继承之前状态</li><li><span class="math inline">\(word1[i-1] ≠ word2[j-1]\)</span>时：<ul><li>删<span class="math inline">\(word1[i-1]\)</span>，步数为<spanclass="math inline">\(dp[i-1][j]+1\)</span></li><li>删<span class="math inline">\(word2[j-1]\)</span>，步数为<spanclass="math inline">\(dp[i][j-1]+1\)</span></li><li>替换其中一个，步数为<spanclass="math inline">\(dp[i-1][j-1]+1\)</span></li></ul></li></ul><p>状态转移方程为：</p><p><span class="math display">\[dp[i][j]\ =\begin{cases}i, &amp; \text{$i&gt;0,j=0$} \\j, &amp; \text{$j&gt;0,i=0$} \\min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1, &amp; \text{$i,\ j&gt;0,\word_1[i]≠word_2[j]$} \\dp[i-1][j-1], &amp; \text{else}\end{cases}\]</span></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= word2.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= word2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]&#125;) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-built_in">size</span>()][word2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git提交PR</title>
    <link href="/2024/07/08/%E8%AE%B0%E4%B8%80%E6%AC%A1git%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E7%BB%8F%E5%8E%86/"/>
    <url>/2024/07/08/%E8%AE%B0%E4%B8%80%E6%AC%A1git%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E7%BB%8F%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="本文背景">本文背景</h1><p>期末考完想向学长的资料公开仓库贡献一些资料，顺便帮助建设一下混个contributor当当。但是只在自己的大小号上实践过PR(pullrequest)操作的我头一次向别人的repo(repository)提交PR，遂记录过程中遇到的问题和解决方法，倒逼自己搞清楚其中原因。同时也作为提交PR的教程作参考。</p><p>本文关于git操作的说法偏向浅显易懂，稍有啰嗦，如有原理性错误，烦请批评指正，联系方式见<ahref="https://novelyear.github.io/about/">关于页</a>。</p><h1 id="问题描述">问题描述</h1><ol type="1"><li><p>我在GitHub上fork了别人的仓库，然后将fork的仓库pull到本地进行修改，修改后push到fork的仓库的master分支，然后又在github上直接在main分支上新增了内容，请问我该如何将远程仓库的main上的新内容和远程仓库上master分支的内容融合，两个内容并无重合，都是新内容。如何合并分支并提交PR？</p></li><li><p>我在本地又修改了文件，在main分支上commit了该修改，并push到远程仓库上，但是并未发生改变，我更新了远程仓库，然后在main分支fetch了，随后发现本地修改的文件又回到了原状，于是重新修改，并切换到master分支add和commit，在切换回main分支并fetch和pull之后，merge时提示冲突，应该如何解决？</p></li></ol><h1 id="提交pr前的准备工作">提交PR前的准备工作</h1><blockquote><p>提交PR首先得先改好才能交 ## fork目标repo进入目标repo的首页，即页面栏显示<code>Code</code>字样、域名末尾为repo名称的页。</p></blockquote><p>点击fork，将在自己的名下新建一个同名repo，相当于把对方的repo复制到了自己名下，这样就可以任意修改内容而不至于对原repo的内容造成影响，并且，<strong>只有fork了才能向原仓库提交PR</strong>。## 拿到本地进行修改这时名下已经有了一个同名repo，在本地新建个文件夹用来装这个repo的内容，在这个文件夹里打开gitbash，在fork来的repo里复制链接，<code>git pull</code>到本地。</p><blockquote><p>若读者尚未将git与github绑定，请参见：</p></blockquote><p>此时可用<code>git branch</code>查看当前分支，大概率是<code>master</code>，因为<code>git pull</code>只给远程分支不给本地分支名默认为<code>master</code>。</p><p>用<code>git remote -v</code>查看当前远程分支，如果没有，就<code>git remote add BRANCH_NAME URL</code>添加，url就是repo的链接,BRANCH_NAME就是远程分支的名字，一般设置成<code>origin</code>。</p><p>然后就可以开始在本地修改内容啦！</p><h2 id="修改完提交到远程仓库">修改完提交到远程仓库</h2><p>修改完后，再回到gitbash，<code>git add .</code>和<code>git commit</code>，可用<code>git status</code>查看跟踪(add)和提交(commit)的状态。</p><p><code>git push origin master</code>，就当你的远程分支名字是origin，将分支master提交到origin分支上去，即上传到远程仓库。</p><h1 id="提交pr">提交PR</h1><p>此时回到fork来的repo，点击contribute，会显示当前已经领先原repo多少个commit，直接openpr，描述一下修改内容，点击提交就成功提交了PR。</p><h3 id="问题1解决过程">问题1解决过程</h3><blockquote><p>问题1可对应到实际场景中自己工作完成慢了，别人先交了PR过了，自己还得去迎合别人的分支，解决完冲突才能提交。</p></blockquote><p>我在本地修改完后还未提交前，在远程仓库上直接做了修改，这导致我的远程仓库除了我本地修改的内容外，还有其他内容与本地master分支不一样，所以不能直接push</p><p>先在本地再创建一个main分支<code>git checkout main</code>，然后将最新的远程仓库pull到main分支，在本地合并main和master分支<code>git merge master</code></p><p>由于master和远程分支origin修改的地方不同，所以不会有冲突，直接merge成功，然后在main分支上再add、commit、push。</p><p>其实也可以将main融进master中，使master始终最新，方便进一步修改。</p><h3 id="问题2解决过程">问题2解决过程</h3><blockquote><p>问题2对应到实际场景中提交了PR结果被打回重造，这期间又有人交了PR还过了，不得不再去融合别人的分支，可恨的是这个人和你修改的文件还是同一个，还不能直接merge。</p></blockquote><p>仍然在main中pull最新的远程仓库，如果是fork来的，还要先在github上同步。</p><p>然后gitmerge，会显示冲突的文件，在本地打开文件(推荐使用vscode等支持git的IDE，会高亮显示冲突)，找到冲突的地方，会有明显的标志，类似于：<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>// changes from main branch<br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br>// changes from master branch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; master<br></code></pre></td></tr></table></figure>这时需要选择采用当前的分支、采用另一个分支还是融合内容，融合好后才能merge。之后就一般流程：add、commit、push。</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day47</title>
    <link href="/2024/07/08/leetcode-day47/"/>
    <url>/2024/07/08/leetcode-day47/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/longest-common-subsequence/">1143.最长公共子序列</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/uncrossed-lines/">1035.不相交的线</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/is-subsequence/">392.判断子序列</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/maximum-subarray/description/">53.最大子数组和</a> <span class="label label-warning">medium</span></li></ul><h1 id="最长公共子序列">1143. 最长公共子序列</h1><p><strong>题目：</strong></p><p>给定两个字符串 <code>text1</code> 和<code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong>的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code>。</p><p>一个字符串的 <strong>子序列</strong>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但<code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li></ul><p>两个字符串的 <code>公共子序列</code>是这两个字符串所共同拥有的子序列。</p><p><strong>思路：</strong></p><p>有两个string，公共子序列出现的地方可能不同，需要i和j两个变量来记录公共子序列在两个string里的范围，以范围逐渐扩张来实现状态的不断推进，二维动态规划。</p><p><strong>1. 确定dp数组含义</strong></p><p><span class="math inline">\(dp[i][j]\)</span>表示字符串<spanclass="math inline">\(text_1\)</span>长度为i的前缀，即<spanclass="math inline">\(text1[0:i]\)</span>，和<spanclass="math inline">\(text_2\)</span>长度为j的前缀的最长公共子序列的长度。</p><p><strong>2. 确定状态转移方程</strong></p><p><span class="math display">\[dp[i][j]\ =\begin{cases}dp[i-1][j-1]+1, &amp; \text{$text_1[i-1]=text_2[j-1]$} \\max(dp[i-1][j],\ dp[i][j-1]), &amp; \text{$text_1[i-1]≠text_2[j-1]$}\end{cases}\]</span></p><p>解释：</p><ul><li>当<spanclass="math inline">\(text_1[i-1]=text_2[j-1]\)</span>时，<spanclass="math inline">\(text_1\)</span>长度为<spanclass="math inline">\(i\)</span>的前缀结尾与<spanclass="math inline">\(text_2\)</span>长度为<spanclass="math inline">\(j\)</span>的前缀结尾相同，在长度为<spanclass="math inline">\(i-1\)</span>和<spanclass="math inline">\(j-1\)</span>的最长公共子序列基础上再加一，即<spanclass="math inline">\(dp[i-1][j-1]+1\)</span></li><li>当<spanclass="math inline">\(text_1[i-1]≠text_2[j-1]\)</span>时，相当于末尾没对上，这时不能在之前的基础上加一，需要继承之前的结果，而之前有两个前缀：<ul><li><span class="math inline">\(text_1[0:i-1]\)</span>和<spanclass="math inline">\(text_2[0:j]\)</span>的最长公共子序列</li><li><span class="math inline">\(text_2[0:j-1]\)</span>和<spanclass="math inline">\(text_1[0:i]\)</span>的最长公共子序列</li></ul></li><li>取其中最大值。</li></ul><p><strong>3. 初始化</strong></p><p>为了方便初始化，dp数组的大小设置成了<spanclass="math inline">\((text_1.size()+1)*(text_2.size()+1)\)</span>表示一个左闭右开的区间，同时也以下标表示前缀长度。</p><p>此时<spanclass="math inline">\(dp[0][0]\)</span>实际无意义，所以初始化<spanclass="math inline">\(0\)</span>，遍历都从<spanclass="math inline">\(0\)</span>开始。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= text1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= text2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(text1[i - <span class="hljs-number">1</span>] != text2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.<span class="hljs-built_in">size</span>()][text2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="不相交的线">1035. 不相交的线</h1><p><strong>题目：</strong></p><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和<code>nums2</code> 中的整数。</p><p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和<code>nums2[j]</code> 的直线，这些直线需要同时满足：</p><ul><li><code>nums1[i] == nums2[j]</code></li><li>且绘制的直线不与任何其他连线（非水平线）相交。</li></ul><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p><p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p><figure><img src="https://assets.leetcode.com/uploads/2019/04/26/142.png"alt="盗链lc" /><figcaption aria-hidden="true">盗链lc</figcaption></figure><p><strong>思路：</strong></p><p>看图就会发现，这简直就是上一道题换皮，直接套代码就行。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxUncrossedLines</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-comment">//换皮最长公共子序列</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= nums1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= nums2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums1.<span class="hljs-built_in">size</span>()][nums2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="判断子序列">392. 判断子序列</h1><p><strong>题目：</strong></p><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断<strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>"ace"</code>是<code>"abcde"</code>的一个子序列，而<code>"aec"</code>不是）。</p><p><strong>进阶：</strong></p><p>如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k &gt;=10亿，你需要依次检查它们是否为 T的子序列。在这种情况下，你会怎样改变代码？</p><p><strong>思路：</strong></p><p>双指针，短的匹配到再走，长的一直走，短的走到头则是子序列。</p><p>动态规划：</p><ul><li>参考1143题的初始化方法，dp数组初始化为<spanclass="math inline">\((s.size()+1)*(t.size()+1)\)</span>，使<spanclass="math inline">\(dp[0][0]\)</span>无意义。遍历都从1开始。</li><li><span class="math inline">\(dp[i][j]\)</span>代表<spanclass="math inline">\(s[0:i-1]\)</span>和<spanclass="math inline">\(t[0:j-1]\)</span>公共子序列长度</li><li>状态转移方程为：</li></ul><p><span class="math display">\[dp[i][j]\ =\begin{cases}dp[i-1][j-1]+1, &amp; \text{$s[i-1]=t[j-1], i,j&gt;0$} \\dp[i][j-1], &amp; \text{$else$}\end{cases}\]</span></p><ul><li>匹配到则推进状态，公共子序列长度加一</li><li>未匹配则继承状态，注意<spanclass="math inline">\(s\)</span>不前进而<spanclass="math inline">\(t\)</span>前进，代表继续在<spanclass="math inline">\(t\)</span>中寻找<spanclass="math inline">\(s[i]\)</span></li></ul><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &gt; t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//开大一个，方便处理0情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= t.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<span class="hljs-comment">//匹配，i和j都往前走</span><br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<span class="hljs-comment">//未匹配，s不能动，t往前走</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()][t.<span class="hljs-built_in">size</span>()] == s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//如果s走到最后，则是</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最大子数组和">53. 最大子数组和</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><p><strong>思路：</strong></p><p>依据贪心的思路，可以迁移到动态规划来，贪心就是和为负之后，就对之后没有贡献了，直接抛弃，将下一个作为新起点重新计算子数组和，动态规划也可以这样：</p><ul><li><span class="math inline">\(dp[i]\)</span>代表以<spanclass="math inline">\(nums[i]\)</span>结尾的最大子数组和</li><li>若<spanclass="math inline">\(dp[i-1]&lt;0\)</span>，则抛弃，以当前<spanclass="math inline">\(nums[i]\)</span>作为新起点：<spanclass="math inline">\(dp[i] = nums[i]\)</span></li><li>若<spanclass="math inline">\(dp[i-1]&gt;=0\)</span>，则继承结果：<spanclass="math inline">\(dp[i] = dp[i-1]+nums[i]\)</span></li><li><span class="math inline">\(dp[0]\)</span>按意义该初始化为<spanclass="math inline">\(nums[0]\)</span></li><li>用一个变量记录其中最大的子数组和</li></ul><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(dp[i - <span class="hljs-number">1</span>] &lt;= <span class="hljs-number">0</span>) dp[i] = nums[i];<br>            <span class="hljs-keyword">else</span> dp[i] = dp[i - <span class="hljs-number">1</span>] + nums[i];<br>            ans = <span class="hljs-built_in">max</span>(dp[i], ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day45</title>
    <link href="/2024/07/07/leetcode-day45/"/>
    <url>/2024/07/07/leetcode-day45/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674.最长连续递增子序列</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718.最长重复子数组</a> <span class="label label-warning">medium</span></li></ul><h1 id="最长递增子序列">300. 最长递增子序列</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code>是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>思路：</strong></p><p><span class="math inline">\(dp[i]\)</span>表示以<spanclass="math inline">\(nums[i]\)</span>结尾的最长递增子序列长度，强制以<spanclass="math inline">\(nums[i]\)</span>结尾为的是方便状态转移，状态转移方程为：</p><p><span class="math display">\[dp[i]\ =\begin{cases}1, &amp; \text{$i = 1$} \\max(dp[j] + 1, dp[i]), &amp; \text{$i &gt; 1,\ j=0,1,2,……,i-1$}\end{cases}\]</span></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; i;j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[j] + <span class="hljs-number">1</span>, dp[i]);<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最长连续递增子序列">674. 最长连续递增子序列</h1><p><strong>题目：</strong></p><p>给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 <code>l</code> 和<code>r</code>（<code>l &lt; r</code>）确定，如果对于每个<code>l &lt;= i &lt; r</code>，都有<code>nums[i] &lt; nums[i + 1]</code> ，那么子序列<code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code>就是连续递增子序列。</p><p><strong>思路：</strong></p><p>这题感觉就像贪心一样，一直换起点就好，dp换起点就是重新把长度改成1</p><p>dp[i]表示以i结尾的最长连续递增序列长度，状态转换方程为：</p><p><span class="math display">\[dp[i]\ =\begin{cases}1, &amp; \text{$nums[i] ≤ nums[i - 1]$}\\dp[i - 1] + 1, &amp; \text{$nums[i]≥nums[i-1]$}\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-number">1</span>;<br><br>            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最长重复子数组">718. 最长重复子数组</h1><p><strong>题目：</strong></p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度 。</p><p><strong>思路：</strong></p><p>由于两个数组的公共子数组起点可能不一样，所以得用<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>分别表示从<spanclass="math inline">\(nums1\)</span>的<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(nums2\)</span>的<spanclass="math inline">\(j\)</span>开始。</p><p>状态转移方程为：(前提条件都为<code>nums1[i] == nums2[j]</code>)</p><p><span class="math display">\[dp[i][j]\ =\begin{cases}1, &amp; \text{$i=0\ or\ j=0$} \\dp[i-1][j-1]+1, &amp; \text{else}\end{cases}\]</span></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; nums2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums1[i] != nums2[j]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) dp[i][j]  = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                ans = <span class="hljs-built_in">max</span>(ans, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day44</title>
    <link href="/2024/07/07/leetcode-day44/"/>
    <url>/2024/07/07/leetcode-day44/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188.买卖股票的最佳时机Ⅳ</a> <span class="label label-danger">hard</span></li><li><a href="">309. 最佳买卖股票时机含冷冻期</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714.买卖股票的最佳时机含手续费</a> <span class="label label-warning">medium</span></li></ul><h1 id="买卖股票的最佳时机ⅳ">188. 买卖股票的最佳时机Ⅳ</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中<code>prices[i]</code> 是某支给定的股票在第 <code>i</code>天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code>笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code>次。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>思路：</strong></p><p>股票题3只能买两次，设置了5个状态，无、1有、1无、2有、2无，迁移到这里就是无 + k组有无，一共<span class="math inline">\(2*k+1\)</span>个状态。</p><p>使用三维dp时空复杂度太过感人，就不写思路了，直接写carl的二维简化版思路：</p><p><span class="math inline">\(dp[i][j]\)</span>表示第<spanclass="math inline">\(i\)</span>天的情况，<spanclass="math inline">\(j\)</span>为状态：</p><ul><li><span class="math inline">\(0\)</span>表示无操作</li><li><span class="math inline">\(1\)</span>表示第一次卖掉</li><li><span class="math inline">\(2\)</span>表示第一次买入</li><li><span class="math inline">\(3\)</span>表示第二次卖掉</li><li><span class="math inline">\(4\)</span>表示第二次买入</li><li>……</li><li><span class="math inline">\(2k-1\)</span>表示第<spanclass="math inline">\(k\)</span>次卖掉</li><li><span class="math inline">\(2k\)</span>表示第<spanclass="math inline">\(k\)</span>次买入</li></ul><p>可见偶数表示买入，奇数表示卖出，详细解释见代码注释：</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt; <span class="hljs-number">2</span> * k;j += <span class="hljs-number">2</span>)<br>      dp[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>];<span class="hljs-comment">//首日买入都是直接减</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>;j += <span class="hljs-number">2</span>) &#123;<br>        dp[i][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j] - prices[i]);<span class="hljs-comment">//i天前交易j+1次不买 = 昨天前交易j+1次没买/昨天前交易j次买了，今天卖掉</span><br>        dp[i][j + <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + prices[i]);<span class="hljs-comment">//i天前交易j+2次买 = 昨天前交易j+1次就买了，今天卖掉/昨天就交易j+2次，已经卖了</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>*k];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最佳买卖股票时机含冷冻期">309. 最佳买卖股票时机含冷冻期</h1><p><strong>题目：</strong></p><p>给定一个整数数组prices，其中第 prices[i] 表示第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>思路：</strong></p><p>没想出来，状态设置出了问题</p><p>卖出后会有冷冻期，由于只有一支股票，所以冷冻期只能无操作，则一天会有4个状态：</p><ul><li>0：无操作</li><li>1：卖出</li><li>2：买入</li><li>3：冷冻期</li></ul><p><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/518d5baaf33f4b2698064f8efb42edbf.png" /></p><p>知道这个就好写代码了</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-comment">//可多次，但不能连续</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//0无操作，1卖，2买，3冷冻</span><br>    dp[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>      dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>      dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] + prices[i]);<br>      dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] - prices[i]);<span class="hljs-comment">//昨天买好/昨天冷冻今天买</span><br>      dp[i][<span class="hljs-number">3</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机含手续费">714. 买卖股票的最佳时机含手续费</h1><p><strong>题目：</strong></p><p>给定一个整数数组 <code>prices</code>，其中<code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数<code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>思路：</strong></p><p>题目的注意指出每组买卖只需要交一次手续费，那设置在卖出时缴纳手续费，其余代码同股票2题一样</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//0buy, 1sell</span><br>    dp[<span class="hljs-number">0</span>] = &#123;-prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] - prices[i]);<br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] + prices[i] - fee);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day43</title>
    <link href="/2024/07/07/leetcode-day43/"/>
    <url>/2024/07/07/leetcode-day43/</url>
    
    <content type="html"><![CDATA[<p>今日内容：股票专题日🤑</p><ul><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121.买卖股票的最佳时机</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122.买卖股票的最佳时机Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123.买卖股票的最佳时机Ⅲ</a> <span class="label label-danger">hard</span></li></ul><h1 id="买卖股票的最佳时机">121. 买卖股票的最佳时机</h1><p><strong>题目：</strong></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素<code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在<strong>未来的某一个不同的日子</strong>卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回<code>0</code> 。</p><p><strong>思路：</strong></p><p>很明显的状态转移，昨天买了和昨天没有买两种情况，昨天买了今天就卖或者持有，昨天没买今天就买或者继续观望，最后返回今天卖了或不卖中的最大值。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = prices.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], -prices[i]);<span class="hljs-comment">//昨天买了；昨天没买今天买</span><br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], prices[i] + dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>]);<span class="hljs-comment">//昨天没买；昨天买了今天卖</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[(len - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<span class="hljs-comment">//卖了肯定比拿手里强，返回卖了的</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机ⅱ">122. 买卖股票的最佳时机Ⅱ</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code>表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候<strong>最多</strong> 只能持有 <strong>一股</strong>股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 你能获得的 <strong>最大</strong> 利润 。</p><p><strong>思路：</strong></p><p>与上一题的区别在于，这题可以多次买卖，如果按贪心来做的话，直接累积上升就可以。</p><p>按dp来做，仍然保留买与没买的状态区别，对于买的状态要修改，上一道题只能买一次，所以买必定是第一次，从0开始算盈亏。这里就需要记录之前的盈亏，因为买不一定是第一次。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-comment">//dp非滚动写法</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    dp[<span class="hljs-number">0</span>] = &#123;-prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//0买，1不买</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-comment">//与上一题的区别：-prices[i]变成了dp[i-1 % 2][1] - prices[i]，在昨天没买的基础上计算</span><br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] - prices[i]); <span class="hljs-comment">//i天买，昨天买了不能再买/昨天没买今天买</span><br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] + prices[i]); <span class="hljs-comment">//i天不买，昨天没买/昨天买了今天卖掉</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机ⅲ">123. 买卖股票的最佳时机Ⅲ</h1><p><strong>题目：</strong></p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第<code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成<strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>思路：</strong></p><p>只能买两次，所以变复杂了很多，<del>不愧是hard，一下给我干趴下了</del>，思路是抄的，没想出来😭</p><p>根据之前的经验，可以分为买和不买两种状态，由于这里只能买卖两次，所以分为四种状态（或者说阶段 ）：</p><ul><li>第一次还没买</li><li>第一次买了在手里</li><li>第二次还没买（第一次已经卖掉了）</li><li>第二次卖掉了</li></ul><p>每个状态都可以如之前一样分别由昨天和今天来得到，取最大值，于是得到如下代码</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<span class="hljs-comment">// 相当于第一天买了卖再买，可不能设成0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>      dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<span class="hljs-comment">//第一次有，昨天就买了；昨天没有，今天才买第一个</span><br>      dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<span class="hljs-comment">//第一次没有，昨天就没有；昨天有，今天才卖掉第一个</span><br>      dp[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<span class="hljs-comment">//第二次有，昨天就有；昨天没有，今天才买第二个</span><br>      dp[i][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);<span class="hljs-comment">//第二次没有，昨天就没有；昨天有，今天才卖掉第二个</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<span class="hljs-comment">//</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day42</title>
    <link href="/2024/07/07/leetcode-day42/"/>
    <url>/2024/07/07/leetcode-day42/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/house-robber/">198.打家劫舍</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/house-robber-ii/description/">213.打家劫舍Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/house-robber-iii/description/">337.打家劫舍Ⅲ</a> <span class="label label-warning">medium</span></li></ul><h1 id="打家劫舍">198. 打家劫舍</h1><p><strong>题目：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><ul><li><p>示例 1：</p></li><li><p>输入：[1,2,3,1]</p></li><li><p>输出：4</p></li><li><p>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。</p></li><li><p>示例 2：</p></li><li><p>输入：[2,7,9,3,1]</p></li><li><p>输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 =9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12。</p></li><li><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 400</li></ul></li></ul><p><strong>思路：</strong></p><p>跟着随想录刷题相当于做题看了tag，所以有思路提示，一开始就知道能够用动态规划来解。</p><p>dp[i]代表打劫[0, i]区间内的房屋的最高金额，状态转换方程如下：</p><p><span class="math display">\[dp[i]\ =\begin{cases}nums[0], &amp; \text{$i\ =\ 0$} \\max(nums[0],\ nums[1]), &amp; \text{$i\ =\ 1$} \\max(dp[i - 2] + nums[i],\ dp[i - 1]), &amp; \text{else}\end{cases}\]</span></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) dp[i] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>      <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>  &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="打家劫舍ⅱ">213. 打家劫舍Ⅱ</h1><p><strong>题目：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈</strong>，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下</strong>，今晚能够偷窃到的最高金额。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>一开始想复杂了：由于循环，所以从某处开始，相当于把上一个给去掉，然后仍然按线性来遍历，于是遍历物品，把每种物品都做一次开头再遍历背包，然后选出最多的一个。这样时间复杂度来到了<spanclass="math inline">\(O(n^2)\)</span></p>          </div><p>实际上这道题和前一道题区别不大，多出的循环机制可以分成两种情况：</p><ul><li>含首不含尾 <imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160821374-20230310134003961.jpg" /></li><li>含尾不含首 <imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160842491-20230310134008133.jpg" /></li></ul><p>所以只需要两种情况都走一遍取最大值就好了。</p><h2 id="代码-1">代码</h2><h3 id="自己过题的复杂代码">自己过题的复杂代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<span class="hljs-comment">//每个nums[i]作起点的初始化</span><br>      dp[i][<span class="hljs-number">0</span>] = nums[i];<br>      dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[i], nums[(i+<span class="hljs-number">1</span>)%nums.<span class="hljs-built_in">size</span>()]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;j &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;j++) &#123;<span class="hljs-comment">//每个i都做一次起点，都打劫一遍，去掉i之前的一个</span><br>        dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">2</span>] + nums[(i + j) % nums.<span class="hljs-built_in">size</span>()], dp[i][j - <span class="hljs-number">1</span>]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>      ans = <span class="hljs-built_in">max</span>(ans, dp[i][nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl的更优代码">carl的更优代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> result1 = <span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>); <span class="hljs-comment">// 情况二</span><br>        <span class="hljs-type">int</span> result2 = <span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 情况三</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result1, result2);<br>    &#125;<br>    <span class="hljs-comment">// 198.打家劫舍的逻辑</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (end == start) <span class="hljs-keyword">return</span> nums[start];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[start] = nums[start];<br>        dp[start + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start + <span class="hljs-number">2</span>; i &lt;= end; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[end];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><ahref="https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 打家劫舍Ⅱ</a></p><h1 id="打家劫舍ⅲ">337. 打家劫舍Ⅲ</h1><p><strong>题目：</strong></p><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为<code>root</code> 。</p><p>除了 <code>root</code>之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong>，房屋将自动报警。</p><p>给定二叉树的 <code>root</code> 。返回<strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额 。</p><p><strong>思路：</strong></p><p><strong>暴力递归：</strong></p><p>跟之前的按监控的题很像，然后思维定势直接后序遍历了，结果美美TLE。又用map来记录已经算过的值防止重复计算，这才AC。</p><p>这个思路和监控题很类似，当前树有两种打劫法：</p><ul><li>打劫儿子，放过根和孙子</li><li>打劫根和孙子，放过儿子</li></ul><p>只要找出最大的就行了。</p><p><strong>树形DP：</strong></p><p>由于是树，还是单向指针，所以不能像之前那样靠dp[i -2]来做到间隔抢劫，得不断上传“抢没抢”的信息，所以每次递归都要返回两个值，抢了当前节点的最大赃款和不抢当前节点的最大赃款。</p><p>递归终止条件自然是遇到null，直接返回0就行，遍历肯定后序遍历，因为处理root得先得到子树的信息，那么单层遍历就是先左再右，最后求出抢root的最大赃款和不抢root的最大赃款，全都返回，再返回最大的一个。</p><h2 id="代码-2">代码</h2><h3 id="暴力递归">暴力递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  unordered_map&lt;TreeNode *, <span class="hljs-type">int</span>&gt; map;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, grandson = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>      <span class="hljs-keyword">return</span> root-&gt;val;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right) &#123;<br>      <span class="hljs-keyword">if</span>(map[root-&gt;right]) right = map[root-&gt;right];<br>      <span class="hljs-keyword">else</span> &#123;<br>        right = <span class="hljs-built_in">rob</span>(root-&gt;right);<br>        map[root-&gt;right] = right;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(!map[root-&gt;right-&gt;left]) &#123;<br>        map[root-&gt;right-&gt;left] = <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;left);<br>      &#125;<br>      grandson += map[root-&gt;right-&gt;left];<br>      <span class="hljs-keyword">if</span>(!map[root-&gt;right-&gt;right]) map[root-&gt;right-&gt;left] = <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;right);<br>      grandson += map[root-&gt;right-&gt;right];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;left)&#123;<br>      <span class="hljs-keyword">if</span>(map[root-&gt;left]) left = map[root-&gt;left];<br>      <span class="hljs-keyword">else</span> &#123;<br>        left = <span class="hljs-built_in">rob</span>(root-&gt;left);<br>        map[root-&gt;left] = left;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(!map[root-&gt;left-&gt;left]) &#123;<br>        map[root-&gt;left-&gt;left] = <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;left);<br>      &#125;<br>      grandson += map[root-&gt;left-&gt;left];<br>      <span class="hljs-keyword">if</span>(!map[root-&gt;left-&gt;right]) map[root-&gt;left-&gt;left] = <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;right);<br>      grandson += map[root-&gt;left-&gt;right];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(root-&gt;val + grandson, left + right);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="树形dp">树形dp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result = <span class="hljs-built_in">robTree</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result[<span class="hljs-number">0</span>], result[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 长度为2的数组，0：不偷，1：偷</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">robTree</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left);<br>        vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right);<br>        <span class="hljs-comment">// 偷cur，那么就不能偷左右节点。</span><br>        <span class="hljs-type">int</span> val1 = cur-&gt;val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况</span><br>        <span class="hljs-type">int</span> val2 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> &#123;val2, val1&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day41</title>
    <link href="/2024/07/06/leetcode-day41/"/>
    <url>/2024/07/06/leetcode-day41/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/coin-change/">322.零钱兑换</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/perfect-squares/description/">279.完全平方数</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/word-break/description/">139.单词拆分</a> <span class="label label-warning">medium</span></li></ul><h1 id="零钱兑换">322. 零钱兑换</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>coins</code>，表示不同面额的硬币；以及一个整数 <code>amount</code>，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong>。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>思路：</strong></p><p>完全背包，dp[j]含义为凑成j需要的最少硬币个数，状态转移方程为：</p><p><span class="math display">\[dp[j]\ =\begin{cases}0, &amp; \text{$j\ =\ 0$} \\min(dp[j\ -\ coin[i]] + 1, dp[j]), &amp; \text{else}\end{cases}\]</span></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; coins.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = coins[i];j &lt;= amount;j++) &#123;<br>        <span class="hljs-keyword">if</span>(dp[j - coins[i]] != INT_MAX) dp[j] = <span class="hljs-built_in">min</span>(dp[j - coins[i]] + <span class="hljs-number">1</span>, dp[j]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount] == INT_MAX ? <span class="hljs-number">-1</span> : dp[amount];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="完全平方数">279. 完全平方数</h1><p><strong>题目：</strong></p><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p><p>完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9和 16 都是完全平方数，而 3 和 11 不是。</p><p><strong>思路：</strong></p><p>其实一开始考虑了数学，但只是记得有相关的数论结论，忘了具体内容，于是果断采用程序员做法————直接dp，很明显的完全背包，只是要求最少数量，把dp含义改一下就好，同时也要根据新的状态转移方程决定新的初始化方式。</p><p>dp[j]表示整数j需要的完全平方数的最少数量</p><p>状态转移方程为：</p><p><span class="math display">\[dp[j]\ =\begin{cases}0, &amp; \text{$j\ =\ 0$} \\min(dp[j], dp[j - i*i] + 1), &amp; \text{$j\ ≥\ i^2, i\ =\ 1,2,3,……$} \\\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-built_in">sqrt</span>(n);i &gt; <span class="hljs-number">0</span>;i--) &#123;<span class="hljs-comment">//稍微剪了剪枝，无伤大雅</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i*i; j &lt;= n;j++) &#123;<br>        <span class="hljs-keyword">if</span>(dp[j - i*i] != INT_MAX) dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - i*i] + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="单词拆分">139. 单词拆分</h1><p><strong>题目：</strong></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code>作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code>则返回 <code>true</code>。</p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>思路：</strong></p><p>把s看成要填满的背包，从dict里一个一个试着装，这时候就不能太死板，要灵活迁移dp的含义：</p><p>dp[j]表示区间[0, j)的s能不能被表示</p><p>那么状态转移方程为：</p><p><span class="math display">\[dp[j] =\begin{cases}true, &amp; \text{$j = 0$} \\dp[j]\ OR\ (dp[j - wordDict[i].size()]\ AND\ s(j\ -\wordDict[i].size())\ ==\ wordDict[i]), &amp; \text{else}\end{cases}\]</span></p><ul><li>还要想到：这里必须先遍历背包容量再遍历字典，不然无法实现拼接，而是一直在判断s的开头。</li><li>还可以对字典去去重</li></ul><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= s.<span class="hljs-built_in">size</span>();j++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; wordDict.<span class="hljs-built_in">size</span>();i++) &#123;<br>          <span class="hljs-keyword">if</span>(j &gt;= wordDict[i].<span class="hljs-built_in">size</span>()) dp[j] = dp[j] || (dp[j - wordDict[i].<span class="hljs-built_in">size</span>()] &amp;&amp; <span class="hljs-built_in">strcmp</span>(s, j - wordDict[i].<span class="hljs-built_in">size</span>(), j, wordDict[i]));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()];<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end, string word)</span> </span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; end;i++) &#123;<br>      <span class="hljs-keyword">if</span>(s[i] != word[j++]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day40</title>
    <link href="/2024/07/05/leetcode-day40/"/>
    <url>/2024/07/05/leetcode-day40/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.acwing.com/problem/content/3/">完全背包</a></li><li><a href="https://leetcode.cn/problems/coin-change-ii/">518.零钱兑换Ⅱ</a> <span class="label label-warning">medium</span></li><li><a href="">377. 组合总和Ⅳ</a> <span class="label label-warning">medium</span></li></ul><h1 id="完全背包">完全背包</h1><p><strong>题目：</strong></p><p>有<span class="math inline">\(N\)</span>种物品和一个容量是<spanclass="math inline">\(V\)</span>的背包，每种物品都有无限件可用。</p><p>第<span class="math inline">\(i\)</span>种物品的体积是<spanclass="math inline">\(v_i\)</span>，价值是<spanclass="math inline">\(w_i\)</span>。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><p><strong>输入格式：</strong></p><p>第一行两个整数，<span class="math inline">\(N\)</span>，<spanclass="math inline">\(V\)</span>，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有<span class="math inline">\(N\)</span>行，每行两个整数<spanclass="math inline">\(v_i\)</span>,<spanclass="math inline">\(w_i\)</span>，用空格隔开，分别表示第<spanclass="math inline">\(i\)</span>种物品的体积和价值。</p><p><strong>输出格式:</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p><span class="math inline">\(0&lt;N,V≤1000\)</span></p><p><span class="math inline">\(0&lt;v_i,w_i≤1000\)</span></p><p><strong>思路：</strong></p><p>相对于01背包，物品数量不受限制，可以多次放入，那么就要改动容量倒序遍历，容量倒序遍历原本目的是为了防止多次放入，但现在可以多次放入，不能防止，所以改为顺序遍历，其他不变。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(N)</span>, <span class="hljs-title">w</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i] ;<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i];j &lt;= V;j++) &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[V] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="零钱兑换ⅱ">518. 零钱兑换Ⅱ</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数<code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回<code>0</code> 。</p><p>假设每一种面额的硬币有无限个。</p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>思路：</strong></p><p>硬币无限+凑总金额，很容易看出使用完全背包。题目所求硬币组合数，和昨天的<ahref="https://leetcode.cn/problems/target-sum/">目标和</a>很像，核心代码都是<code>dp[j] += dp[j - nums[i]]</code>，照着样子套就行。</p><p>carl强调：要注意遍历的顺序，首先完全背包遍历背包容量时要顺序遍历以实现多次拿取，其次要先遍历物品再遍历背包容量，不然就会求成排列数而非组合数：</p><ul><li>先物品后容量 ==&gt; 组合数</li><li>先容量后物品 ==&gt; 排列数</li></ul><p>可自推dp数组画图</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-type">int</span> N = coins.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = coins[i];j &lt;= amount;j++) &#123;<br>                dp[j] += dp[j - coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="组合总和ⅳ">377. 组合总和Ⅳ</h1><p><strong>题目：</strong></p><p>给你一个由<strong>不同</strong> 整数组成的数组 <code>nums</code>，和一个目标整数 <code>target</code> 。请你从 <code>nums</code>中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。 <div class="note note-light">            <p><strong>示例 1：</strong></p><p><strong>输入：</strong>nums = [1,2,3], target = 4</p><p><strong>输出：</strong>7</p><p><strong>解释：</strong></p><p>所有可能的组合为：</p><p>(1, 1, 1, 1)</p><p>(1, 1, 2)</p><p>(1, 2, 1)</p><p>(1, 3)</p><p>(2, 1, 1)</p><p>(2, 2)</p><p>(3, 1)</p><p>请注意，顺序不同的序列被视作不同的组合。</p>          </div></p><p><strong>思路：</strong></p><p>有上一道题的经验，安排这题作为下一题非常合适，直接当场体会遍历顺序对结果的影响。</p><p>这道题所求组合个数，但却又在示例中说明顺序不同的序列视作不同组合，与通用概念存在矛盾。不过总之是求通用概念的排列数，先遍历容量再遍历物品即可。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= target;j++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; j) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> dp[j] += dp[j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day38</title>
    <link href="/2024/07/05/leetcode-day38/"/>
    <url>/2024/07/05/leetcode-day38/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/last-stone-weight-ii/description/">1049.最后一块石头的重量Ⅱ</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/ones-and-zeroes/description/">474.一和零</a> <span class="label label-warning">medium</span></li></ul><h1 id="最后一块石头的重量">1049. 最后一块石头的重量</h1><p><strong>题目：</strong></p><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中<code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为<code>x</code> 和 <code>y</code>，且<code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code>的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为<code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头<strong>最小的可能重量</strong> 。如果没有石头剩下，就返回<code>0</code>。</p><p><strong>思路：</strong></p><p><del>一次周赛的Q4，很有档次啊</del></p><p>今天的三道题都是这种类型的题目，01背包的情景应用，我把这种类型概括为“分堆儿”。</p><p>这道题有点难走到“分堆儿”的思路上，卡住我的是这个思想：</p><div class="note note-light">            <p>石块两两粉碎，把所有石头分成两堆，每次分别拿出一块来对碰粉碎，实际上<strong>一次粉碎过程，两堆都损失了相同的重量</strong>。</p>          </div><p>理解到这一点，就能想到将石块分成<strong>尽可能相近的两堆</strong>，其差值就是<strong>最小可能重量</strong>。那问题就变成了昨天的分割等和了，一下就能套上01背包问题</p><ul><li>包容量就是总和sum的一半(两堆尽量相近)</li><li>物品数量就是石头数量，物品价值和体积都是石头重量</li><li>把包装满就是最大重量为sum/2限制下能得到的最重子堆<code>dp[sum/2]</code></li><li>另一堆就是<code>sum - dp[sum/2]</code>，两堆相减即可，可以相减的原因就是上面所说，也可以详见<ahref="https://leetcode.cn/problems/last-stone-weight-ii/solutions/817930/zui-hou-yi-kuai-shi-tou-de-zhong-liang-i-95p9/">力扣官解的前言证明</a></li></ul><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : stones) sum += i;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; stones.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = dp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;j &gt;= stones[i];j--) &#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);<span class="hljs-comment">//套路</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - dp[sum/<span class="hljs-number">2</span>] - dp[sum/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="目标和">494. 目标和</h1><p><strong>题目：</strong></p><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code>。</p><p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code>，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加<code>'+'</code> ，在 <code>1</code> 之前添加<code>'-'</code>，然后串联起来得到表达式 <code>"+2-1"</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同<strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [1,1,1,1,1], target = 3</p><p>输出：5</p><p>解释：一共有 5 种方法让最终目标和为 3 。</p><ul><li>-1 + 1 + 1 + 1 + 1 = 3</li><li>+1 - 1 + 1 + 1 + 1 = 3</li><li>+1 + 1 - 1 + 1 + 1 = 3</li><li>+1 + 1 + 1 - 1 + 1 = 3</li><li>+1 + 1 + 1 + 1 - 1 = 3</li></ul></blockquote><p><strong>思路：</strong></p><p>这题就已经明示要“分堆儿”了，将nums分为正数部分和负数部分，使正数加负数等于target。</p><p>由于01背包求的是<strong>最大价值</strong>，和这里的<strong>最多种类数</strong>不一样，所以不能直接套，得改dp的含义。</p><p>dp[j] 代表总和为j的包有dp[j]种装法</p><p>那么状态转移方程为：</p><p><span class="math display">\[dp[j] =\begin{cases}1, &amp; \text{$j = 0$} \\dp[j], &amp; \text{$j &lt; nums[i]$} \\dp[j] + dp[j - nums[i]], &amp; \text{$else$}\end{cases}\]</span></p><p>dp[0] = 1的原因： 由于会涉及到<code>dp[j - nums[i]]</code>，如果j正好等于nums[i]，那么只能直接装入，只有一种方法。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) sum += i;<br>        <span class="hljs-type">int</span> V = sum + target;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(V % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        V /= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(V &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> N = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">// </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = dp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;j &gt;= nums[i];j--) &#123;<br>                dp[j] += dp[j - nums[i]];<br>            &#125;   <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[V];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="一和零">474. 一和零</h1><p><strong>题目：</strong></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p><strong>思路：</strong></p><p>让选个子集出来，情景已经很贴近01背包模板了，只是背包体积同时有两个维度的限制：0的个数和 1的个数</p><p>那判断两次能不能装下不就好了，多加一个循环。</p><p>这里的物品价值就是串的个数，因为最后看的是长度，所以在状态转移那里是加一。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> N = strs.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">//dp[i][j]表示容量为m个0和n个1的包最多装多少个</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>      <span class="hljs-type">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : strs[i]) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;0&#x27;</span>) zeroNum++;<br>        <span class="hljs-keyword">else</span> oneNum++;<br>      &#125;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j &gt;= zeroNum;j--) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = n;k &gt;= oneNum;k--) &#123;<br>          dp[j][k] = <span class="hljs-built_in">max</span>(dp[j][k], dp[j - zeroNum][k - oneNum] + <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day37</title>
    <link href="/2024/07/04/leetcode-day37/"/>
    <url>/2024/07/04/leetcode-day37/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">01背包问题二维</a></li><li><ahref="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">01背包问题一维</a></li><li><ahref="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416.分割等和子集</a> <span class="label label-warning">medium</span></li></ul><h1 id="背包问题">01背包问题</h1><p><strong>题目：</strong></p><p>有<span class="math inline">\(N\)</span>件物品和一个容量是<spanclass="math inline">\(V\)</span>的背包。每件物品只能使用一次。</p><p>第<span class="math inline">\(i\)</span>件物品的体积是<spanclass="math inline">\(v_i\)</span>，价值是<spanclass="math inline">\(w_i\)</span>。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，<span class="math inline">\(N\)</span>，<spanclass="math inline">\(V\)</span>，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有<span class="math inline">\(N\)</span>行，每行两个整数 <spanclass="math inline">\(v_i\)</span>,<spanclass="math inline">\(w_i\)</span>，用空格隔开，分别表示第<spanclass="math inline">\(i\)</span>件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p><span class="math inline">\(0&lt;N,V≤1000\)</span></p><p><span class="math inline">\(0&lt;vi,wi≤1000\)</span></p><p><strong>思路：</strong></p><p><strong>二维基础版：</strong></p><p>dp[i][j]表示从0-i号物品选，背包容量为j，能装的最大价值。</p><p>对于第i件物品</p><ul><li>若容量不够（<spanclass="math inline">\(j&lt;w[i]\)</span>），则dp[i][j] = dp[i -1][j]，继承价值</li><li>若容量足够：<ul><li>放入后价值为dp[i - 1][j - v[i]] + w[i]</li><li>不放入价值为dp[i - 1][j]，取其中最大值。</li></ul></li></ul><p>可得状态转移方程为：</p><p><span class="math display">\[dp[i][j] =\begin{cases}0, &amp; \text {$j=0$} \\w[i], &amp; \text{$i=0$} \\max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]), &amp; \text{$else$}\end{cases}\]</span></p><p><strong>一维优化版：</strong></p><p>由于只需要最终状态，利用滚动数组优化空间</p><p>dp[j]表示背包容量为j时能装的最大价值</p><div class="note note-warning">            <p>对于j的遍历，即枚举背包容量时需要逆序。</p><p>当进入下一层容量枚举时，新增了物品i，而此时的dp还是对于物品i-1的状态，如果顺序枚举，则枚举到中间就会用到之前的状态，但此时之前的状态已经包含了物品i，会造成重复装入，相当于把dp[i- 1][j - v[i]]用成了dp[i][j - v[i]]。</p>          </div><h2 id="代码">代码</h2><h3 id="二维版">二维版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(V + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[<span class="hljs-number">0</span>];j &lt; V;j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = w[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= V;j++) &#123;<br>            <span class="hljs-keyword">if</span>(j &lt; v[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[N<span class="hljs-number">-1</span>][V] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一维版">一维版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V + <span class="hljs-number">1</span>)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = V;j &gt;= v[i];j--) &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[V] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化输入版">优化输入版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> f[MAXN];  <span class="hljs-comment">// </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;   <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> v, w;<br>        cin &gt;&gt; v &gt;&gt; w;      <span class="hljs-comment">// 边输入边处理</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v; j--)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);<br>    &#125;<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>来源：<a href="https://www.acwing.com/solution/content/1374/">AcWing2. 01背包问题（状态转移方程讲解）</a></p><h1 id="分割等和子集">416. 分割等和子集</h1><p><strong>题目：</strong></p><p>给你一个<strong>只包含正整数</strong>的<strong>非空</strong>数组<code>nums</code>。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>思路：</strong></p><p>提前告诉了要用01背包，不然还看不出来是01背包。</p><p>套用的关键在于搞清楚在当前场景下，物品价值w[i]、物品体积v[i]、背包容量V、物品数量N分别代表什么。</p><p>容易想到要从nums中找到一组数使其和为总和的一半，所以考虑总和的一半作为背包容量，nums中的数的值作为物品的体积</p><p>关于为什么物品的价值也是nums中数的值没想明白，下面是目前的解释，对于价值的解释好像偷换概念了：</p><blockquote><p>由于最后要知道背包到底装满没，所以至少得算到dp[sum/2]，也就是容量为sum/2的包里最多能装多少“价值”，，此时并不知道这个“价值”是不是sum/2,也可能比sum/2小，比如1、5、5、11当容量为6时dp[6]=dp[5]=5，所以得判断dp[j]是不是sum/2，所以dp里的值得是数值。</p></blockquote><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) sum += i;<br><br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        sum /= <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">40001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = sum;j &gt;= nums[i];j--) &#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[sum] == sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day36</title>
    <link href="/2024/07/03/leetcode-day36/"/>
    <url>/2024/07/03/leetcode-day36/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/unique-paths/description/">62.不同路径</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/unique-paths-ii/">63.不同路径Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/integer-break/description/">343.整数拆分</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/unique-binary-search-trees/description/">96.不同的二叉搜索树</a> <span class="label label-warning">medium</span></li></ul><h1 id="不同路径">62. 不同路径</h1><p><strong>题目：</strong></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start”）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>思路：</strong></p><p>由于方向定死只能朝着目标走，不允许走回头路，所以走到一个格子只可能从其左边或上面来到，那么这就不难直接想出递推公式：</p><p><span class="math display">\[dp[i][j] =\begin{cases}1, &amp; \text {$i = 1 or j = 1$} \\dp[i - 1][j] + dp[i][j - 1], &amp; \text {else}\end{cases}\]</span> dp[i][j]表示从起点走到第[i, j]格的所有路径数</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="不同路径ⅱ">63. 不同路径Ⅱ</h1><p><strong>题目：</strong></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start”）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>其实思路差不多，由于笔者追求尽可能少的改动，只加了一行代码就想过关，结果被特殊用例坑了两发WA😭，怎么障碍物会出现在起点和终点啊，落地成盒+通天河老鼋是吧🤡</p>          </div><p>仍然动态规划，只是状态转移方程要改一下，应该遍历整个地图，如果发现障碍物，就把这一格的dp置零表示此路不通，由于笔者代码有点问题，所以还另有改动，在地图边缘的格子不能无脑置1，得继承上一格数值，防止跳过了障碍物。</p><p>carl的代码也有类似思想</p><h2 id="代码-1">代码</h2><h3 id="个人代码">个人代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>(), n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> || obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">1</span>) dp[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) dp[i][j] = i == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="官解代码">官解代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = obstacleGrid.<span class="hljs-built_in">size</span>(), m = obstacleGrid.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>).<span class="hljs-built_in">size</span>();<br>        vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">f</span>(m);<span class="hljs-comment">//压缩了dp数组</span><br><br>        f[<span class="hljs-number">0</span>] = (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>);<span class="hljs-comment">//起点能不能走</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//遇障置零</span><br>                    f[j] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//非首列</span><br>                    f[j] += f[j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>利用滚动数组压缩空间，滚动数组就是上一篇只用3个变量来压缩整个dp数组的思想，抛弃掉之前不用的状态，只获取最终状态，这里也一样，从上到下的路径是继承的，而从左到右的路径是累加的。而外层大循环就是改变行，每行都会继承上一行的结果。</p><h1 id="整数拆分">343. 整数拆分</h1><p><strong>题目：</strong></p><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2），并使这些整数的乘积最大化。</p><p>返回 你可以获得的最大乘积 。</p><p><strong>思路：</strong></p><p>本来该用dp的，但是数学直觉给我指了另一条路，高中学过基本不等式，有口诀为“和定积最大，积定和最小”，而此处就是“和定”，由基本不等式最值条件可知，每个数应该尽量相等（尽量是因为得是整数，不然必须相等），而拆分的数量简单一推就知道先增后减：</p><p>比如12：</p><ul><li>分为2个数：<span class="math inline">\(6*6=36\)</span></li><li>分为3个数：<span class="math inline">\(4 * 4 * 4 = 64\)</span></li><li>分为4个数：<span class="math inline">\(3^4=81\)</span></li><li>分为5个数：<span class="math inline">\(2 * 2 * 2 * 3 * 3 =72\)</span></li><li>分为6个数：<span class="math inline">\(2^6=64\)</span></li></ul><p>先增后减，所以从2开始一直增加拆分数，一旦积开始减少，就说明到达最值点了。</p><p><del>官解的数学证明好复杂，看起来很抽象啊，导数大题只得了6分的我看不懂，还是不等式选修秒杀更舒服</del></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//和定积最大，基本不等式定调均分</span><br>    <span class="hljs-comment">//随便举几个例子可大致知道k先增后减，存在峰值</span><br>    <span class="hljs-comment">//但均分不好实现，如10分为2233或2224，均分应该使方差最小</span><br>    <span class="hljs-comment">//逐步除法也许可以实现最均分，尝试一下</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>;k &lt;= n;k++) &#123;<span class="hljs-comment">//等分数量</span><br>            <span class="hljs-type">int</span> m = n, temp = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k;i &gt; <span class="hljs-number">0</span>;i--) &#123;<span class="hljs-comment">//已经获得的加子数量</span><br>                temp *= m / i;<br>                m -= m / i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(temp &gt; ans) ans = temp;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>均分方法蒙对了，没严格证明，至少能AC</p><h1 id="不同的二叉搜索树">96. 不同的二叉搜索树</h1><p><strong>题目：</strong></p><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>思路：</strong></p><p>有点多项式定理的感觉，<del>沉睡的高中数学之魂复燃？</del>，画图可能比较好理解，但是图书馆要闭馆了，没时间画图了。</p><p>根据其示例可以得到提示：以不同的数做根来分类讨论，以4为例</p><ul><li>若1作根，则剩余3个数形成的BST个数就是当前BST的个数总数，由示例得到为5</li><li>若2作根，则剩余2个数3、4只能在右子树，当前BST总数就是2节点BST的总数2</li><li>若3作根，则4只能在右子树，左子树是2节点BST总数2</li><li>若4作根，则1、2、3都在左子树，就是3节点BST总数，5</li></ul><p>所以4节点BST总数为5+2+2+5。</p><p>由此发散，联想多项式定理，可得状态转移方程：</p><p><span class="math display">\[dp[i] =\begin{cases}1, &amp; \text {$i = 0 or i = 1$} \\\sum_{root=1}^i (dp[root-1]*dp[i-root]), &amp; \text {$i &gt; 1$}\end{cases}\]</span></p><p>dp[i] 代表有i个节点的BST种数;</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++) &#123;<span class="hljs-comment">//节点数</span><br>            <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;root &lt;= i;root++) &#123;<span class="hljs-comment">//谁做根</span><br>                temp += dp[root - <span class="hljs-number">1</span>] * dp[i - root];<br>            &#125;<br>            dp[i] = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day35</title>
    <link href="/2024/07/03/leetcode-day35/"/>
    <url>/2024/07/03/leetcode-day35/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/fibonacci-number/">509.斐波那契数</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/climbing-stairs/description/">70.爬楼梯</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">746.使用最小花费爬楼梯</a> <span class="label label-success">easy</span></li></ul><h1 id="斐波那契数">509. 斐波那契数</h1><p><strong>题目：</strong></p><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code>表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由<code>0</code> 和 <code>1</code>开始，后面的每一项数字都是前面两项数字的和。也就是：</p><blockquote><p>F(0) = 0，F(1) = 1</p><p>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p></blockquote><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>思路：</strong></p><p>由于是dp训练，所以不能直接递归或套公式。</p><p>递推公式题目有，直接dp，没有优化空间复杂度。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="爬楼梯">70. 爬楼梯</h1><p><strong>题目：</strong></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>思路：</strong></p><ol type="1"><li>只有45个数，打表🤓</li><li>直接dp！</li><li>套斐波那契公式🤓</li></ol><p>dp递归公式如下：</p><p><span class="math display">\[dp[n]=\begin{cases}1, &amp; \text {$n=1$} \\2, &amp; \text {$n=2$} \\dp[n-1]+dp[n-2], &amp; \text {$n&gt;3$}\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="使用最小花费爬楼梯">746. 使用最小花费爬楼梯</h1><p><strong>题目：</strong></p><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>思路：</strong></p><p>直接dp！递推公式如下：</p><p><span class="math display">\[dp[n]=\begin{cases}0, &amp; \text {$n = 1 or 0$} \\min(dp[n-1]+cost[n-1], dp[n-2]+cost[n-2]), &amp; \text {$n&gt;1$}\end{cases}\]</span></p><p>没有优化空间复杂度，感觉可有可无，优化也不复杂，具体优化方法见<ahref="https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html">代码随想录| 使用最小花费爬楼梯</a></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(cost.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(cost[<span class="hljs-number">0</span>], cost[<span class="hljs-number">1</span>]);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size() + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= cost.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[cost.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day34</title>
    <link href="/2024/07/01/leetcode-day34/"/>
    <url>/2024/07/01/leetcode-day34/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/merge-intervals/description/">56.合并区间</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/monotone-increasing-digits/">738.单调递增的数字</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/binary-tree-cameras">968.监控二叉树</a> <span class="label label-danger">hard</span></li></ul><h1 id="合并区间">56. 合并区间</h1><p><strong>题目：</strong></p><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] =[starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p><strong>思路：</strong></p><p>与昨天的重叠区间类型问题一样，按开始点排序，有重合就合并，没重合就新维护</p><div class="note note-light">            <p>忽然诧异怎么这道题显示已解决，查看提交记录发现这道题在几个月前做过，当初WA4发才做出来结果击败5%，真是感慨</p><p>回首向来萧瑟处，也无风雨也无晴，虽然一直感觉在蹉跎人生，但实际上我还是有一点小小的进步，加油共勉！</p>          </div><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; b )</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> left = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], right = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; intervals.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt; right) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;left, right&#125;);<br>                left = intervals[i][<span class="hljs-number">0</span>];<br>                right = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>            right = <span class="hljs-built_in">max</span>(right, intervals[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;left, right&#125;);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="单调递增的数字">738. 单调递增的数字</h1><p><strong>题目：</strong></p><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y时，我们称这个整数是单调递增的。</p><p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>没做出来，做的时候脑子有点不舒服，所以歇逼了</p>          </div><p>此题局部最优策略为，如果数字本身就满足“单调递增”要求，则直接返回该数字即可，若出现反例，即高位大于低位，则将高位减1低位置9</p><p>将此局部最优策略应用至全局即可得到最优解，具体代码实现方式见注释。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>&#123;<br>        string strNum = <span class="hljs-built_in">to_string</span>(N);<br>        <span class="hljs-type">int</span> flag = strNum.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// flag用来标记赋值9从哪里开始</span><br>        <span class="hljs-comment">// 设置为超限默认值，为了防止第二个for循环在flag没有被赋值的情况下执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = strNum.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-comment">//倒序遍历数位，若连续出现高位大于低位，则连续减一高位并记录计划变为9的位数</span><br>            <span class="hljs-keyword">if</span> (strNum[i - <span class="hljs-number">1</span>] &gt; strNum[i] ) &#123;<span class="hljs-comment">//如果出现高位大于低位，则将高位减1，同时记录低位位数为flag</span><br>                flag = i;<br>                strNum[i - <span class="hljs-number">1</span>]--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = flag; i &lt; strNum.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-comment">//由于从后往前，所以最后得到的计划变9位将是最高的，把后面所有数变9只会增大数字从而得到最优解</span><br>            strNum[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span>(strNum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="监控二叉树">968. 监控二叉树</h1><p><strong>题目：</strong></p><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象</strong>。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>思路：</strong></p><p><del>不会做😭，抄了</del></p><p>由于涉及二叉树，可以套路化地想到尝试递归遍历，题目所求最少摄像头数量，最少一般是贪心或者dp，那就得分析状态，考虑局部最优全局最优或者状态之间的转移。</p><p>在这道题中，一个节点的状态有三种：放了摄像头+被覆盖+没覆盖，关于二叉树的状态容易联想到从两个子树的状态得到当前root树的状态，那么又可以想到：如果子树的根left或者right有摄像头+仅仅被覆盖+没被覆盖这三种状态，这三种状态转移到整个树的状态的方式就为：1. 如果left或right有一个没被覆盖，则root需要放置摄像头； 2.如果left或者right有一个有摄像头，则root不需要放置； 3.如果left和right都只是被覆盖，那么root需要补一个摄像头。</p><p>但这并没有取最优化，仅仅只是状态转移，所以不是dp。</p><p>dp做法官方题解和灵神的不太一样，树形dp没看懂，dp做法以后再看吧。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//0:无覆盖，1：有摄像头，2：有覆盖</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) &#123;<br>            result++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) result++;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day33</title>
    <link href="/2024/07/01/leetcode-day33/"/>
    <url>/2024/07/01/leetcode-day33/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452.用最少数量的箭引爆气球</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/non-overlapping-intervals/description/">435.无重叠区间</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/partition-labels/description/">763.划分字母区间</a> <span class="label label-warning">medium</span></li></ul><h1 id="用最少数量的箭引爆气球">452. 用最少数量的箭引爆气球</h1><p><strong>题目：</strong></p><p>有一些球形气球贴在一堵用 XY平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中 $points[i] =[x_{start}, x_{end}] $ 表示水平直径在 <spanclass="math inline">\(x_{start}\)</span> 和<spanclass="math inline">\(x_{end}\)</span>之间的气球。你不知道气球的确切 y坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x处射出一支箭，若有一个气球的直径的开始和结束坐标为<spanclass="math inline">\(x_{start}\)</span>，<spanclass="math inline">\(x_{end}\)</span>， 且满足 <spanclass="math inline">\(x_{start} ≤ x ≤ x_{end}\)</span>，则该气球会被引爆 。可以射出的弓箭的数量 没有限制 。弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p><p><strong>思路：</strong></p><p>按照直观思维，肯定要找重叠部分，再按贪心分析，局部最优是射重叠部分，全局最优是尽可能多射重叠部分来减少箭数</p><p>此时不妨画个图来分析，脑子好也可以直接想象，用线段表示气球直径范围，以下图为例，很容易看出答案是两根箭，但是我们是如何得出答案的呢，背后的依赖逻辑是什么</p><figure><img src="https://s3.bmp.ovh/imgs/2024/07/01/7513d5db99cbc545.png"alt="帮助分析线段图" /><figcaption aria-hidden="true">帮助分析线段图</figcaption></figure><p>此时发散思维，不难想到跟开始和结束点有关，此前做过类似题则更容易想到，以结束点为标准，从左往右开始射，必须照顾到最早结束的气球，否则就会漏掉，那么我们就能得到如下贪心策略：（大白话版）</p><p>按起点排序，记录气球结束点按最近的来，若结束点超过了这个最近结束点，则一支箭就不够了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//按起点排序，记录气球结束点按最近的来，若结束点超过了这个最近结束点，则一支箭就不够了</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> end = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> nextBallon = <span class="hljs-number">0</span>;<span class="hljs-comment">//新的起点</span><br>        <span class="hljs-type">int</span> arrow = <span class="hljs-number">1</span>;<span class="hljs-comment">//箭数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; points.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(end &lt; points[i][<span class="hljs-number">0</span>]) &#123;<br>                nextBallon = i;<br>                arrow++;<br>                end = points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>            end = <span class="hljs-built_in">min</span>(end, points[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arrow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="无重叠区间">435. 无重叠区间</h1><p><strong>题目：</strong></p><p>给定一个区间的集合 intervals ，其中 intervals[i] = [start_i, end_i]。返回需要移除区间的最小数量，使剩余区间互不重叠 。</p><p><strong>思路：</strong></p><p>由于之前做过一道安排活动的题目，大概意思就是有很多活动(区间)，请在不重叠的前提下安排尽可能多的活动。与此题很像</p><p>安排活动题就是按结束时间从早到晚排序，先安排早的，这样就有局部最优：留出更多的时间给之后的活动，如果结束时间相同，则为了多，选择更短的活动，以留出更多时间给更早的活动</p><p>那么这道题也可以迁移这个策略，移除最少就是保留最多嘛。</p><p>这道题比较经典，carl给了很多思路，建议阅读：<ahref="https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 无重叠区间</a></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] == b[<span class="hljs-number">1</span>] ? a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>] : a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">//移除最少那就保留最多，移除长的，保留短的</span><br>    <span class="hljs-comment">//保留最多就要流出足够多的时间给后面的区间，所以结束时间要早</span><br>    <span class="hljs-comment">//那么应该按结束时间排序，如果结束相同，那么选择开始时间最晚的</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> save = <span class="hljs-number">1</span>;<span class="hljs-comment">//保留的活动数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; intervals.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &lt; end) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                save++;<br>                end = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - save;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="划分字母区间">763. 划分字母区间</h1><p><strong>题目：</strong></p><p>给你一个字符串 s。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是s 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><p><strong>思路：</strong></p><p>一开始有点懵，然后迁移之前的思路想到可以将字母出现的范围视作区间，那就又成了区间不重叠问题。</p><p>但这个思路编码有点复杂，速度也不快</p><p>carl的直截了当思路简直优雅👍:</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20201222191924417.png"alt="太巧妙辣！" /><figcaption aria-hidden="true">太巧妙辣！</figcaption></figure><h2 id="代码-2">代码</h2><h3 id="个人14代码">个人14%代码😭</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//尽可能多的片段，且是分割，是连续的，只在前面出现的字母，统计各字母首次和默次出现构成区间</span><br>    <span class="hljs-comment">//按区间开始排序，目的是分出尽可能多的组，原理相同</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; points;<span class="hljs-comment">//存各字母的区间</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-comment">//获取s中各字母的区间</span><br>        points = <span class="hljs-built_in">getSection</span>(s);<br>        <span class="hljs-comment">//写代码能力太弱，有点费时间啊……</span><br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> right = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; points.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; right) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>                left = points[i][<span class="hljs-number">0</span>];<br>            &#125;<br>            right = <span class="hljs-built_in">max</span>(right, points[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">getSection</span>(string s) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">alpha</span>(<span class="hljs-number">26</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>));<span class="hljs-comment">//全部字母都留出空</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(alpha[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">-1</span>) alpha[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>] = i;<span class="hljs-comment">//起点只记一次</span><br>            alpha[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>] = i;<span class="hljs-comment">//终点不断更新</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; alpha.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(alpha[i][<span class="hljs-number">0</span>] != <span class="hljs-number">-1</span>) res.<span class="hljs-built_in">push_back</span>(alpha[i]);<span class="hljs-comment">//结果只记录出现过的</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl优雅代码">carl优雅代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        <span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// i为字符，hash[i]为字符出现的最后位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 统计每一个字符最后出现的位置</span><br>            hash[S[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            right = <span class="hljs-built_in">max</span>(right, hash[S[i] - <span class="hljs-string">&#x27;a&#x27;</span>]); <span class="hljs-comment">// 找到字符出现的最远边界</span><br>            <span class="hljs-keyword">if</span> (i == right) &#123;<br>                result.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day31</title>
    <link href="/2024/06/30/leetcode-day31/"/>
    <url>/2024/06/30/leetcode-day31/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/gas-station/description/">134.加油站</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/candy/description/">135.分发糖果</a> <span class="label label-danger">hard</span></li><li><ahref="https://leetcode.cn/problems/lemonade-change/description/">860.柠檬水找零</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406.根据身高重建队列</a> <span class="label label-warning">medium</span></li></ul><h1 id="加油站">134. 加油站</h1><p><strong>题目：</strong></p><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1个加油站需要消耗汽油 cost[i]升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 gas 和 cost，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。如果存在解，则 保证 它是 唯一 的。</p><p><strong>思路：</strong></p><p>贪心算法是从局部最优一直推到整体最优，那么对于解从起点开始的每一小段，肯定油都是有剩的，即<spanclass="math inline">\(∑gas[i] - ∑cost[i] &gt;0\)</span>，如果有一段内的油少于需要，则肯定不是解从开头的段</p><p>开一个数组<span class="math inline">\(loss[]\)</span>表示<spanclass="math inline">\(loss[i] = gas[i] -cost[i]\)</span>，肯定从正数开始，如果加到中间变负了，证明从开始到这里都不行，换下一站做起点，不断搜索即可。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">loss</span><span class="hljs-params">((<span class="hljs-type">int</span>)gas.size())</span></span>;<br>        <span class="hljs-type">int</span> sumg = <span class="hljs-number">0</span>, sumc = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; gas.<span class="hljs-built_in">size</span>();i++) &#123;<br>            loss[i] = gas[i] - cost[i];<br>            sumg += gas[i];<br>            sumc += cost[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sumg &lt; sumc) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//油不够，直接-1</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; loss.<span class="hljs-built_in">size</span>()) &#123;<br>            sum += loss[i++];<br>            <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>) &#123;<br>                sum = <span class="hljs-number">0</span>;<br>                ans = i;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i == ans) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//回到起点</span><br>            <span class="hljs-keyword">if</span>(ans &gt; <span class="hljs-number">0</span> &amp;&amp; i == loss.<span class="hljs-built_in">size</span>()) i = <span class="hljs-number">0</span>;<span class="hljs-comment">//循环，注意起点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="分发糖果">135. 分发糖果</h1><p><strong>题目：</strong></p><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><p><strong>思路：</strong></p><p>个人击败5%思路：</p><ul><li>如果相比上一个更大，则糖果比上一个人多一个，这没得说</li><li>如果相比上一个相同，则先置为1，后续再操作</li><li>如果更小，此时需要往前维护糖果大小关系，细节见代码</li></ul><p>carl思路：</p><p>两次遍历，分别维护两种相邻情况的糖果大小关系，顺序维护递增的加一关系，倒序维护递减的关系，巧妙啊</p><h2 id="代码-1">代码</h2><h3 id="个人5代码">个人5%代码😭</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//需要注意的就是1234321这种例子，不能想当然按照两格滑动窗口解题，也不能左右同时走</span><br>    <span class="hljs-comment">//往前，如果比前一个小，则置位1，同时维护之前的大小关系，直到遇到下降</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candys</span><span class="hljs-params">(ratings.size())</span></span>;<br>        candys[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; ratings.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candys[i] = candys[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ratings[i] == ratings[i - <span class="hljs-number">1</span>]) candys[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ratings[i] &lt; ratings[i - <span class="hljs-number">1</span>]) &#123;<br>                candys[i] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(candys[i - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)  &#123;<span class="hljs-comment">//维护先前的大小关系，必须倒着加回去</span><br>                <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>) &#123;<br>                    candys[j]++;<br>                    <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; candys[j] &lt; candys[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; ratings[j] &gt;= ratings[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span>;<br>                    j--;<br>                &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; candys.<span class="hljs-built_in">size</span>();i++) sum += candys[i];<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl代码">carl代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candyVec</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 从前向后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candyVec[i] = candyVec[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从后向前</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] ) &#123;<br>                candyVec[i] = <span class="hljs-built_in">max</span>(candyVec[i], candyVec[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 统计结果</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candyVec.<span class="hljs-built_in">size</span>(); i++) result += candyVec[i];<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="柠檬水找零">860. 柠檬水找零</h1><p><strong>题目：</strong></p><p>在柠檬水摊上，每一杯柠檬水的售价为 5美元。顾客排队购买你的产品，（按账单 bills支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 bills ，其中 bills[i] 是第 i位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false。</p><p><strong>思路：</strong></p><p>很简单，记住5块有多少，10块有多少，遇到10块补5块，遇到20优先给出10块，没有10块就全给5块，中间给不出就false，能找完就true</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>&#123;<br>        <span class="hljs-type">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : bills) &#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">5</span>) five++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">10</span>) ten++, five--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ten == <span class="hljs-number">0</span>) five -= <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">else</span> ten--, five--;<br>            <span class="hljs-keyword">if</span>(ten &lt; <span class="hljs-number">0</span> || five &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="根据身高重建队列">406. 根据身高重建队列</h1><p><strong>题目：</strong></p><p>假设有打乱顺序的一群人站成一个队列，数组 people表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第i 个人的身高为 hi ，前面 <strong>正好</strong> 有 ki 个身高大于或等于 hi的人。</p><p>请你重新构造并返回输入数组 people所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj,kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p><strong>思路：</strong></p><p>有两个标准，不难想到应该先用身高排序，由高到低，其中相同身高的k由低到高，因为这样才能更便捷地调换位置，满足k的需要。</p><p>然后按照k来插入即可。注意使用list，底层由链表实现，插入效率较高，这题对于语法要求还有点高，得多熟悉这些不那么常用的API。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; p1, vector&lt;<span class="hljs-type">int</span>&gt; &amp; p2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> p1[<span class="hljs-number">0</span>] == p2[<span class="hljs-number">0</span>] ? p1[<span class="hljs-number">1</span>] &lt; p2[<span class="hljs-number">1</span>] : p1[<span class="hljs-number">0</span>] &gt; p2[<span class="hljs-number">0</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que; <span class="hljs-comment">// list底层是链表实现，插入效率比vector高的多</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 插入到下标为position的位置</span><br>            std::list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = que.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">while</span> (position--) &#123;<br>                it++;<br>            &#125;<br>            que.<span class="hljs-built_in">insert</span>(it, people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(que.<span class="hljs-built_in">begin</span>(), que.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day30</title>
    <link href="/2024/06/22/leetcode-day30/"/>
    <url>/2024/06/22/leetcode-day30/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/jump-game/description/">55.跳跃游戏</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/jump-game-ii/description/">45.跳跃游戏II</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/">1005.K次取反后最大化的数组和</a> <span class="label label-success">easy</span></li></ul><h1 id="买卖股票的最佳时机ii">122. 买卖股票的最佳时机II</h1><p><strong>题目：</strong></p><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><p><strong>思路：</strong></p><p>披着medium皮的easy题，统计所有上升就好了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) res += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="跳跃游戏">55. 跳跃游戏</h1><p><strong>题目：</strong></p><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回false 。</p><p><strong>思路：</strong></p><p>从终点倒着走，不断找能跳到当前的点，并将其更新为新的终点，如果最后终点来到了0，就找到了，反之则没有</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> end = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//4</span><br>        <span class="hljs-type">int</span> newend = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;<span class="hljs-comment">//3</span><br>        <span class="hljs-keyword">while</span>(newend &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(end - newend &gt; nums[newend]) newend--;<br>            <span class="hljs-keyword">else</span> &#123;<br>                end = newend;<br>                newend--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(end == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="跳跃游戏ii">45.跳跃游戏II</h1><p><strong>题目：</strong></p><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p><p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><ul><li>0 &lt;= j &lt;= nums[i]</li><li>i + j &lt; n</li></ul><p>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n -1]。</p><p><strong>思路：</strong></p><p>贪心就是贪个最远能到达的距离，当前在一个地方，这个地方前面有一个范围，范围呢每个点又有范围，找的就是有最远范围的下一个点。</p><p>写得感觉有点冗余，过用例的时候错一个改一条，突然就AC了，没细察。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> current = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(current &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> currentMaxRange = current + nums[current];<br>            <span class="hljs-keyword">if</span>(currentMaxRange &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> nextStepMaxRange = currentMaxRange;<br>            <span class="hljs-type">int</span> nextStep = current;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = current + <span class="hljs-number">1</span>;i &lt;= currentMaxRange;i++) &#123;<br>                <span class="hljs-keyword">if</span>(nextStepMaxRange &lt; i + nums[i]) &#123;<br>                    nextStepMaxRange = i + nums[i];<br>                    nextStep = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nextStepMaxRange &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans + <span class="hljs-number">2</span>;<br>            current = nextStep;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="k次取反后最大化的数组和">1005.K次取反后最大化的数组和</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p><ul><li>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。</li></ul><p>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p><p>以这种方式修改数组后，返回数组 可能的最大和 。</p><p><strong>思路：</strong></p><p>见<ahref="https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html">代码随想录</a></p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp);       <span class="hljs-comment">// 第一步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 第二步</span><br>            <span class="hljs-keyword">if</span> (A[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>) &#123;<br>                A[i] *= <span class="hljs-number">-1</span>;<br>                K--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) A[A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>; <span class="hljs-comment">// 第三步</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) result += a;        <span class="hljs-comment">// 第四步</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day29</title>
    <link href="/2024/06/21/leetcode-day29/"/>
    <url>/2024/06/21/leetcode-day29/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/assign-cookies/description/">455.分发饼干</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/wiggle-subsequence/description/">376.摆动序列</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/maximum-subarray/description/">53.最大子数组和</a> <span class="label label-warning">medium</span></li></ul><h1 id="分发饼干">455. 分发饼干</h1><p><strong>题目：</strong></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j分配给孩子 i，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>思路：</strong></p><p>见<ahref="https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 分发饼干</a></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123;<br>                result++;<br>                index--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="摆动序列">376. 摆动序列</h1><p><strong>题目：</strong></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7,3) 是正负交替出现的。</p><p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5]不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度。</p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 1000</li><li>0 &lt;= nums[i] &lt;= 1000</li></ul><p><strong>思路：</strong></p><p>符号转换一次就记一次数。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sign = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(nums[i] - nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                sign = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                sign = <span class="hljs-number">0</span>;<br>            &#125;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最大子数组和">53. 最大子数组和</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><p><strong>思路：</strong></p><p>见<ahref="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 最大子数组和</a></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = INT_MIN;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            sum += nums[i];<br>            res = <span class="hljs-built_in">max</span>(res, sum);<br>            <span class="hljs-keyword">if</span>(sum &lt;= <span class="hljs-number">0</span>) sum = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day28</title>
    <link href="/2024/06/19/leetcode-day28/"/>
    <url>/2024/06/19/leetcode-day28/</url>
    
    <content type="html"><![CDATA[<p>期末复习压力大，简单写写，暑假再补</p><p>(已补)</p><p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/non-decreasing-subsequences/description/">491.非递减子序列</a> <span class="label label-warning">medium</span><br /></li><li><a href="https://leetcode.cn/problems/permutations/description/">46.全排列</a> <span class="label label-warning">medium</span><br /></li><li><ahref="https://leetcode.cn/problems/permutations-ii/description/">47.全排列Ⅱ</a> <span class="label label-warning">medium</span><br /></li><li><ahref="https://leetcode.cn/problems/reconstruct-itinerary/description/">332.重新安排行程</a> <span class="label label-danger">hard</span><br /></li><li><a href="https://leetcode.cn/problems/n-queens/description/">51.N皇后</a><span class="label label-danger">hard</span><br /></li><li><ahref="https://leetcode.cn/problems/sudoku-solver/description/">37.解数独</a><span class="label label-danger">hard</span></li></ul><h1 id="非递减子序列">491. 非递减子序列</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素。你可以按 任意顺序 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>思路：</strong></p><p>难点在于去重，例如[1,2,3,1,1]这样的用例，就要注意不要在解空间树第一层重复取1，最后得到重复的[1,1]和[1,1,1]，解空间树单层去重方法为在单层递归中创建一个作用域仅限于单层递归函数内的记录变量数组，用过就记录，之后再用就跳过，具体代码实现方法见下</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">-101</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; nums, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(<span class="hljs-number">210</span>, <span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">//这就是作用域仅在单层的记录变量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; pre) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[nums[i] + <span class="hljs-number">100</span>]) <span class="hljs-keyword">continue</span>;<br>            used[nums[i] + <span class="hljs-number">100</span>] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            pre = nums[i];<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            pre = !temp.<span class="hljs-built_in">empty</span>() ? temp.<span class="hljs-built_in">back</span>() : <span class="hljs-number">-101</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="全排列">46. 全排列</h1><p><strong>题目：</strong></p><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以按任意顺序 返回答案。</p><p><strong>思路：</strong></p><p>在程序设计课上写那么久，之前一直踩坑全局used，这下终于能尽情全局used了，手速题，10min秒了</p><p>carl哥的方法明明和我一样，只是把used下传了，但就是快，也许是语法因素？</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(used[i]) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        used.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">backtrack</span>(nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="全排列ⅱ">47. 全排列Ⅱ</h1><p><strong>题目：</strong></p><p>给定一个可包含重复数字的序列 nums ，按任意顺序返回所有不重复的全排列。</p><p><strong>思路：</strong></p><p>又是去重，由于任意顺序，所以可以排序，对于[1,1,2]这样的用例，需要注意的就是不要来两个[1,1,2]，光把前两个1交换了。</p><p>去重标准可设为：相同元素仅允许最先一个作为开头，之后的相同元素不可做开头，但可做后缀。</p><p>翻译成代码就是<code>if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue;</code></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[i]) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        used.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">backtrack</span>(nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="重新安排行程">332. 重新安排行程</h1><p><strong>题目：</strong></p><p>给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi]表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><p>所有这些机票都属于一个从JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p><p>例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。假定所有机票至少存在一种合理的行程。且<strong>所有的机票 必须都用一次 且只能用一次</strong>。</p><p><strong>思路：</strong></p><p>首先看懂题目，类似哥尼斯堡七桥问题，也就是欧拉回路，就是要找到一条路，能把所有路走一遍且不重复，而此题还额外要求字典序最小。</p><p>那么可以直观得到如下思路：</p><ol type="1"><li>找到当前节点能够去到的 所有 下一个节点，按字典序由小到大排好序</li><li>从最小字典序节点开始dfs，如果最后没能用光机票而走入死路，则换次小字典序节点继续寻找，直到找到。</li></ol><p>思路其实不难，主要在于代码实现，carl合理选择了适当的容器来做，代码时间打败98%，但我这次独立完成，主要记录个人解题思路，目前最优解仍为carl的题解，详见：<ahref="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E6%80%9D%E8%B7%AF">代码随想录| 重新安排行程</a>。</p><p>对于我的思路，具体代码实现遇到的问题见代码注释，直接叙述效果不佳</p><h2 id="代码-3">代码</h2><h3 id="个人代码可怜的5">个人代码（可怜的5%😭）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<span class="hljs-comment">//存欧拉道路</span><br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<span class="hljs-comment">//记录哪些tickets的下标已经被用过，即用过的机票</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt; &amp;tickets, string start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == tickets.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//根据start得到接下来的目标，选取可用的机票，按字典序从小到大排列</span><br>        <span class="hljs-comment">//按下标存方便used记录，按名称存不好记录哪些机票用过了，后续会出问题，于是两个合在一起存，排序自定义</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, string&gt;&gt; nextPort;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; tickets.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(!used[i] &amp;&amp; tickets[i][<span class="hljs-number">0</span>] == start) &#123;<br>                nextPort.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, string&gt;(i, tickets[i][<span class="hljs-number">1</span>]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nextPort.<span class="hljs-built_in">begin</span>(), nextPort.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-comment">//遍历接下来的机场，如果找到答案，则直接返回，如果没有，则换次小字典序机场再找</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nextPort.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(used[nextPort[i].first]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//超时尝试剪枝，对于相同机票，可失败后跳过后续所有相同机票</span><br>            <span class="hljs-comment">//剪枝后成功AC，但用时仅超过5%，丢人</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nextPort[i].second == nextPort[i - <span class="hljs-number">1</span>].second) <span class="hljs-keyword">continue</span>;<br>            used[nextPort[i].first] = <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nextPort[i].second);<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtrack</span>(tickets, nextPort[i].second)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            used[nextPort[i].first] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果走到这一步，证明走错，返回false</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, string&gt; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, string&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.second.<span class="hljs-built_in">compare</span>(b.second) &lt; <span class="hljs-number">0</span>;<span class="hljs-comment">//按照字典序排序</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        used.<span class="hljs-built_in">resize</span>(tickets.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<span class="hljs-comment">//记录哪些机票已经被用过</span><br>        path.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<span class="hljs-comment">//起点不会被加入，所以提前加入</span><br>        <span class="hljs-built_in">backtrack</span>(tickets, <span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl的优质代码个人注释版">carl的优质代码个人注释版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//才注意到carl哥把自己实现的方法都private了，细节！</span><br><span class="hljs-comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span><br>unordered_map&lt;string, map&lt;string, <span class="hljs-type">int</span>&gt;&gt; targets;<span class="hljs-comment">// 起点 -&gt; (目的地，剩余可飞次数)</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == ticketNum + <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//找齐了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//回传成功信号，也算剪枝了吧，不用再遍历后续的target了</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (pair&lt;<span class="hljs-type">const</span> string, <span class="hljs-type">int</span>&gt;&amp; target : targets[result[result.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]]) &#123;<span class="hljs-comment">//细节引用，result[result.size() - 1]就是前一个机场，targets[result[result.size() - 1]]就是要遍历的目的地集合</span><br>        <span class="hljs-keyword">if</span> (target.second &gt; <span class="hljs-number">0</span> ) &#123; <span class="hljs-comment">// 该路线还有余票</span><br>            result.<span class="hljs-built_in">push_back</span>(target.first);<span class="hljs-comment">//回溯模板，看不懂只能去复习了</span><br>            target.second--;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(ticketNum, result)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            result.<span class="hljs-built_in">pop_back</span>();<br>            target.second++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        targets.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//细节clear，防止内存里有脏东西</span><br>        vector&lt;string&gt; result;<span class="hljs-comment">//没开成员变量，提高速度，见 全排列的疑惑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;string&gt;&amp; vec : tickets) &#123;<span class="hljs-comment">//vec就是每张票了，俩元素，起点[0]跟终点[1]</span><br>            targets[vec[<span class="hljs-number">0</span>]][vec[<span class="hljs-number">1</span>]]++; <span class="hljs-comment">// 这里就提前给每个目的地集合按字典序排好序了，之后从头遍历就行</span><br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>); <span class="hljs-comment">// 手动加入起始机场</span><br>        <span class="hljs-built_in">backtracking</span>(tickets.<span class="hljs-built_in">size</span>(), result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="n皇后">51. N皇后</h1><p><strong>题目：</strong></p><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code>个皇后放置在 <code>n×n</code>的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong>的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code>分别代表了皇后和空位。</p><p>提示：</p><p><code>1 &lt;= n &lt;= 9</code></p><p><strong>思路：</strong></p><p>按图的深度优先搜索回溯查找所有放置可能，结束条件就是放到了最后一行仍然合法，放一个就在当前基础上往下搜索，写好判断合法函数，注意有两条斜线，经典问题所以不太难，披着hard的中等题吧。</p><h2 id="代码-4">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<span class="hljs-comment">//存放所有解</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, vector&lt;string&gt; &amp;board)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(row == n) &#123;<span class="hljs-comment">//最后一行放下去了，来到了界外</span><br>            ans.<span class="hljs-built_in">push_back</span>(board);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isVaild</span>(n, row, i, board)) <span class="hljs-keyword">continue</span>;<br>            board[row][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            <span class="hljs-built_in">backtrack</span>(n, row + <span class="hljs-number">1</span>, board);<br>            board[row][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">//尝试下一个放置位</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isVaild</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, vector&lt;string&gt; &amp;board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r &lt; n;r++) &#123;<span class="hljs-comment">//检测[row, col]有无同列Queen</span><br>            <span class="hljs-keyword">if</span>(board[r][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> r = row, c = col;<br>        <span class="hljs-keyword">while</span>(r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//检测左上斜线有无Queen</span><br>            <span class="hljs-keyword">if</span>(board[r--][c--] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        r = row, c = col;<br>        <span class="hljs-keyword">while</span>(r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; n) &#123;<span class="hljs-comment">//检测右上斜线有无Queen</span><br>            <span class="hljs-keyword">if</span>(board[r--][c++] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">board</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        <span class="hljs-built_in">backtrack</span>(n, <span class="hljs-number">0</span>, board);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="解数独">37. 解数独</h1><p><strong>题目：</strong></p><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 遵循如下规则：</p><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3宫内只能出现一次。（请参考示例图）</li></ul><p>数独部分空格内已填入了数字，空白格用 '.' 表示。</p><p>示例一：</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/202011171912586.png"alt="示例一" /><figcaption aria-hidden="true">示例一</figcaption></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],<br><br>[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],<br><br>[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br><br>输出：[[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>],<br><br>[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>],<br><br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>],<br><br>[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],<br><br>[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],<br><br>[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],<br><br>[<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>],<br><br>[<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],<br><br>[<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br><br>解释：输入的数独如上图所示，唯一有效的解决方案如下所示：<br></code></pre></td></tr></table></figure><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20201117191340669.png"alt="answer" /><figcaption aria-hidden="true">answer</figcaption></figure><p>图源：<ahref="https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p><p><strong>思路：</strong></p><div class="note note-light">            <p>没写出来，想着用n皇后的思路一个一个回溯暴力填的，结果一堆bug😭</p><p>记录一下错误思路：在回溯函数里我传入了上一个被填位置的row和col，想着每次向下递归就能知道上次在哪里，结果会出现：一行填到最后一个没法填了，退回去清空倒数第二格后再跳过把最后一格填了，留着空格子不管直接下一行……</p><p>问题出在返回false的时机上，其实到没法填的时候就已经可以返回false了，然后会到上一格接着试下一个数字。</p>          </div><p>这道题回溯没有单独设置终止条件，如果有传参的话也许可以加一条到了8行9列就返回，不过也可以不加，循环跑完自然就会结束。</p><h2 id="代码-5">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//先行再列，逐个试错</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r &lt; <span class="hljs-number">9</span>;r++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">9</span>;i++) &#123;<span class="hljs-comment">//先填满row行</span><br>                <span class="hljs-keyword">if</span>(board[r][i] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">9</span>;j++) &#123;<span class="hljs-comment">//为(r, i)尝试所有可能数字</span><br>                    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isValid</span>(board, r, i, j)) <span class="hljs-keyword">continue</span>;<br>                    board[r][i] = <span class="hljs-string">&#x27;0&#x27;</span> + j;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtrack</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    board[r][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//没得填了，返回false</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp; board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;c &lt; <span class="hljs-number">9</span>;c++) <span class="hljs-keyword">if</span>(board[row][c] == <span class="hljs-string">&#x27;0&#x27;</span> + num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r &lt; <span class="hljs-number">9</span>;r++) <span class="hljs-keyword">if</span>(board[r][col] == <span class="hljs-string">&#x27;0&#x27;</span> + num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = row / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;r &lt; (row / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)*<span class="hljs-number">3</span>;r++) &#123;<span class="hljs-comment">//宫格</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c = col / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;c &lt; (col / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)*<span class="hljs-number">3</span>;c++) &#123;<br>                <span class="hljs-keyword">if</span>(board[r][c] == <span class="hljs-string">&#x27;0&#x27;</span> + num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">backtrack</span>(board);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day27</title>
    <link href="/2024/06/18/leetcode-day27/"/>
    <url>/2024/06/18/leetcode-day27/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/restore-ip-addresses/description/">93.复原IP地址</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/subsets/description/">78.子集</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集Ⅱ</a><span class="label label-warning">medium</span></li></ul><h1 id="复原ip地址">93. 复原IP地址</h1><p><strong>题目：</strong></p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255之间组成，且不能含有前导 0），整数之间用 '.' 分隔。</p><p>例如："0.1.2.201" 和 "192.168.1.1" 是 <strong>有效</strong> IP地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是<strong>无效</strong> IP 地址。 给定一个只包含数字的字符串 s，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP地址</strong>，这些地址可以通过在 s 中插入 '.' 来形成。你<strong>不能</strong> 重新排序或删除 s 中的任何数字。你可以按<strong>任何</strong> 顺序返回答案。</p><p><strong>思路：</strong></p><p>回溯做了几天，对于简单的解空间树怎么分支比较熟悉了，这题就先按长度从1到3分割，然后下传起点，如果第四段仍然合法，则找到一个答案，不断递归回溯寻找所有答案即可。</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933.png"alt="解空间树.图源：代码随想录" /><figcaption aria-hidden="true">解空间树.图源：<ahref="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E6%80%9D%E8%B7%AF">代码随想录</a></figcaption></figure><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    string temp;<br>    <span class="hljs-type">int</span> seg = <span class="hljs-number">4</span>;<span class="hljs-comment">//剩余段数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(seg &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(seg == <span class="hljs-number">0</span> &amp;&amp; begin &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() - i &gt; seg * <span class="hljs-number">3</span> &amp;&amp; i - begin &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//后续太多，直接剪枝\提前判断位数剪枝</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, begin, i)) &#123;<br>                <span class="hljs-keyword">if</span>(begin &gt; <span class="hljs-number">0</span>) temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                temp += <span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + begin, s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>                seg--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">backtrack</span>(s, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span>(!temp.<span class="hljs-built_in">empty</span>() &amp;&amp; temp.<span class="hljs-built_in">back</span>() != <span class="hljs-string">&#x27;.&#x27;</span>) temp.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">if</span>(!temp.<span class="hljs-built_in">empty</span>()) temp.<span class="hljs-built_in">pop_back</span>();<br>            seg++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &lt; end &amp;&amp; s[begin] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(begin &lt;= end) &#123;<br>            num *= <span class="hljs-number">10</span>;<br>            num += s[begin++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= num &amp;&amp; num &lt;= <span class="hljs-number">255</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">backtrack</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="子集">78. 子集</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> ，数组中的元素<strong>互不相同</strong>。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 <strong>任意顺序</strong>返回解集。</p><p><strong>思路：</strong></p><p>也是很容易套上模板的回溯，不过<strong>不能不求甚解依赖模板</strong>，还是要想清楚代码逻辑。这题是求子集，高中就学过n个元素的集合有2^n个子集，虽然跟这没啥关系，不过可以认识到求子集就是求元素个数从0~n的关于全集nums的组合，所以可以分别求长度为i，i从0到n，的组合，那就是从nums里抓i个的组合，就变成了该题的上一题：<ahref="https://leetcode.cn/problems/combinations/">77. 组合</a>了。</p><div class="note note-light">            <p>对于错误思路的反思：</p><p>注意到该题的tag里有<strong>位运算</strong>字样，昨天做错的题目里我也尝试使用位运算模拟<code>bool used[]</code>来记录哪些数字已经被使用过，但实际上是多余的。今天又看见位运算，由于其出现在tag里，所以深信不疑，再次尝试，WA，去掉后，AC。下面逐条分析错误核心，搞清楚什么时候用used记录用过，什么时候不用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<span class="hljs-comment">//此处i从begin开始，已经与之前的结果隔开</span><br>    <span class="hljs-keyword">if</span>(used &gt;&gt; nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//这句等同于：如果nums[i]在之前用过就跳过，但此题nums中无重复元素，所以之前出现的元素之后肯定没出现过，多余</span><br>    used |= <span class="hljs-number">1</span> &lt;&lt; nums[i];<span class="hljs-comment">//在used的第nums[i]位置一</span><br>    temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>, len);<br>    temp.<span class="hljs-built_in">pop_back</span>();<br>    used &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; nums[i]);<span class="hljs-comment">//第nums[i]位复位</span><br>&#125;<br></code></pre></td></tr></table></figure><p>看完发现，used的确多余，但好像没有影响啊，其实WA原因在于<code>used &gt;&gt; nums[i] % 2</code>，%运算符优先级高于&gt;&gt;，所以错了。</p><p>当然，改了还是会错，nums里有负数，这样就越来越复杂了。</p>          </div><h2 id="代码-1">代码</h2><p><strong>第一版</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == len) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>, len);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= nums.<span class="hljs-built_in">size</span>();i++) &#123;<br><br>            <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>, i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p><strong>carl的解</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(temp);<span class="hljs-comment">//提前</span><br>        <span class="hljs-keyword">if</span>(begin &gt;= nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="子集ⅱ">90. 子集Ⅱ</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums，其中可能包含<strong>重复元素</strong>，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按<strong>任意顺序</strong> 排列。</p><p><strong>思路：</strong></p><p>与上一题相比多了重复元素，相当于[1,2,2]的子集注意别回溯出两个[1,2]，可以采用昨天<ahref="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">40.组合总和</a>的相同去重思路。在昨天的blog中已经提到不能简单用used来尝试去重。所以还是乖乖用carl的写法，附图carl的解空间树：</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000918.png"alt="子集Ⅱ解空间树,图源：代码随想录 | 子集Ⅱ" /><figcaption aria-hidden="true">子集Ⅱ解空间树,图源：<ahref="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF">代码随想录| 子集Ⅱ</a></figcaption></figure><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(temp);<br>        <span class="hljs-keyword">if</span>(begin &gt;= nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-comment">//使用这条的前提是要排序哦，不然相同的不挨在一起就麻烦了</span><br>            <span class="hljs-keyword">if</span>(i &gt; begin &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day26</title>
    <link href="/2024/06/17/leetcode-day26/"/>
    <url>/2024/06/17/leetcode-day26/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/combination-sum/description/">39.组合总和</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/combination-sum-ii/description/">40.组合总和Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/palindrome-partitioning/description/">131.分割回文串</a> <span class="label label-warning">medium</span></li></ul><h1 id="组合总和">39. 组合总和</h1><p><strong>题目：</strong></p><p>给你一个<strong>无重复元素</strong>的整数数组 <code>candidates</code>和一个目标整数 <code>target</code> ，找出 <code>candidates</code>中可以使数字和为目标数 <code>target</code> 的 所有<strong>不同组合</strong> ，并以列表形式返回。你可以按<strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以<strong>无限制重复被选取</strong>。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于<code>150</code> 个。</p><p><strong>思路：</strong></p><p>递归挨个选取就行，选了一个之后递归下一个，起点不变，如果和到了target就加入答案，可以在下一步递归前判断当前值是否已经过大了，过大则跳过实现剪枝。比较简单</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidate, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; candidate.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(candidate[i] &gt; target) <span class="hljs-keyword">continue</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(candidate[i]);<br>            <span class="hljs-built_in">backtrack</span>(candidate, target - candidate[i], i);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-keyword">if</span>(candidates.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">backtrack</span>(candidates, target, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="组合总和ⅱ">40. 组合总和Ⅱ</h1><p><strong>题目：</strong></p><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数<code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为<code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用<strong>一次</strong> 。</p><p><strong>注意</strong>：解集不能包含重复的组合。</p><p><strong>提示:</strong></p><p><code>1 &lt;= candidates.length &lt;= 100</code></p><p><code>1 &lt;= candidates[i] &lt;= 50</code></p><p><code>1 &lt;= target &lt;= 30</code></p><p><strong>思路：</strong></p><p>难点主要在于去重，下面举个例子来快速直观体会这道题要去什么重</p><p>对于示例：<code>[10,1,1,7,6,1,5]</code>、<code>target = 8</code>，正确结果应该是<code>[[1,1,1,5],[1,1,6],[1,7]]</code>。题目中<strong>candidate中的每个数字只能用一次</strong>是关键，勿错误理解为每种数字只能用一次，示例<code>[10,1,1,7,6,1,5]</code>中有3个<code>1</code>，当<strong>选中第一个<code>1</code>作为解成员之一</strong>递归下去的时候，由于之前无1，所以已有的解中肯定无1，后面的两个<code>1</code>仍然可用，由答案可见，选中第一个<code>1</code>递归下去已经可以得到全部解了。</p><p>那么<strong>选中第二个<code>1</code>作为解成员之一</strong>递归下去后，后面还有一个<code>1</code>，此时<strong>含有两个<code>1</code>的解</strong>已经出现过了，此时需要去重。</p><p>由上可看出不能简单使用used来阻止使用使用过的下标，因为第一个1把所有解得到后，回溯取消操作会开放used，后面的1又会变得可用，去重失败</p><p>carl哥的代码思路按我理解可以叙述为：<span class="label label-danger">重复元素只能由排前面的重复元素使用</span>，对于上面的示例，就是含有多个1的解只能由第一个1的递归分支得到，后面的如果还是1就不能在解里出现1。</p><p><strong>排前面的重复</strong>即对应carl哥说法的<strong>前一个树枝</strong>，即前一个重复元素的解空间树分支。</p><div class="note note-light">            <p>又瞟了题解才做出来，WA了4发😭😭😭</p><p>脑子抽了没看见<code>1 &lt;= candidates.length &lt;= 100</code>，还乐呵呵地用位运算当used[]用来记录哪些下标被用了，左移右移老半天跟二傻子似的，结果不仅位运算爆longlong，而且用used记录本身就是脱裤子放屁，因为我回溯传了起点begin……</p>          </div><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidate, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; candidate.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(candidate[i] &gt; target) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(i &gt; begin &amp;&amp; candidate[i] == candidate[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//去重关键</span><br>            temp.<span class="hljs-built_in">push_back</span>(candidate[i]);<br>            <span class="hljs-built_in">backtrack</span>(candidate, target - candidate[i], i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-keyword">if</span>(candidates.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtrack</span>(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="分割回文串">131. 分割回文串</h1><p><strong>题目：</strong></p><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回s 所有可能的分割方案。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>没做出来，贴出失败思路：</p><p>分割子串，想到之前做的有关题目了，至少分割操作还是比较熟悉，用迭代器构造新串就好，从首开始分割，分割长度逐渐递增，也就是回溯中的那个for循环，每个分割长度在分割前判断是否是回文串，如果是回文串就分割，不是就接着增大分割长度。</p><p>然后就卡了……没记住或者说想另辟蹊径结果弄巧成拙，没有像模板那样接着回溯下一种可能并取消当前轮次操作继续for循环。</p>          </div><p>接下来是正确思路：</p><p>仍然按照回溯模板，理清递归思路： 1. 递归参数与返回值： 返回值void，参数应该是分割起点，确保能够递归下去接着分割之后的子串 2.递归终止条件，如果真的分割到结尾，那么该条递归调用路线就是正确的，此时temp中即为一个答案，标准就是起点超过了终点，begin大于了string的长度3. 递归操作：逐个尝试分割长度，合法就接着分割，不合法就跳过</p><p>carl哥这次画的解空间树很形象，如下图，失败思路想到了怎么分支，但是没想到怎么判断叶节点，具体的代码写法也写昏了头</p><figure><img src="https://s3.bmp.ovh/imgs/2024/06/17/788a44e4b04795dd.png"alt="解空间树" /><figcaption aria-hidden="true">解空间树</figcaption></figure><h2 id="代码-2">代码</h2><h3 id="一般代码">一般代码</h3><p>之所以叫一般，是因为判断回文串的函数<code>isValid</code>每次调用都要俩指针相向而行，有很多重复操作，提高了时间复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;string&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = begin, right = end;<br>        <span class="hljs-keyword">if</span>(right &gt; s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span>(s[left++] != s[right--]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, begin, i)) &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + begin, s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>));<br>                <span class="hljs-built_in">backtrack</span>(s, i + <span class="hljs-number">1</span>);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-built_in">backtrack</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="动态规划代码">动态规划代码</h3><p>使用动态规划（dynamic programming，DP）直接把所有子串是否是回文串都提前算好，这样后续判断时就只需要O(1)复杂度就可以了</p><p>动态规划状态转移方程为： <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">           ⌜<span class="hljs-number">1</span>, <span class="hljs-selector-tag">i</span> = j <br><br>dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> = +s<span class="hljs-selector-attr">[i]</span>==s<span class="hljs-selector-attr">[j]</span>, <span class="hljs-selector-tag">i</span> = j - <span class="hljs-number">1</span><br><br>           ㇗s<span class="hljs-selector-attr">[i]</span>==s<span class="hljs-selector-attr">[j]</span>ANDdp<span class="hljs-selector-attr">[i+1]</span><span class="hljs-selector-attr">[j-1]</span>,<span class="hljs-keyword">else</span><br></code></pre></td></tr></table></figure><del>不会打latex，好拉的公式，快去配置渲染器！！</del></p><p>(更新：现在会打公式了，留着当耻辱柱😁，提升观感，公式如下) <spanclass="math display">\[dp[i][j]\ =\begin{cases}1,&amp; \text{$i=j$} \\s[i]==s[j],&amp; \text{$i=j-1$} \\s[i] == s[j]\ \and\ dp[i+1][j-1],&amp; \text{$else$}\end{cases}\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;string&gt; temp;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; dp;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(dp[begin][i]) &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + begin, s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>));<br>                <span class="hljs-built_in">backtrack</span>(s, i + <span class="hljs-number">1</span>);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string &amp;s)</span> </span>&#123;<br>        dp.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<span class="hljs-comment">//vector还得resize了才能用</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; s.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> == j) dp[i][j] = s[i] == s[j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == j) dp[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-built_in">isValid</span>(s);<br>        <span class="hljs-built_in">backtrack</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day24</title>
    <link href="/2024/06/15/leetcode-day24/"/>
    <url>/2024/06/15/leetcode-day24/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><a href="https://leetcode.cn/problems/combinations/">77.组合</a></li><li><ahref="https://leetcode.cn/problems/combination-sum-iii/description/">216.组合总和Ⅲ</a></li><li><ahref="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/">17.电话号码的字母组合</a></li></ul><h1 id="前言">前言</h1><p>进入回溯算法篇章，对递归掌握仍然不熟练，尤其是回溯算法，在左的课上写全排列等题目简直惨不忍睹，趁此机会，再次尝试学会回溯算法，每题务必隔天复习重写熟悉</p><p>卡哥的题解也要仔细看，综合多篇题解学习。</p><blockquote><p><ahref="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">文章讲解</a><br /><a href="https://www.bilibili.com/video/BV1cy4y167mM">视频讲解</a></p></blockquote><h1 id="组合">77. 组合</h1><p><strong>题目：</strong></p><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>思路：</strong></p><p>多重for循环就行，但是由于层数不定，所以不能直接for，需要靠递归来实现任意层数循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;    <span class="hljs-comment">//回溯模板1：总答案</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;           <span class="hljs-comment">//回溯模板2：单个答案暂存</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == k) &#123;  <span class="hljs-comment">//回溯模板3：递归结束条件：遍历到叶子节点</span><br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start;i &lt;= n - k + temp.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(i);  <span class="hljs-comment">//回溯模板4：选择当前，进入下一步</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-comment">//回溯模板5：取消之前操作，回溯</span><br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="组合总和ⅲ">216. 组合总和Ⅲ</h1><p><strong>题目：</strong></p><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em>。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>思路：</strong></p><p>和上一道题很像，卡哥选题还是很有深意的。熟悉模板写法，给出的代码没有剪枝，剪枝写法参见：</p><p><ahref="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">代码随想录| 组合总和iii</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == k) &#123;<br>            <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start;i &lt;= <span class="hljs-number">9</span>;i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(k, n - i, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">backtracking</span>(k, n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="电话号码的字母组合">17. 电话号码的字母组合</h1><p><strong>题目：</strong></p><p>给定一个仅包含数字 2-9的字符串，返回所有它能表示的字母组合。答案可以按<strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1不对应任何字母。</p><p><strong>思路：</strong></p><p>仍然是不定次数for循环，使用递归来解，同样，剪枝写法参见<ahref="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">代码随想录| 电话号码的字母组合</a></p><p>注意打表方式，值得学习，自己打表还用的unordered_map，结果打出来一堆bug，还是string数组聪明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    string temp;<br>    <span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = &#123;<br>    <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 0</span><br>    <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 1</span><br>    <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-comment">// 2</span><br>    <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-comment">// 3</span><br>    <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-comment">// 4</span><br>    <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-comment">// 5</span><br>    <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-comment">// 6</span><br>    <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-comment">// 7</span><br>    <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-comment">// 8</span><br>    <span class="hljs-string">&quot;wxyz&quot;</span>, <span class="hljs-comment">// 9</span><br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string digits, <span class="hljs-type">int</span> begin_for_string)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> digit = digits[begin_for_string] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        string letter = letterMap[digit];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; letter.<span class="hljs-built_in">size</span>();i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(letter[i]);<br>            <span class="hljs-built_in">backtracking</span>(digits, begin_for_string + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">backtracking</span>(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day23</title>
    <link href="/2024/06/14/leetcode-day23/"/>
    <url>/2024/06/14/leetcode-day23/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669.修剪二叉搜索树</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108.将有序数组转换为二叉搜索树</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">538.把二叉搜索树转换为累加树</a> <span class="label label-warning">medium</span></li></ul><h1 id="修剪二叉搜索树">669. 修剪二叉搜索树</h1><p><strong>题目：</strong></p><p>给你二叉搜索树的根节点 <code>root</code>，同时给定最小边界<code>low</code> 和最大边界<code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树<strong>不应该</strong> 改变保留在树中的元素的相对结构(即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在<strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>思路：</strong></p><p>根据day22的“删除二叉搜索树的节点”，这题就变成了：删除小于low的节点和大于high的节点，那么同样的做法，制定好分类讨论的规则，然后按规则遍历就好</p><h2 id="可以中序遍历吗">可以中序遍历吗？</h2><p>笔者第一版代码惨遭RE和WA，由于是区间，所以笔者“理所应当”地想要中序遍历先把小的全删了，然后再把大的全删了，看似没有问题，就像操作有序数组一样，但笔者实际写出的代码却是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root) &#123;<span class="hljs-comment">//不为空才操作</span><br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);    <span class="hljs-comment">//先左，中序嘛</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; low) &#123;                           <span class="hljs-comment">//然后中，处理当前节点</span><br>            TreeNode * temp = root;                     <span class="hljs-comment">//如果当前的小了</span><br>            root = root-&gt;right;                         <span class="hljs-comment">//让更大一点的右孩子来补位（雷点所在）</span><br>            <span class="hljs-keyword">delete</span> temp;                                <span class="hljs-comment">//删掉当前的</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; high) &#123;                     <span class="hljs-comment">//同理</span><br>            TreeNode * temp = root;<br>            root = root-&gt;left;                          <span class="hljs-comment">//大了就让更小一点的左孩子来补位</span><br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root) root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<span class="hljs-comment">//最后右</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>RE原因：</strong>这题力扣上似乎有点问题，对于<code>[1, null, 2]</code>这个用例，如果delete掉root，就会报错，但本地写好代码run出来是不会报错的，carl对此的解释是：</p><div class="note note-light">            <p>○ 代码加了内存释放，在运行时出错，<code>[1,null,2]</code>这个输入，本地调试时，没有出错。卡哥的代码没有处理内存问题，难道这题不用自己释放内存？把delete的逻辑移除后，就通过了。手动delete反而会出错</p><p>○解答：因为最终答案是删除了原本的根节点，然后返回节点2作为新的根节点也就是答案，为此做了两个实验：1.把right子树的指赋给原本的root，然后最终返回root，可以通过case；2.把root指向right，然后之前用个tmp指向原本root的内存再删除，这次会报错。而报错的原因是释放的内存再次被使用，所以我猜测是LeetCode的判题机在判题的时候应该再次使用了原本子树根节点的那块内存导致的错误，你可以只删除那个会释放根节点的delete语句，其他的释放语句不去掉，结果还是可以通过的，所以你本地输出答案没有错误那说明就是lc自己的问题了，不用太过于纠结。</p>          </div><p>忽略力扣本身原因，关注上述中序代码的逻辑错误，即</p><p><strong>WA原因：</strong></p><p>对于用例[4, 2, 5, null,3]，如下图所示，若范围为[4,5]，那么应该删除2、3，最后得到一棵4、5的链，但是依照上述代码，当递归到节点<code>2</code>时，会发生：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode * temp = root;           <span class="hljs-comment">//记录节点2</span><br>root = root-&gt;right;               <span class="hljs-comment">//将root-&gt;right赋值给root指针变量，意图让右孩子补位</span><br><span class="hljs-keyword">delete</span> temp;                      <span class="hljs-comment">//删掉节点2</span><br></code></pre></td></tr></table></figure><p>问题就出在第二条，原本计划让right来补位，但是实际操作却仅仅是给一个函数里的形式参数赋了值，相当于<strong>用形参root保留了当前的右儿子</strong>，之后递归处理右儿子right实际却处理了右<strong>孙子</strong>，可能会返回右孙子本身或者null，但是最后却返回了右儿子right，相当于跳过了<code>if(root) root-&gt;right = trimBST(root-&gt;right, low, high);</code>语句，会导致修剪不到位，对于上述用例，就会返回[3,4,5]，本应被删除的节点3被保留了。</p><p>看起来被否定的只是代码编写，而中序遍历这个思路似乎仍具有可行性，实际上，硬要保持左中右的教条中序遍历，也是可以的。</p><p>需要改的地方就是：如果根节点被删除，那么就应该返回 <strong>儿子节点的处理结果</strong>，而不仅仅是儿子节点，修改后的中序遍历如下，由于力扣本身原因，省去delete操作避免RE：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-comment">//规则：</span><br>        <span class="hljs-comment">//1. 当前小，删了让右孩子补位</span><br>        <span class="hljs-comment">//2. 当前大，删了让左孩子补位</span><br>        <span class="hljs-comment">//3. 当前合法，处理左右孩子后返回</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//左</span><br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        <span class="hljs-comment">//中</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; low) <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; high) <br>            <span class="hljs-keyword">return</span> root-&gt;left;<br>        <span class="hljs-keyword">else</span><br>            root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>按照官解做完再看这段修改后的“中序”，其实会发现对比下来就是把<code>root-&gt;left = trimBST(root-&gt;left, low, high);</code>这句给摘出来提前了。</p><p><strong>综上</strong></p><p>对于“可以中序吗？”的问题，我的回答是可以，事实上这道题并不需要关注前中后序怎么遍历，这也引出了笔者的一个思维定势：<strong>二叉树的递归都基于前中后序遍历，迭代都基于层序遍历</strong>。不要局限于前中后序遍历，这只是参考，实际就按递归三部曲来就行</p><p><del>这也许是一直看卡哥的代码却没有仔细思考，光看了个大概长相的缘故。😣</del></p><h2 id="正经解答">正经解答</h2><p>对一个小问题想多了，下面给出优雅的正确答案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>            root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="将有序数组转化为二叉搜索树">108. 将有序数组转化为二叉搜索树</h1><blockquote><p>乍一看，想要走捷径，直接拉个有序链表不也是二叉搜索树？</p></blockquote><blockquote><p>实际上题目要求平衡。。切</p></blockquote><p><strong>题目：</strong></p><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵平衡 二叉搜索树。</p><p><strong>思路：</strong></p><p>由于要平衡，所以对半分就行，这样深度差就得到控制，不会退化成链，有点像快排？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>官解整花活，划线方式给整了三种，实际就是一种方法</p>          </div><h1 id="把二叉搜索树转换为累加树">538. 把二叉搜索树转换为累加树</h1><p><strong>题目：</strong></p><p>给出二叉 <strong>搜索</strong>树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater SumTree），使每个节点 <code>node</code> 的新值等于原树中大于或等于<code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>思路：</strong></p><p>把累加树定义看懂就成，就是把一个节点右边的值（比它大的）全加起来变成这个节点的新值。那不就是从右至左累加么，一个右中左顺序遍历，开个int记录前一个节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        root-&gt;right = <span class="hljs-built_in">convertBST</span>(root-&gt;right);<br>        root-&gt;val += pre;<br>        pre = root-&gt;val;<br>        root-&gt;left = <span class="hljs-built_in">convertBST</span>(root-&gt;left);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><del>少有的直接秒杀还和标准答案一模一样，嘿嘿嘿😆</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day22</title>
    <link href="/2024/06/13/leetcode-day22/"/>
    <url>/2024/06/13/leetcode-day22/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">235.二叉搜索树的最近公共祖先</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701.二叉搜索树的插入操作</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450.删除二叉搜索树中的节点</a><span class="label label-warning">medium</span></li></ul><h1 id="二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先</h1><p>与day21的第三题相比，这题多了二叉搜索树这一条件，变得更简单</p><p><strong>题目：</strong></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>思路</strong></p><p>主体思路就是<strong>当root的值在p和q之间时，root就是最近公共祖先了</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == p || root == q || !root) <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//沿用236题的返回条件</span><br>        <span class="hljs-keyword">if</span>(p-&gt;val &gt; q-&gt;val) &#123;<span class="hljs-comment">//先设定p &lt; q</span><br>            TreeNode * temp = p;<br>            p = q;<br>            q = temp;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//如果root在之间，返回</span><br>        <span class="hljs-keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<span class="hljs-comment">//不然就在左子树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<span class="hljs-comment">//不然就在右子树</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树的插入操作">701. 二叉搜索树的插入操作</h1><p><strong>题目：</strong></p><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。你可以返回 任意有效的结果 。</p><p><strong>思路</strong></p><p>不要拘泥于AVL的标准，这只是普通的二叉搜索树，哪怕退化成链都没关系，所以<strong>直接在最底部插入就行</strong></p><p>然后问题转化为:<strong>在二叉搜索树BST中查找val</strong>。当然肯定找不到，但最后会在某个叶子节点处下行碰到null，那么只需要判断走没走到叶子，以及val该插在叶子的左边还是右边</p><p><del>别想着在中途插入了，本菜比卡了一个小时没写出来，看评论区全是“伪装成medium的easy”😭</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) &#123;<br>            TreeNode * node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除二叉搜索树中的节点">450. 删除二叉搜索树中的节点</h1><p><strong>题目：</strong></p><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ul><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ul><p><strong>思路：</strong></p><p>依然别想着AVL的左右旋什么的，别自己给自己上难度，简单暴力地分类讨论就行：</p><ol type="1"><li>没找到<code>val</code>(<code>root</code>是空的)，返回<code>nullptr</code></li><li>要删的是个叶子，直接删了返回<code>nullptr</code></li><li>要删的节点只有一个孩子，删完孩子上来补位，返回这个独生子</li><li>要删的节点有两个孩子，把左子树接到右子树最左边的节点下面当左孩子（这样可以最简单地使树依然合法）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        <span class="hljs-keyword">if</span>(root-&gt;val == key) &#123;<br>            <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>                TreeNode * temp = root-&gt;left;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right &amp;&amp; !root-&gt;left) &#123;<br>                TreeNode * temp = root-&gt;right;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                TreeNode * keeper = root-&gt;right;<br>                <span class="hljs-keyword">while</span>(keeper-&gt;left != <span class="hljs-literal">nullptr</span>) keeper = keeper-&gt;left;<br>                keeper-&gt;left = root-&gt;left;<br>                TreeNode * temp = root-&gt;right;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day21</title>
    <link href="/2024/06/13/leetcode-day21/"/>
    <url>/2024/06/13/leetcode-day21/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530.二叉搜索树的最小绝对差</a><span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/">501.二叉搜索树中的众数</a><span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236.二叉搜索树的最近公共祖先</a><span class="label label-warning">medium</span></li></ul><h1 id="二叉搜索树的最小绝对差">530. 二叉搜索树的最小绝对差</h1><p><strong>题目：</strong>（仅题干，示例请移步力扣）</p><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回<code>树中任意两不同节点值之间的最小差值</code> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>思路：</strong></p><p>由于是二叉搜索树，时刻牢记<span class="label label-info">中序遍历二叉搜索树相当于遍历有序数组</span>，所以大思路就是中序遍历树，并维护一个最小绝对差</p><p>中序遍历这里采用递归法，递归途中需要记录上一个节点的值以求出两数之差</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> &amp;ans, <span class="hljs-type">int</span> &amp; pre)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root) &#123;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;left, ans, pre);<br>            <span class="hljs-keyword">if</span>(pre == <span class="hljs-number">-1</span>) pre = root-&gt;val;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans = <span class="hljs-built_in">min</span>(ans, root-&gt;val - pre);<br>                pre = root-&gt;val;<br>            &#125;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;right, ans, pre);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = INT_MAX, pre = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">traversal</span>(root, ans, pre);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树中的众数">501. 二叉搜索树中的众数</h1><p><strong>题目：</strong></p><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code>，找出并返回 BST 中的所有<code>众数</code>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <code>小于等于</code> 当前节点的值</li><li>结点右子树中所含节点的值 <code>大于等于</code> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p><strong>思路：</strong></p><p>大思路仍然依靠<span class="label label-info">中序遍历二叉搜索树相当于遍历有序数组</span>，问题转换为求出一个有序数组中的众数，那么在遍历时记录每个数的频率，维护一个最大频率</p><p>若该数最后的频率小于最大频率，则不做操作；等于最大频率，则加入答案中；大于最大频率，则更新最大频率，清空当前答案，并将当前数加入答案</p><p>依然是递归中序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-comment">//答案answer</span><br>    <span class="hljs-type">int</span> max_freq = <span class="hljs-number">0</span>;<span class="hljs-comment">//最大频率</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> &amp;cur, <span class="hljs-type">int</span> &amp;freq)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, cur, freq);<span class="hljs-comment">//中序左</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val == cur) &#123;<span class="hljs-comment">//当前数cur还未遍历完，继续加频率freq</span><br>            freq++;<br>            <span class="hljs-keyword">if</span>(max_freq == freq) &#123;<span class="hljs-comment">//如果已经赶上最大频率，加入答案</span><br>                ans.<span class="hljs-built_in">push_back</span>(cur);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(max_freq &lt; freq) &#123;<span class="hljs-comment">//如果已经超过，更新max，清空答案，重新加入cur作为答案</span><br>                max_freq = freq;<br>                ans.<span class="hljs-built_in">clear</span>();<br>                ans.<span class="hljs-built_in">push_back</span>(cur);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cur = root-&gt;val;<span class="hljs-comment">//当前数cur遍历结束，将cur更新为新的数，频率重置</span><br>            freq = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, cur, freq);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cur = root-&gt;val, freq = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(root, cur, freq);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树的最近公共祖先">236. 二叉搜索树的最近公共祖先</h1><p><strong>题目：</strong></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>思路</strong></p><p>初次尝试越想越复杂，以失败告终，原因是单次递归逻辑和终止条件没想明白，</p><p>按照carl的递归三部曲：</p><ol type="1"><li>确定递归返回值和参数。这一步没问题，就按照力扣给的核心方法的定义就可以，返回公共祖先的指针，参数就是两个节点p、q和根节点</li><li>确定递归终止条件。第一个终止条件想到了：“root等于p或者q时，或者root为空”就返回root。之后就开始混乱了，尝试讨论p、q是root的孩子还是孙子还是更远的孩子，遂失败</li><li>确定单次递归逻辑。失败</li></ol><p>我没有分析出：当递归到<code>最近公共祖先的祖先</code>时，返回值也应该是<code>最近公共祖先</code>，也就是说<code>最近公共祖先</code>是会不断向上传递的，这样就就能保证<code>最近</code>而不会得到深度更浅的公共祖先。</p><p>对于<strong>遍历一条路</strong>还是<strong>遍历整棵树</strong>，carl老师的解释令我耳目一新：</p><div class="note note-light">            <p><strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）。</strong></p><p>搜索一条边的写法： <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">if</span> (递归函数(root-&gt;<span class="hljs-built_in">left</span>)) <span class="hljs-keyword">return</span> ;<br><span class="hljs-keyword">if</span> (递归函数(root-&gt;<span class="hljs-built_in">right</span>)) <span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></table></figure> 搜索整个树写法： <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">left</span> = 递归函数(root-&gt;<span class="hljs-built_in">left</span>);  // 左<br><span class="hljs-built_in">right</span> = 递归函数(root-&gt;<span class="hljs-built_in">right</span>); // 右<br><span class="hljs-built_in">left</span>与<span class="hljs-built_in">right</span>的逻辑处理;         // 中 <br></code></pre></td></tr></table></figure></p>          </div><p>由于返回值确定，所以递归时肯定会有东西接住返回值，又由于，递归的参数是root，返回值也是root，所以当递归root左右孩子时，返回值也应该是左右孩子，即必然会有</p><p><code>left = lowestCommonAncestor(root-&gt;left, p, q);</code></p><p>由于这道题不需要对树进行操作，只需要查找遍历，所以<code>left</code>并不是<code>root-&gt;left</code>，即不需要更新。根据carl的区分，我们可以根据这条语句推断我们之后应该进行left和right的逻辑处理，那么就可以合理推测应该判断left和right是否为空，因为如果没有找到必定返回空，而找到p、q才会返回p或者q，那么如果left和right都返回了，就遇到答案（root）了，向上不断返回即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == p || root == q || root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br><br>        TreeNode * left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode * right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> &amp;&amp; right != <span class="hljs-literal">nullptr</span>) <br>            <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><del>对于想了半小时还WA的我来说，这真是段优雅的代码</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day20</title>
    <link href="/2024/06/11/leetcode-day20/"/>
    <url>/2024/06/11/leetcode-day20/</url>
    
    <content type="html"><![CDATA[<p>今日内容</p><p><ahref="https://leetcode.cn/problems/maximum-binary-tree/description/">●654.最大二叉树</a><br /><ahref="https://leetcode.cn/problems/merge-two-binary-trees/description/">●617.合并二叉树</a><br /><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">●700.二叉搜索树中的搜索</a><br /><ahref="https://leetcode.cn/problems/validate-binary-search-tree/description/">●98.验证二叉搜索树</a></p><h1 id="最大二叉树">最大二叉树</h1><h2 id="一般写法">一般写法</h2><p>题目实际上已经给出了递归逻辑，翻译成代码即可</p><p>给定一个不重复的整数数组<code>nums</code>。<code>最大二叉树</code>可以用下面的算法从<code>nums</code>递归地构建:</p><ol type="1"><li>创建一个根节点，其值为<code>nums</code>中的最大值。</li><li>递归地在最大值<code>左边</code>的<code>子数组前缀上</code>构建左子树。</li><li>递归地在最大值<code>右边</code>的<code>子数组后缀上</code>构建右子树。</li></ol><p>返回<code>nums</code>构建的<code>最大二叉树</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) <br>            <span class="hljs-keyword">if</span>(nums[max] &lt; nums[i]) max = i;<br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[max]);<span class="hljs-comment">// 1创建一个根节点，其值为`nums`中的最大值。</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(nums.begin(), nums.begin() + max)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(nums.begin() + max + <span class="hljs-number">1</span>, nums.end())</span></span>;<br>        root-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(left);<span class="hljs-comment">// 2递归地在最大值`左边`的`子数组前缀上`构建左子树。</span><br>        root-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(right);<span class="hljs-comment">// 3递归地在最大值`右边`的`子数组后缀上`构建右子树。</span><br>        <span class="hljs-keyword">return</span> root;<span class="hljs-comment">// 返回最大二叉树</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="单调栈写法">单调栈写法</h2><p>笔者仅根据题目写出递归写法，未想到单调栈写法，此为<ahref="https://leetcode.cn/problems/maximum-binary-tree/solutions/1759348/zui-da-er-cha-shu-by-leetcode-solution-lbeo/">力扣官方题解</a>启发</p><figure><img src="https://s3.bmp.ovh/imgs/2024/06/11/b6ce26fcf0d47d93.png"alt="总体思想图示" /><figcaption aria-hidden="true">总体思想图示</figcaption></figure><div class="note note-light">            <p>因此，我们的任务变为：找出每一个元素左侧和右侧第一个比它大的元素所在的位置。这就是一个经典的单调栈问题了，可以参考<ahref="https://leetcode.cn/problems/next-greater-element-ii/description/">503.下一个更大元素II</a>。如果左侧的元素较小，那么该元素就是左侧元素的右子节点；如果右侧的元素较小，那么该元素就是右侧元素的左子节点。</p>          </div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;  <span class="hljs-comment">//单调栈</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(len, <span class="hljs-number">-1</span>)</span></span>;  <span class="hljs-comment">//每个节点左侧第一个更大的节点</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(len, <span class="hljs-number">-1</span>)</span></span>;  <span class="hljs-comment">//每个节点右侧第一个更大的节点</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">tree</span><span class="hljs-params">(len)</span></span>;  <span class="hljs-comment">//存储树节点</span><br>        <span class="hljs-comment">//使用单减栈 获取left和right  (题目限制元素是不同的)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            tree[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[i]); <span class="hljs-comment">//构造当前节点</span><br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[stk.<span class="hljs-built_in">top</span>()])&#123;  <span class="hljs-comment">//当前节点比栈中元素大 弹栈并给栈中的小元素赋right</span><br>                right[stk.<span class="hljs-built_in">top</span>()] = i;<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!stk.<span class="hljs-built_in">empty</span>())&#123;  <span class="hljs-comment">//当前节点的左侧更大节点就是单减栈的顶部元素</span><br>                left[i] = stk.<span class="hljs-built_in">top</span>();<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        TreeNode* root = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//将每个节点接到自己的父节点上以构造树形结构</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(left[i] == <span class="hljs-number">-1</span> &amp;&amp; right[i] == <span class="hljs-number">-1</span>)&#123;  <span class="hljs-comment">//当前节点为最大值，其为根</span><br>                root = tree[i];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left[i] == <span class="hljs-number">-1</span> || (right[i] != <span class="hljs-number">-1</span> &amp;&amp; nums[left[i]] &gt; nums[right[i]]))&#123; <br>                tree[right[i]]-&gt;left = tree[i];   <span class="hljs-comment">//左侧没有更大的节点或左侧更大值大于右侧更大值，说明当前节点是右侧更大值的左子树的根节点</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tree[left[i]]-&gt;right = tree[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>该代码中的注释来源于题解评论区<ahref="https://leetcode.cn/u/6ifted-ishi2aka1rd/"><span class="citation"data-cites="健">@健</span></a>，本菜比瞪眼看了十分钟没看懂，抄了，挖坑后面来看</p>          </div><h1 id="合并二叉树">合并二叉树</h1><p>简单递归即可</p><ol type="1"><li>确定返回值和参数：就按力扣给的核心函数递归就行，无需另写函数，返回值就是合并后的节点指针，参数就是要合并的两个节点</li><li>确定递归结束条件：如果一方为空则返回另一方，都不空则相加后返回和节点</li><li>确定递归中途操作：合并当前节点对应的左右孩子</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root1) <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span>(!root2) <span class="hljs-keyword">return</span> root1;<br>        root1-&gt;val += root2-&gt;val;<br>        root1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);<br>        root1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树中的搜索">二叉搜索树中的搜索</h1><p>过于简单，知道什么是二叉搜索树就能做，略</p><h1 id="验证二叉搜索树">验证二叉搜索树</h1><p>示例2就已经给出一个容易犯的陷阱：错误地以为只需要左右节点各比根节点小和大就可以了，实际上二叉搜索树需要整个左右子树都比根节点小和大，所以需要注意在想当然递归的时候不要只比较左右节点，还需注意更上层的节点。</p><p>由于是二叉搜索树，条件比较硬，所以可以充分利用二叉搜索树的特性————利用中序遍历获取序列，然后判断该序列是否单调递增就好，若不单调递增，证明不是二叉搜索树</p><p>二叉排序树左子树-根-右子树严格单调递增，标准地画出一棵二叉排序树，并从上到下作其投影可得到严格序列，该序列即是中序遍历序列，并且该序列单调递增</p><p>附图直观一览</p><figure><img src="https://s3.bmp.ovh/imgs/2024/06/11/8bf9279d365104cd.png"alt="二叉排序树的投影与中序遍历" /><figcaption aria-hidden="true">二叉排序树的投影与中序遍历</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; ans;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root) &#123;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; ans2 = ans;<br>        <span class="hljs-built_in">sort</span>(ans2.<span class="hljs-built_in">begin</span>(), ans2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; ans.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(ans[i] != ans2[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; ans2[i] &lt;= ans2[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day18</title>
    <link href="/2024/06/09/leetcode-day18/"/>
    <url>/2024/06/09/leetcode-day18/</url>
    
    <content type="html"><![CDATA[<p>今日内容</p><ul><li><ahref="https://leetcode.cn/problems/find-bottom-left-tree-value/">513.找树左下角的值</a><br /></li><li><a href="https://leetcode.cn/problems/path-sum/description/">112.路径总和</a></li><li><ahref="https://leetcode.cn/problems/path-sum-ii/">113.路径总和ii</a><br /></li><li><ahref="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106.从中序与后序遍历序列构造二叉树</a><br /></li><li><ahref="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105.从前序与中序遍历序列构造二叉树</a></li></ul><h1 id="找树左下角的值">找树左下角的值</h1><h2 id="递归写法">递归写法</h2><p>递归代表深度优先搜索，所以对于这道题要求的bottom比较好把握，只要维护一个最深深度就行了，对于left，就要在递归逻辑上把握</p><ul><li>当遇到叶子节点，根据深度判断是否维护，注意一定是深度比当前大才维护，不能相等</li><li>当遇到分支节点，先走左再走右</li></ul><p>为什么先走左就能保证最底最左？</p><p>最底可以保证，最左就是第一个遇到，而维护时只维护更深的，就意味着当前答案就是当前深度中第一个遇到的、最左的节点，所以最左也可以保证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; ans = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">findBottomLeftValueHelp</span>(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans.first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findBottomLeftValueHelp</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            <span class="hljs-keyword">if</span>(depth &gt; ans.second) ans = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&#123;root-&gt;val, depth&#125;;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;left) <span class="hljs-built_in">findBottomLeftValueHelp</span>(root-&gt;left, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">findBottomLeftValueHelp</span>(root-&gt;right, depth + <span class="hljs-number">1</span>);<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代写法">迭代写法</h2><p>代表广度优先搜索，或者层序遍历，由于每层从左向右，所以left好把握，对于bottom就要多写点逻辑来把握</p><p>遍历每行时，若遇到叶子节点，则跳过对该层后面节点的判断，仅仅只入队后面节点的子节点，这样就保证了最左。如果队中还有元素，则说明还有更深，继续寻找，最后就会得到答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> ans = root-&gt;val;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>                TreeNode * cur = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                <span class="hljs-keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;<br>                    ans = cur-&gt;val;<br>                    <span class="hljs-keyword">while</span>(++i &lt; size) &#123;<br>                        cur = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                        <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="路径总和">路径总和</h1><p>这题太适合深度优先搜索了，一条路走到头才能判断，那就一条一条走，正符合dfs。</p><p>代码比较简单，注意参数怎么传的，传参步骤减去当前节点值，最后判断是否刚好相等。而非从0加到叶子再判断是否等于target，虽然空间复杂度没变，但是少一个变量更简洁一点</p><p>具体代码不贴，与下一题类似，可同理理解</p><h1 id="路径综合ii">路径综合II</h1><p>仍然是深度优先搜索，只是多了保存答案的步骤，也不难</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">path</span>(root, targetSum, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(), ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">path</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> targetSum, vector&lt;<span class="hljs-type">int</span>&gt; temp, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == targetSum) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        temp.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(root-&gt;left) <span class="hljs-built_in">path</span>(root-&gt;left, targetSum - root-&gt;val, temp, ans);<br>        <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">path</span>(root-&gt;right, targetSum - root-&gt;val, temp, ans);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="从中序和后序构造二叉树">从中序和后序构造二叉树</h1><h2 id="递归写法-1">递归写法</h2><p>经典考题，递归写法核心思想为分割序列为子树的中序和后序，不断分割直到只剩一个，即是叶子节点</p><p>根据后序可以直接确定当前树的根节点，然后在中序中定位左右子树的中序，最后将左右子树的中序和后需继续下传，返回当前根节点</p><p>分割序列采用vector的构造函数，使用迭代器分割</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> size = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> rootval = postorder[size - <span class="hljs-number">1</span>];<br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootval);<br>        <span class="hljs-type">int</span> split;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>            <span class="hljs-keyword">if</span>(inorder[i] == rootval) &#123;<br>                split = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; inleft = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(inorder.<span class="hljs-built_in">begin</span>(), inorder.<span class="hljs-built_in">begin</span>() + split);<br>        vector&lt;<span class="hljs-type">int</span>&gt; inright = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(inorder.<span class="hljs-built_in">begin</span>() + split + <span class="hljs-number">1</span>, inorder.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; postleft = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(postorder.<span class="hljs-built_in">begin</span>(), postorder.<span class="hljs-built_in">begin</span>() + split);<br>        vector&lt;<span class="hljs-type">int</span>&gt; postright = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(postorder.<span class="hljs-built_in">begin</span>() + split, postorder.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>);<br>        root-&gt;left = <span class="hljs-built_in">buildTree</span>(inleft, postleft);<br>        root-&gt;right = <span class="hljs-built_in">buildTree</span>(inright, postright);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="从前序和中序构造二叉树">从前序和中序构造二叉树</h1><h2 id="递归写法-2">递归写法</h2><p>与上一题同理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> rootval = preorder[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> split = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(split;split &lt; preorder.<span class="hljs-built_in">size</span>();split++) &#123;<br>            <span class="hljs-keyword">if</span>(inorder[split] == rootval) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootval);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftpre</span><span class="hljs-params">(preorder.begin() + <span class="hljs-number">1</span>, preorder.begin() + <span class="hljs-number">1</span> + split)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightpre</span><span class="hljs-params">(preorder.begin() + <span class="hljs-number">1</span> + split, preorder.end())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftin</span><span class="hljs-params">(inorder.begin(), inorder.begin() + split)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightin</span><span class="hljs-params">(inorder.begin() + split + <span class="hljs-number">1</span>, inorder.end())</span></span>;<br>        root-&gt;left = <span class="hljs-built_in">buildTree</span>(leftpre, leftin);<br>        root-&gt;right = <span class="hljs-built_in">buildTree</span>(rightpre, rightin);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代写法-1">迭代写法</h2><p>迭代写法思维很巧妙，官方题解写得很严谨，我直接摘抄并加入自己的注解 ：<span class="label label-success">注解格式</span></p><p><ahref="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">原文链接</a></p><p>对于前序遍历中的任意两个连续节点 <code>u</code> 和<code>v</code>，根据前序遍历的流程，我们可以知道 <code>u</code> 和<code>v</code> 只有两种可能的关系：</p><p><code>v</code> 是 <code>u</code> 的左儿子。这是因为在遍历到<code>u</code> 之后，下一个遍历的节点就是 <code>u</code> 的左儿子，即<code>v</code>；</p><p><code>u</code> 没有左儿子，并且 <code>v</code> 是 <code>u</code>的某个祖先节点（或者 <code>u</code> 本身）的右儿子。 <span class="label label-success">可以自己画几个树来验证</span> ​</p><p>举一个例子来说明第二种关系的正确性，并在例子中给出我们的迭代算法。</p><p><strong>例子</strong>:</p><p>我们以树 <figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">        3<br>       / \<br>     <span class="hljs-number"> 9 </span> 20<br>     /  /  \<br>   <span class="hljs-number"> 8 </span><span class="hljs-number"> 15 </span>  7<br>   / \<br> <span class="hljs-number"> 5 </span> 10<br> /<br>4<br></code></pre></td></tr></table></figure> 为例，它的前序遍历和中序遍历分别为</p><p>preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]</p><p>inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]</p><p>我们用一个栈 <code>stack</code>来维护「<strong>当前节点的所有还没有考虑过右儿子的祖先节点</strong>」<span class="label label-success">栈内的元素无论何时都是这一含义，视作未判断过是不是有右孩子的节点</span>，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针<code>index</code> 指向中序遍历的某个位置，初始值为<code>0</code>。<code>index</code>对应的节点是「<strong>当前节点不断往左走达到的最终节点</strong>」，这也是符合中序遍历的，它的作用在下面的过程中会有所体现。</p><p>首先我们将根节点 <code>3</code> 入栈，再初始化 <code>index</code>所指向的节点为<code>4</code>，随后对于前序遍历中的每个节点，我们依次判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p><p>我们遍历 <code>9</code>。<code>9</code> 一定是栈顶节点 <code>3</code>的左儿子。我们使用反证法，假设 <code>9</code> 是 <code>3</code>的右儿子，那么 <code>3</code> 没有左儿子，<code>index</code>应该恰好指向 <code>3</code>，但实际上为<code>4</code>，因此产生了矛盾。所以我们将 <code>9</code> 作为<code>3</code> 的左儿子，并将 <code>9</code> 入栈。</p><p><code>stack = [3, 9]</code></p><p><code>index -&gt; inorder[0] = 4</code></p><p>我们遍历 <code>8</code>，<code>5</code> 和<code>4</code>。同理可得它们都是上一个节点（栈顶节点）的左儿子，所以它们会依次入栈。</p><p><code>stack = [3, 9, 8, 5, 4]</code></p><p><code>index -&gt; inorder[0] = 4</code></p><p>我们遍历 <code>10</code>，这时情况就不一样了。我们发现<code>index</code> 恰好指向当前的栈顶节点 <code>4</code>，也就是说<code>4</code> 没有左儿子，那么 <code>10</code>必须为栈中某个节点的右儿子。那么如何找到这个节点呢？栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的。<span class="label label-success">z左中右与中左右，其中“中”和“左”是相反的</span></p><blockquote><p>这是因为栈中的任意两个相邻的节点，前者都是后者的某个祖先。并且我们知道，栈中的任意一个节点的右儿子还没有被遍历过，说明后者一定是前者左儿子的子树中的节点，那么后者就先于前者出现在中序遍历中。</p></blockquote><p>因此我们可以把 <code>index</code>不断向右移动，并与栈顶节点进行比较。如果 <code>index</code>对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了栈顶节点，所以将<code>index</code> 增加 <code>1</code> 并弹出栈顶节点，直到<code>index</code>对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后一个节点<code>x</code> 就是 <code>10</code> 的双亲节点，这是因为 <code>10</code>出现在了 <code>x</code> 与 <code>x</code>在栈中的下一个节点的中序遍历之间，因此 <code>10</code> 就是<code>x</code> 的右儿子。</p><p>回到我们的例子，我们会依次从栈顶弹出 <code>4</code>，<code>5</code>和 <code>8</code>，并且将 <code>index</code> 向右移动了三次。我们将<code>10</code> 作为最后弹出的节点 <code>8</code>的右儿子<span class="label label-success">栈中没有考虑右孩子</span>，并将 <code>10</code> 入栈。</p><p><code>stack = [3, 9, 10]</code></p><p><code>index -&gt; inorder[3] = 10</code></p><p>我们遍历 <code>20</code>。同理，<code>index</code>恰好指向当前栈顶节点 <code>10</code>，那么我们会依次从栈顶弹出<code>10</code>，<code>9</code> 和 <code>3</code>，并且将<code>index</code> 向右移动了三次。我们将 <code>20</code>作为最后弹出的节点 <code>3</code> 的右儿子，并将 <code>20</code>入栈。</p><p><code>stack = [20]</code></p><p><code>index -&gt; inorder[6] = 15</code></p><p>我们遍历 <code>15</code>，将 <code>15</code> 作为栈顶节点<code>20</code> 的左儿子，并将 <code>15</code> 入栈。</p><p><code>stack = [20, 15]</code></p><p><code>index -&gt; inorder[6] = 15</code></p><p>我们遍历 <code>7</code>。<code>index</code> 恰好指向当前栈顶节点<code>15</code>，那么我们会依次从栈顶弹出 <code>15</code> 和<code>20</code>，并且将 <code>index</code> 向右移动了两次。我们将<code>7</code> 作为最后弹出的节点 <code>20</code> 的右儿子，并将<code>7</code> 入栈。</p><p><code>stack = [7]</code></p><p><code>index -&gt; inorder[8] = 7</code></p><p>此时遍历结束，我们就构造出了正确的二叉树。</p><p><strong>算法</strong></p><p>我们归纳出上述例子中的算法流程：</p><ul><li><p>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p></li><li><p>我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果<code>index</code>恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动<code>index</code>，并将当前节点作为最后一个弹出的节点的右儿子；如果<code>index</code>和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</p></li></ul><p>无论是哪一种情况，我们最后都将当前的节点入栈。</p><p><strong>代码</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!preorder.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        stack&lt;TreeNode*&gt; stk;<br>        stk.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> inorderIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; preorder.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> preorderVal = preorder[i];<br>            TreeNode* node = stk.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;val != inorder[inorderIndex]) &#123;<br>                node-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorderVal);<br>                stk.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>()-&gt;val == inorder[inorderIndex]) &#123;<br>                    node = stk.<span class="hljs-built_in">top</span>();<br>                    stk.<span class="hljs-built_in">pop</span>();<br>                    ++inorderIndex;<br>                &#125;<br>                node-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorderVal);<br>                stk.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day17</title>
    <link href="/2024/06/07/leetcode-day17/"/>
    <url>/2024/06/07/leetcode-day17/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/balanced-binary-tree/description/">110.平衡二叉树</a></li><li><a href="https://leetcode.cn/problems/binary-tree-paths/">257.二叉树的所有路径</a></li><li><ahref="https://leetcode.cn/problems/sum-of-left-leaves/description/">404.左叶子之和</a></li></ul><h1 id="平衡二叉树">平衡二叉树</h1><p>只是判断平衡二叉树，比较简单，按规范化思路来吧，避免一会有感觉秒了，一会没感觉卡了</p><p>递归结束条件：如果左子树不是平衡二叉树 或者 右子树不是平衡二叉树 或者左右子树深度差距大于1</p><p>递归操作：判断左子树是不是平衡二叉树，判断右子树是不是平衡二叉树，获取左右子树深度</p><p>参数及返回值：根节点 + 是否合法的bool值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//空视作平衡</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;right)) &#123;<span class="hljs-comment">//左右都是</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">getDepth</span>(root-&gt;left) - <span class="hljs-built_in">getDepth</span>(root-&gt;right)) &lt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//左右深度是否匹配</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//空树深度0</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getDepth</span>(root-&gt;left), <span class="hljs-built_in">getDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<span class="hljs-comment">//左右子树最大深度加自己</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个时间复杂度较大，<spanclass="math inline">\(O(n^2)\)</span>，对每一个节点都要单独求深度然后判断，自顶向下</p><p>自底向上做法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getDepth</span>(root) != <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">getDepth</span>(root-&gt;left);<br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//只要一个子树不平衡，整个树就不平衡</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">getDepth</span>(root-&gt;right);<br>    <span class="hljs-keyword">if</span>(right == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(left - right) &lt;= <span class="hljs-number">1</span> ? <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="二叉树的所有路径">二叉树的所有路径</h1><p>递归三步：</p><ol type="1"><li>参数&amp;返回值</li></ol><p>无需返回值，参数有根节点和存路径和答案的数组</p><ol start="2" type="1"><li>递归终止条件</li></ol><p>遇到叶节点</p><ol start="3" type="1"><li>递归逻辑</li></ol><p>没遇到就接着往里插</p><p>比较简单，贴代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        string line;<br>        <span class="hljs-built_in">traversal</span>(root, line);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode * root, string s)</span> </span>&#123;<br>        s += <span class="hljs-built_in">to_string</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) ans.<span class="hljs-built_in">push_back</span>(s);<br>        <span class="hljs-keyword">else</span> &#123;<br>            s += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>            <span class="hljs-keyword">if</span>(root-&gt;left) <span class="hljs-built_in">traversal</span>(root-&gt;left, s);<br>            <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">traversal</span>(root-&gt;right, s);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h2 id="迭代写法">迭代写法</h2><p>用一个栈存节点，一个栈存目前已经走过的路径注意push根节点和其他节点的差异</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        stack&lt;string&gt; path;<br>        stack&lt;TreeNode *&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        path.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">to_string</span>(root-&gt;val));<span class="hljs-comment">//only value</span><br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode * cur = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>            string tem = path.<span class="hljs-built_in">top</span>(); path.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span>(cur-&gt;left) &#123;<br>                st.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                path.<span class="hljs-built_in">push</span>(tem + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">to_string</span>(cur-&gt;left-&gt;val));<span class="hljs-comment">//insert the next value</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur-&gt;right) &#123;<br>                st.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                path.<span class="hljs-built_in">push</span>(tem + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">to_string</span>(cur-&gt;right-&gt;val));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;<span class="hljs-comment">//no next value</span><br>                ans.<span class="hljs-built_in">push_back</span>(tem);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="左叶子之和">左叶子之和</h1><p>需要注意，单独一个根节点不能称作左叶子，只是叶子，但不左</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;<br>            ans = root-&gt;left-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个递归看得有点懵，后面再来仔细理解一下吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day16</title>
    <link href="/2024/06/06/leetcode-day16/"/>
    <url>/2024/06/06/leetcode-day16/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><p><ahref="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104.二叉树的最大深度</a></p></li><li><p><ahref="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/">559.n叉树的最大深度</a></p></li><li><p><ahref="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111.二叉树的最小深度</a></p></li><li><p><ahref="https://leetcode.cn/problems/count-complete-tree-nodes/description/">222.完全二叉树的节点个数</a></p></li></ul><h1 id="树的最大深度">树的最大深度</h1><p>最大深度指从根到所有节点的长度中最长的那一个，换言之就是要找离根最远的节点然后返回到它的长度。</p><p>用DFS和BFS都行，分别代表递归前后序遍历和层序遍历，对于n叉树而言，仅仅是多比较几次而已，改写难度不大</p><p>下附对于n叉树的bfs遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>    queue&lt;Node *&gt; q;<br>    <span class="hljs-keyword">if</span>(root) q.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>            Node * cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; cur-&gt;children.<span class="hljs-built_in">size</span>();j++) &#123;<br>                q.<span class="hljs-built_in">push</span>(cur-&gt;children[j]);<br>            &#125;<br>        &#125;<br>        ans++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的最小深度">二叉树的最小深度</h1><p>最小深度需要注意，是从根到最近的<strong>叶子节点</strong>的距离，<strong>叶子节点</strong>指没有左右孩子的节点</p><p>所以在遍历时需要注意结束条件，对于层序遍历则判断当前节点是否是叶子，如果是就维护最小深度</p><p>对于递归遍历则根据子节点个数来分类处理，如果左右双全或双无，则直接递归；如果只有一个，就单独递归</p><p>下附递归遍历代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">minDepth</span>(root-&gt;left);<br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">minDepth</span>(root-&gt;right);<br><br>    <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + right;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;right == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;left) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(left, right);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>留坑，lc的最快执行代码中在最后<code>return</code>前把<code>root</code>的左右都指<code>null</code>，意义不明，但是就是快，没想出来为什么</em></p><h1 id="完全二叉树的节点个数">完全二叉树的节点个数</h1><p>用普通二叉树的遍历当然能做，只是不太好，还是用好完全二叉树的特性：<strong>非底层全满，底层从左往右堆</strong></p><p>所以完全二叉树的左右子树深度肯定是一样的，如果不一样，那么再递归，直到递归到完全二叉树或者细粒度足够小时的空节点</p><p>代码贴的carl的，原文链接：<ahref="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录| 完全二叉树的节点个数</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    TreeNode* left = root-&gt;left;<br>    TreeNode* right = root-&gt;right;<br>    <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里初始为0是有目的的，为了下面求指数方便</span><br>    <span class="hljs-keyword">while</span> (left) &#123;  <span class="hljs-comment">// 求左子树深度</span><br>        left = left-&gt;left;<br>        leftDepth++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (right) &#123; <span class="hljs-comment">// 求右子树深度</span><br>        right = right-&gt;right;<br>        rightDepth++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (leftDepth == rightDepth) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day15</title>
    <link href="/2024/06/05/leetcode-day15/"/>
    <url>/2024/06/05/leetcode-day15/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102.层序遍历</a><br /></li><li><ahref="https://leetcode.cn/problems/invert-binary-tree/">226.翻转二叉树</a><br /></li><li><ahref="https://leetcode.cn/problems/symmetric-tree/">101.对称二叉树</a></li></ul><h1 id="层序遍历">层序遍历</h1><p>思路就是用队列记录逐层，这样顺序不会变。进入一层时最好记录队列初长度，然后根据长度遍历该层，避免根据队列是否空而判断该层是否遍历结束，便于即时将子节点入队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    TreeNode * cur = root;<br>    queue&lt;TreeNode*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(cur);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            temp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span> (cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(temp);<br>        temp.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="翻转二叉树">翻转二叉树</h1><p>递归版比较简单，太过简单，所以skip</p><p>迭代版就看作在遍历，而且是前序遍历那种单循环，出栈后把左右节点交换，然后压栈左右节点继续就行，给出循环部分的核心代码<del>本来就是核心代码模式，又再核心……</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>    TreeNode* node = st.<span class="hljs-built_in">top</span>();              <span class="hljs-comment">// 中</span><br>    st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>    <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);   <span class="hljs-comment">// 右</span><br>    <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);     <span class="hljs-comment">// 左</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对称二叉树">对称二叉树</h1><p>递归版很简单，写一个辅助函数判断左右节点是不是相等，是树就接着递归，然后从根开始对每一个分支节点的左右孩子判断就行<br />代码没写，偷了个懒😜</p><p>迭代版要难一点，仅限于手写层面，思路不难</p><p>迭代需要用队列或者栈等来存，但是不是按左右顺序挨个入队，而是左右<strong>对应交替</strong>入队，这样方便判断是否相等</p><p>下附carl的漂亮含注释代码，<ahref="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">carl原文链接</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root-&gt;left);   <span class="hljs-comment">// 将左子树头结点加入队列</span><br>        que.<span class="hljs-built_in">push</span>(root-&gt;right);  <span class="hljs-comment">// 将右子树头结点加入队列</span><br>        <br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">// 接下来就要判断这两个树是否相互翻转</span><br>            TreeNode* leftNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            TreeNode* rightNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;  <span class="hljs-comment">// 左节点为空、右节点为空，此时说明是对称的</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span><br>            <span class="hljs-keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;left);   <span class="hljs-comment">// 加入左节点左孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;right); <span class="hljs-comment">// 加入右节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;right);  <span class="hljs-comment">// 加入左节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;left);  <span class="hljs-comment">// 加入右节点左孩子</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day14</title>
    <link href="/2024/06/04/leetcode-day14/"/>
    <url>/2024/06/04/leetcode-day14/</url>
    
    <content type="html"><![CDATA[<p>今日内容：<br />- 递归遍历<br />- 迭代遍历<br />- 统一迭代</p><p>三道例题：</p><p><ahref="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">前序遍历二叉树</a><br /><ahref="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">中序遍历二叉树</a><br /><ahref="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">后续遍历二叉树</a></p><h1 id="递归遍历">递归遍历</h1><p>太过简单，skip</p><h1 id="迭代遍历非统一版">迭代遍历（非统一版）</h1><p>使用栈模拟递归过程：</p><p>前序就是先访问当前节点值，然后压栈右左孩子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    stack&lt;TreeNode*&gt; st;<br>    TreeNode * cur = root;<br>    st.<span class="hljs-built_in">push</span>(cur);<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        cur = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        <span class="hljs-keyword">if</span>(cur-&gt;right) st.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left) st.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>中序就是先存所有左节点，直到遇<code>null</code>再出栈栈顶，访问值后压栈右节点（压栈的所有节点均不为空）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    stack&lt;TreeNode*&gt; st;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    TreeNode * cur = root;<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(cur);<br>            cur = cur-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cur = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>后序比较讨巧，左右中倒序就是中右左，把前序的压栈顺序调换，最后翻转结果就行，就不贴代码了</p><h1 id="统一迭代遍历">统一迭代遍历</h1><p>形式统一的迭代遍历，主要思想是压栈<code>null</code>来<strong>标记</strong>下一个节点需要访问，这样写出来的代码在压栈部分就可以只调换顺序实现三种遍历</p><p>个人感觉比较好理解，最好记住写法，下面以后序为例给出代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; st;<br>    TreeNode * cur = root;<br>    <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)st.<span class="hljs-built_in">push</span>(cur);<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        cur = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br><br>            st.<span class="hljs-built_in">push</span>(cur);<br>            st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-comment">//中</span><br><br>            <span class="hljs-keyword">if</span>(cur-&gt;right) st.<span class="hljs-built_in">push</span>(cur-&gt;right);<span class="hljs-comment">//右</span><br><br>            <span class="hljs-keyword">if</span>(cur-&gt;left) st.<span class="hljs-built_in">push</span>(cur-&gt;left);<span class="hljs-comment">//左</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>            cur = st.<span class="hljs-built_in">top</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day13</title>
    <link href="/2024/06/03/leetcode-day13/"/>
    <url>/2024/06/03/leetcode-day13/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/sliding-window-maximum/description/">239.滑动窗口最大值</a></li><li><a href="">347.前 K 个高频元素</a></li></ul><h1 id="滑动窗口最大值">239.滑动窗口最大值</h1><p>考验对于<code>priority_queue</code>数据结构的了解和掌握程度，不过不能当API选手，得知道怎么手写堆，不求随手手撕出大小顶堆，但是得知道大概写法。</p><h2id="关于priority_queue的感性理解">关于<code>priority_queue</code>的感性理解</h2><p>在lc上看见了评论区大佬，关于<code>priority_queue</code>的比喻描述很形象，特引用至此：</p><blockquote><p>单调队列真是一种让人感到五味杂陈的数据结构，它的维护过程更是如此.....就拿此题来说，队头最大，往队尾方向单调......有机会站在队头的老大永远心狠手辣，当它从队尾杀进去的时候，如果它发现这里面没一个够自己打的，它会毫无人性地屠城，把原先队里的人头全部丢出去，转身建立起自己的政权，野心勃勃地准备开创一个新的王朝.....这时候，它的人格竟发生了一百八十度大反转，它变成了一位胸怀宽广的慈父！它热情地请那些新来的“小个子”们入住自己的王国......然而，这些小个子似乎天性都是一样的——嫉妒心强，倘若见到比自己还小的居然更早入住王国，它们会心狠手辣地找一个夜晚把它们通通干掉，好让自己享受更大的“蛋糕”；当然，遇到比自己强大的，它们也没辙，乖乖夹起尾巴做人。像这样的暗杀事件每天都在上演，虽然王国里日益笼罩上白色恐怖，但是好在没有后来者强大到足以干翻国王，江山还算能稳住。直到有一天，闯进来了一位真正厉害的角色，就像当年打江山的国王一样，手段狠辣，野心膨胀，于是又是大屠城......历史总是轮回的。</p></blockquote><p>似乎没办法贴评论的链接，去description下找吧，应该挺靠前的。</p><p>叛军屠城 = 遇到新最值，<strong>全弹出</strong>; 慈悲为怀 =后续小值有序堆在队头之后;</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; pq;<span class="hljs-comment">//存pair，得带上值得下标方便确定是不是该出队</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">empty</span>()) pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<span class="hljs-comment">//空的直接存</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] &gt;= pq.<span class="hljs-built_in">top</span>().first) &#123;<span class="hljs-comment">//新最值，全出队</span><br>                <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>()) pq.<span class="hljs-built_in">pop</span>();<br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &gt;= k) &#123;<span class="hljs-comment">//已满</span><br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<br>                <span class="hljs-keyword">while</span>(pq.<span class="hljs-built_in">top</span>().second + k &lt;= i)<span class="hljs-comment">//出队已经晚了的,注意得是while</span><br>                    pq.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<br>            <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &gt;= k) ans.<span class="hljs-built_in">push_back</span>(pq.<span class="hljs-built_in">top</span>().first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="前k个高频元素">347.前k个高频元素</h1><p>感觉思路比较简单暴力，用map来记“值-频率”，然后根据“频率数组”建堆排序来降低时间复杂度到O(nlogn)以下。总之是先记再排序。</p><p>不过carl的反其道而行很巧妙，采用小根堆，这样就可以简单地根据队列盈满来出队队头，官解也是小根堆，不过没有简单出队，而是判断当前的和队头的哪个更小，如果队头更小才出队。</p><p>对于pq自定义排序标准的语法不了解，是看过之后才写的，对于这道题</p><p><code>priority_queue</code>的模板类型参数有三，1.要存的类型；2.要存的类型的vector；3.自定义比较方法所在类，自定义比较需重载<code>()</code>运算符</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">cmp</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//用map记录值-频率，通过优先队列或者堆来对前k个频率排序，最后输出前k个元素</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) map[i]++;<br><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, cmp&gt; pq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : map) &#123;<br>            pq.<span class="hljs-built_in">push</span>(it);<br>            <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &gt; k) pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span> (k--)&#123;<br>            <span class="hljs-type">int</span> t = pq.<span class="hljs-built_in">top</span>().first;<br>            ans.<span class="hljs-built_in">push_back</span>(t);<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day11</title>
    <link href="/2024/06/01/leetcode-day11/"/>
    <url>/2024/06/01/leetcode-day11/</url>
    
    <content type="html"><![CDATA[<p>今日内容： - <ahref="https://leetcode.cn/problems/valid-parentheses/description/">20.有效的括号</a><br />- <ahref="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">1047.删除字符串中所有相邻重复项</a><br />- <ahref="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150.逆波兰表达式求值</a></p><h1 id="有效的括号">20.有效的括号</h1><p>其实这题跟最后一个逆波兰表达式有关，最后一题是逆波兰表达式求值，但是根据中缀表达式生成逆波兰表达式的算法里就会用到栈来处理中缀中的括号问题。</p><p>所以一个栈直接秒了，思路打开，碰到左括号别傻傻push左括号，而得push右括号，这样就可以直接判断<code>top()</code>了，而不用碰到右括号的时候再来个转换。</p><p><del>没错，我这次就push的左括号，碰到右括号的时候还用ASCII码去算对应的左括号值</del></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stack&lt;<span class="hljs-type">char</span>&gt; b;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) b.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) b.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span>) b.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b.<span class="hljs-built_in">empty</span>() || s[i] != b.<span class="hljs-built_in">top</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> b.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> b.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除字符串中所有相邻重复项">1047.删除字符串中所有相邻重复项</h1><p>如果不告诉用栈做的话，貌似还挺复杂的，不过用栈就很简单了</p><p>压栈前判断栈顶是不是重复，重复就pop，不重复就push，建议从尾到头遍历s，这样全pop出来时顺序还是对的。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() != s[i]) st.<span class="hljs-built_in">push</span>(s[i]);<br>            <span class="hljs-keyword">else</span> st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        string ans;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;!st.<span class="hljs-built_in">empty</span>();i++) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(st.<span class="hljs-built_in">top</span>());<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="逆波兰表达式求值">105.逆波兰表达式求值</h1><p>笔者大一下的Qt课设就是写一个大数计算器，对这逆波兰表达式还是比较熟悉，有了式子，求值就比较简单了，这个题还确保了int不炸。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; tokens.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;+&quot;</span> || tokens[i] == <span class="hljs-string">&quot;-&quot;</span> || tokens[i] == <span class="hljs-string">&quot;*&quot;</span> || tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>                <span class="hljs-type">int</span> num1 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> num2 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;+&quot;</span>) st.<span class="hljs-built_in">push</span>(num1 + num2);<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;-&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 - num1);<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;*&quot;</span>) st.<span class="hljs-built_in">push</span>(num1 * num2);<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 / num1);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(tokens[i]));<br>        &#125;<br>        <span class="hljs-type">int</span> res = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day10</title>
    <link href="/2024/05/31/leetcode-day10/"/>
    <url>/2024/05/31/leetcode-day10/</url>
    
    <content type="html"><![CDATA[<p>此帖仅作打卡用，过于简单，建议跳过</p><h1 id="用栈实现队列"><ahref="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232.用栈实现队列</a></h1><p>根据题意，用俩栈来回倒就行</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; q1;<br>    stack&lt;<span class="hljs-type">int</span>&gt; q2;<br>    <span class="hljs-built_in">MyQueue</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q2.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> pipe = q2.<span class="hljs-built_in">top</span>();<br>            q2.<span class="hljs-built_in">pop</span>();<br>            q1.<span class="hljs-built_in">push</span>(pipe);<br>        &#125;<br>        q1.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> pipe = q1.<span class="hljs-built_in">top</span>();<br>            q1.<span class="hljs-built_in">pop</span>();<br>            q2.<span class="hljs-built_in">push</span>(pipe);<br>        &#125;<br>        <span class="hljs-type">int</span> ans = q2.<span class="hljs-built_in">top</span>();<br>        q2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> pipe = q1.<span class="hljs-built_in">top</span>();<br>            q1.<span class="hljs-built_in">pop</span>();<br>            q2.<span class="hljs-built_in">push</span>(pipe);<br>        &#125;<br>        <span class="hljs-keyword">return</span> q2.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">empty</span>() &amp;&amp; q2.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="用队列实现栈"><ahref="https://leetcode.cn/problems/implement-stack-using-queues/">225.用队列实现栈</a></h1><p>一个双端队列完事</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    deque&lt;<span class="hljs-type">int</span>&gt; d1;<br>    <span class="hljs-built_in">MyStack</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        d1.<span class="hljs-built_in">push_front</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> p = d1.<span class="hljs-built_in">front</span>();<br>        d1.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> d1.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> d1.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day6</title>
    <link href="/2024/05/30/leetcode-day6/"/>
    <url>/2024/05/30/leetcode-day6/</url>
    
    <content type="html"><![CDATA[<h1 id="有效的字母异位词"><ahref="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">有效的字母异位词</a></h1><p>哈希表新手题，不过可以直接排序再判断，剑走偏锋不用哈希</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() != t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> s == t;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="两个数组的交集"><ahref="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">两个数组的交集</a></h1><p>这个也可以排序然后双指针，不用哈希，时间复杂度 <spanclass="math inline">\(O(mlogm+nlogn)\)</span>，主要是排序的复杂度，空间复杂度<span class="math inline">\(O(mlogm+nlogn)\)</span> 也是排序造成的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> len1 = nums1.<span class="hljs-built_in">size</span>(), len2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> index1 = <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span>(index1 &lt; len1 &amp;&amp; index2 &lt; len2) &#123;<br>            <span class="hljs-keyword">if</span>(nums1[index1] == nums2[index2]) &#123;<br>                <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || nums1[index1] != ans.<span class="hljs-built_in">back</span>()) ans.<span class="hljs-built_in">push_back</span>(nums1[index1]);<br>                index1++;<br>                index2++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[index1] &lt; nums2[index2]) index1++;<br>            <span class="hljs-keyword">else</span> index2++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="快乐数"><ahref="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">快乐数</a></h1><p>这题和<ahref="https://leetcode.cn/problems/linked-list-cycle-ii/description/">环形链表II</a>有点异曲同工之妙，笔者的做法是用一个set来记录每次计算的结果，重复就false，等于1就true。</p><p>但看过评论区后发现，这样只是走了int限制的捷径，有可能会爆栈，所以不能记录，而应该采取环形链表中检查环的方法——追及问题。</p><p>用快慢指针，不过指的是计算结果，如果fast最终等于slow，则有环，false，这样空间复杂度就成了<spanclass="math inline">\(O(1)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitSquareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> bit = n % <span class="hljs-number">10</span>;<br>            sum += bit * bit;<br>            n = n / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slow = n, fast = n;<br>        <span class="hljs-keyword">do</span>&#123;<br>            slow = <span class="hljs-built_in">bitSquareSum</span>(slow);<br>            fast = <span class="hljs-built_in">bitSquareSum</span>(fast);<br>            fast = <span class="hljs-built_in">bitSquareSum</span>(fast);<br>        &#125;<span class="hljs-keyword">while</span>(slow != fast);<br>        <br>        <span class="hljs-keyword">return</span> slow == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><ahref="https://leetcode.cn/problems/happy-number/solutions/21454/shi-yong-kuai-man-zhi-zhen-si-xiang-zhao-chu-xun-h/">该题解来源</a></p><h1 id="两数之和"><ahref="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">两数之和</a></h1><p>思路还记得，用哈希来记录target -x，利用set查找的O(1)复杂度来优化查找过程。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">find</span>(target - nums[i]);<br>            <span class="hljs-keyword">if</span>(it != map.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> &#123;it-&gt;second, i&#125;;<br>            map[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="unordered_set">unordered_set</h1><ul><li>无序存储</li><li>元素独一无二，即键值key唯一</li></ul><p>## 常用方法</p><ul><li><code>unorder_set&lt;string&gt; first</code>容器定义</li><li><code>first.empty()</code>判断容器是否是空，是空返回<code>true</code>，反之为<code>false</code></li><li><code>first.size()</code>返回容器大小</li><li><code>first.maxsize()</code>返回容器最大尺寸</li><li><code>first.begin()</code>返回迭代器开始</li><li><code>first.end()</code>返回迭代器结束</li><li><code>first.find(value)</code>返回<code>value</code>在迭代器的位置，没找到会返回<code>end()</code></li><li><code>first.count(key)</code>返回key在容器的个数</li><li><code>first.insert(value)</code>将value插入到容器中</li><li><code>first.erase(key)</code>通过key删除</li><li><code>first.clear()</code>清空容器 <ahref="https://cplusplus.com/reference/unordered_map/unordered_map/">详细文档</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day4</title>
    <link href="/2024/05/30/leetcode-day4/"/>
    <url>/2024/05/30/leetcode-day4/</url>
    
    <content type="html"><![CDATA[<h1 id="两两交换链表中的节点"><ahref="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24.两两交换链表中的节点</a></h1><p>​链表貌似就是虚头+双指针+遍历，回到老家的感觉，注意对空节点的检查就好，题不难</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode * virhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        virhead-&gt;next = head;<br>        ListNode * left = virhead;<br>        ListNode * right = head;<br>        <span class="hljs-keyword">while</span>(right &amp;&amp; right-&gt;next) &#123;<br>            left-&gt;next = right-&gt;next;<br>            right-&gt;next = right-&gt;next-&gt;next;<br>            left-&gt;next-&gt;next = right;<br>            left = right;<br>            right = right-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> virhead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除链表的倒数第n个节点"><ahref="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19.删除链表的倒数第n个节点</a></h1><p>算脑筋急转弯吧，不过之前做过，已经没有难度了，思路就是让fast先走n步，再和slow一起走，这样fast走到最后slow就是倒数第n个了。</p><blockquote><p>​评论区在diss官解的“一次遍历”说法，去搜了一下，看见了宫水三叶前辈的帖，下为结论：</p><p>我们应该用「对数组的访问次数」来定义遍历多少次，而不是「利用 for循环的个数」来定义。 上述无论那种方法，对数组访问次数都是一样的。</p><p>出处：<ahref="https://developer.aliyun.com/article/905822">为什么「一次遍历」要比「两次遍历」慢（含小实验代码） | Java 刷题打卡-阿里云开发者社区 (aliyun.com)</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode * vir = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        vir-&gt;next = head;<br>        ListNode * fast = vir;<br>        ListNode * slow = vir;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        ListNode * t = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> t;<br>        <span class="hljs-keyword">return</span> vir-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="链表相交"><ahref="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">链表相交</a></h1><p>思路比较原始，都走一遍，把屁股对齐，长的先走几步把优势消耗，然后一起走找交点。</p><p>官解的追及思路更优雅，不过复杂度相同。<ahref="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solutions/1395092/lian-biao-xiang-jiao-by-leetcode-solutio-2kne/">官解</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode * vir = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        vir-&gt;next = head;<br>        ListNode * fast = vir;<br>        ListNode * slow = vir;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        ListNode * t = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> t;<br>        <span class="hljs-keyword">return</span> vir-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="环形链表ii"><ahref="https://leetcode.cn/problems/linked-list-cycle-ii/description/">环形链表II</a></h1><p>数学题，刚开始没推出来，注意把环分成走过的b段和没走过的c段，这样就很直观了，贴个图帮助理解</p><figure><img src="https://s3.bmp.ovh/imgs/2024/05/31/868052041ecc7ee9.jpg"alt="环形链表示意图" /><figcaption aria-hidden="true">环形链表示意图</figcaption></figure><p><em>公式中a对应图中x，y对应b，z对应c</em></p><p>求的是a，slow被碰到时离入口还差c，所以此时再来个指针从头开始一起走，碰到的时候刚好就是等式两边，即入口。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode * fast = head;<br>        ListNode * slow = head;<br>        <span class="hljs-keyword">while</span>(fast) &#123;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(!fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast == slow) &#123;<br>                ListNode * ans = head;<br>                <span class="hljs-keyword">while</span>(ans != slow) &#123;<br>                    ans = ans-&gt;next;<br>                    slow = slow-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>不太难，链表问题不大，注意空指针检查就行。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day3</title>
    <link href="/2024/05/30/leetcode-day3/"/>
    <url>/2024/05/30/leetcode-day3/</url>
    
    <content type="html"><![CDATA[<h1 id="移除链表元素"><ahref="https://leetcode.cn/problems/remove-linked-list-elements/description/">203.移除链表元素</a></h1><p>看见链表跟回家一样，大一走来就研究链表，被<code>-&gt;</code>和<code>.</code>的用法confuse了好久，然后链表操作信手拈来，现在实现个线性表、栈、队列都是拿链表来实现，数组都不会写了……</p><p>题很简单，拿java练练语法好了，就连java都是一把过： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        h.next = head;<br>        ListNode cur = h;<br>        <span class="hljs-keyword">while</span>(cur.next != null) &#123;<br>            <span class="hljs-keyword">if</span>(cur.next.val == val) &#123;<br>                cur.next = cur.next.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>                cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="设计链表"><ahref="https://leetcode.cn/problems/design-linked-list/description/">707.设计链表</a></h1><p>群友遇到问题，跟着debug了一会，本来不想做的，给出修改后的群友代码吧，收获也有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(index--)<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; index;i++)<br></code></pre></td></tr></table></figure><p>就是这上面俩是等效的，不够之前知道，算加深印象吧，毕竟while(index--)这样的写法不常见，但是字少。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;<br>        <span class="hljs-type">int</span> val;<br>        LNode* next;<br>        <span class="hljs-built_in">LNode</span>(<span class="hljs-type">int</span> v):<span class="hljs-built_in">val</span>(v),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125; <span class="hljs-comment">//构造函数</span><br>       <span class="hljs-comment">// LNode(int v)&#123; val=v,next=nullptr;&#125;</span><br>    &#125;;<br>    <span class="hljs-built_in">MyLinkedList</span>() &#123;<br>        <span class="hljs-comment">//建立空链表</span><br>        lsize=<span class="hljs-number">0</span>;<br>        lhead=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;=lsize) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        LNode* p=lhead;<br>        <span class="hljs-comment">//从第一个实际数据开始遍历，当循环结束，一定是p指向了Index位置</span><br>        <span class="hljs-keyword">while</span>(index--)<br>            p=p-&gt;next;<br>        p=p-&gt;next;<br>        <span class="hljs-keyword">return</span> p-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//将val插入作为第一个节点，即头结点的下一个</span><br>        LNode* np=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(val);<br>        np-&gt;next=lhead-&gt;next;<br>        lhead-&gt;next=np;<br>        lsize++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//在最后增加节点</span><br>        LNode* np=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(val);<br>        LNode* p=lhead;<br>        <span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            p=p-&gt;next;<br>        &#125;<br>        np-&gt;next=p-&gt;next;<br>        p-&gt;next=np;<br>        lsize++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&gt;lsize) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(index == lsize) &#123;<br>            <span class="hljs-built_in">addAtTail</span>(val);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        LNode* np=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(val);<br>        LNode* p=lhead;<br>        <span class="hljs-keyword">while</span>(index--)<br>            p=p-&gt;next;<br>        np-&gt;next=p-&gt;next;<br>        p-&gt;next=np;<br>        lsize++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;=lsize) <span class="hljs-keyword">return</span>;<br>        LNode* p=lhead;<br>        <span class="hljs-keyword">while</span>(index--)<br>            p=p-&gt;next;<br>        LNode* tmp=p-&gt;next;<br>           p-&gt;next=p-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        lsize--;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> lsize;<br>    LNode* lhead;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="反转链表"><ahref="https://leetcode.cn/problems/reverse-linked-list/description/">206.反转链表</a></h1><p>主要看了下递归做法，对于递归还是很迷，这次也没有一次写出来。</p><p>将后续部分看作已经反转完成，所以当前节点的下一个节点的下一个应该变成当前，即：</p><p><code>cur-&gt;next-&gt;next = cur;</code></p><p>对于头节点，再加一个next指null，就完成了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode * virHead = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> virHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day8</title>
    <link href="/2024/05/29/leetcode_day8/"/>
    <url>/2024/05/29/leetcode_day8/</url>
    
    <content type="html"><![CDATA[<h1 id="反转字符串ii"><ahref="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">反转字符串II</a></h1><p>按题意模拟即可，重写reverse方法，方便直接根据下标反转<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i += k) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span>*k == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">reverse</span>(s, begin, i / <span class="hljs-number">2</span>);<br>                begin = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= end) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">while</span>(begin &lt; end)&#123;<br>            <span class="hljs-type">char</span> c = s[begin];<br>            s[begin] = s[end];<br>            s[end] = c;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="替换数字"><ahref="https://programmercarl.com/kama54.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html">替换数字</a></h1><p>预先扩充好空间，然后<strong>从后向前</strong>扫描 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>        <span class="hljs-type">int</span> sOldIndex = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计数字的个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 扩充字符串s的大小，也就是将每个数字替换成&quot;number&quot;之后的大小</span><br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + count * <span class="hljs-number">5</span>);<br>        <span class="hljs-type">int</span> sNewIndex = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 从后往前将数字替换为&quot;number&quot;</span><br>        <span class="hljs-keyword">while</span> (sOldIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (s[sOldIndex] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[sOldIndex] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;r&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;e&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;m&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;u&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;n&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                s[sNewIndex--] = s[sOldIndex];<br>            &#125;<br>            sOldIndex--;<br>        &#125;<br>        cout &lt;&lt; s &lt;&lt; endl;       <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="反转单词"><ahref="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">反转单词</a></h1><p>思路比较巧，全部反转，然后再反转单词，这样就得到了词序反转，注意删除空格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">auto</span> it1 = s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">auto</span> it2 = s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(it2 != s.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">while</span>(*it2 != <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; it2 != s.<span class="hljs-built_in">end</span>()) it2++;<br>            <span class="hljs-built_in">reverse</span>(it1, it2);<br>            <span class="hljs-keyword">while</span>(*it2 == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; it2 != s.<span class="hljs-built_in">end</span>()) it2++;<br>            it1 = it2;<br>        &#125;<br>        it1=s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(it1!=s.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(it1==s.<span class="hljs-built_in">begin</span>() &amp;&amp; *it1 == <span class="hljs-string">&#x27; &#x27;</span>) s.<span class="hljs-built_in">erase</span>(it1);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*it1 == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; *<span class="hljs-built_in">next</span>(it1) == <span class="hljs-string">&#x27; &#x27;</span>) s.<span class="hljs-built_in">erase</span>(it1);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">next</span>(it1) == s.<span class="hljs-built_in">end</span>() &amp;&amp; *it1 == <span class="hljs-string">&#x27; &#x27;</span>) s.<span class="hljs-built_in">erase</span>(it1);<br>            <span class="hljs-keyword">else</span> it1++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="右旋字符串"><ahref="https://programmercarl.com/kama55.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html">右旋字符串</a></h1><p>思路与反转单词差不多，整体局部反转活用就行 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    string s;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//获取长度</span><br><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 整体反转</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + n); <span class="hljs-comment">// 先反转前一段，长度n</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + n, s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 再反转后一段</span><br><br>    cout &lt;&lt; s &lt;&lt; endl;<br><br>&#125; <br></code></pre></td></tr></table></figure>字符串和数组很像，后面的<spanclass="math inline">\(KMP\)</span>上难度，前面的比较简单，略过即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day7</title>
    <link href="/2024/05/28/leetcode_day7/"/>
    <url>/2024/05/28/leetcode_day7/</url>
    
    <content type="html"><![CDATA[<h1 id="四数相加"><ahref="https://leetcode.cn/problems/4sum-ii/description/">454.四数相加</a></h1><blockquote><p>视频讲解: <ahref="https://www.bilibili.com/video/BV1Md4y1Q7Yh/">学透哈希表，map使用有技巧！LeetCode：454.四数相加II</a></p><p>文章讲解：<ahref="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html">454.四数相加</a></p></blockquote><p>之前做过，知道用map，但是太久没用过map，一时间不知道怎么用map，干瞪眼十几分钟，最后看了题解，思路有，但是map的用法限制了我……</p><h2id="unordered_map怎么在算法题中使用">unordered_map怎么在算法题中使用</h2><p>unordered_map是std命名空间下的，所以自己写ACM模式的时候记得加<code>std::</code></p><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td><code>map</code></td><td>红黑树</td><td>key有序</td><td>key不重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td><code>multimap</code></td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td><code>unordered_map</code></td><td>哈希表</td><td>key无序</td><td>key不重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>由该表能看出，unordered_map查找的效率最高，但是内部元素无序</p><p>适用于：当作记录型变量用于需要多次查找的场合</p><p><strong>创建unordered_map</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//注意给出两个模板类型变量</span><br>unordered_map&lt;type1, type2&gt; map;<br><span class="hljs-comment">//设定初值方法</span><br>unordered_map&lt;t1, t2&gt; map = &#123;&#123;key1, value1&#125;, &#123;key2, value2&#125;, ……&#125;;<br>vector&lt;pair&lt;t1, t2&gt;&gt; v = &#123;&#123;key1, value1&#125;, &#123;key2, value2&#125;, ……&#125;;  <br><span class="hljs-comment">//使用既有pair数组初始化</span><br><span class="hljs-function">unordered_map&lt;<span class="hljs-type">int</span>, string&gt; <span class="hljs-title">map</span><span class="hljs-params">(v.begin(), v.end())</span></span>;<br></code></pre></td></tr></table></figure><p><strong>插入一个元素进map</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果要记录的是&lt;key, value&gt;</span><br>map[key] = value;<br><span class="hljs-comment">//或者复杂点</span><br>map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;type1, type2&gt;(key, value));<br><span class="hljs-comment">//如果记录key出现几次</span><br>map[key]++;<span class="hljs-comment">//[]被重载过，即使没有key也会创建一个并赋值1</span><br></code></pre></td></tr></table></figure><p><strong>map的迭代器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用迭代器访问key和value</span><br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map;<br><span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">begin</span>();<br>it-&gt;first = key;<span class="hljs-comment">//it视作一个pair&lt;int, string&gt;元素，用-&gt;访问key和value</span><br>it-&gt;second = value;<span class="hljs-comment">//说白了就是用first和second</span><br></code></pre></td></tr></table></figure><p><strong>map的增删改查方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> type1&amp; key)</span>    <span class="hljs-comment">//返回key在map中的位置，没有就指end()</span></span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">const</span> type1&amp; key)</span>    <span class="hljs-comment">//返回哈希桶中关键码为key的键值对的个数</span></span><br><span class="hljs-function">insert    <span class="hljs-comment">//插入键值对</span></span><br><span class="hljs-function">erase     <span class="hljs-comment">//删除键值对</span></span><br></code></pre></td></tr></table></figure><p>注意<code>erase</code>方法是使用迭代器删除元素，传入的参数指向目标的迭代器，而返回下一个元素的迭代器，用<code>for</code>遍历删除时不要 <code>iter++</code>，应该使用<code>iter = map.erase(iter)</code></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : nums1) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b : nums2) &#123;<br>                <span class="hljs-type">int</span> sum = a + b;<br>                map1[sum]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : nums3) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b : nums4) &#123;<br>                <span class="hljs-keyword">if</span>(map1.<span class="hljs-built_in">count</span>(-a-b)) <br>                    ans += map1[-a-b];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="赎金信"><ahref="https://leetcode.cn/problems/ransom-note/description/">383.赎金信</a></h1><blockquote><p>Carl文章&amp;视频链接：<ahref="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html">代码随想录| 383.赎金信</a></p></blockquote><p>看覆不覆盖就完了，用 <code>char alpha[26]</code>或者开一个<code>map</code>都行，一次遍历 ++，一次遍历 --，缺了就 false，不缺就true</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : magazine) &#123;<br>            map[c]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : ransomNote) &#123;<br>            <span class="hljs-keyword">if</span>(map[c]) map[c]--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="三数之和双指针"><ahref="https://leetcode.cn/problems/3sum/description/">15.三数之和（双指针）</a></h1><blockquote><p>Carl文章&amp;视频链接：<ahref="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录| 三数之和</a></p></blockquote><p>该题看起来是<ahref="https://leetcode.cn/problems/two-sum/description/">两数之和</a>的拓展，所以自然想到用双指针，但是有3个数，得3个指针，所以拆分子问题，一个指针在大循环里移动，小循环内使用两数之和的方法查找。</p><p>还得去重操作，没有关注，WA了几发，哈希做法需要大量剪枝没看。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">2</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> target = -nums[i];<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>                <span class="hljs-type">int</span> sum = nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>(sum == target) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    left++;<br>                    right--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target) &#123;<br>                    left++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <br>                    right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="四数之和双指针"><ahref="https://leetcode.cn/problems/4sum/description/">四数之和（双指针）</a></h1><blockquote><p>Carl文章&amp;视频链接：<ahref="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录| 四数之和</a></p></blockquote><p>跟三数之和差不多，继续拆分子问题套循环，不过又多了剪枝操作</p><p>还得注意范围，此题会爆 <code>int</code>，得用<code>long long</code></p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>      <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">3</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) &#123;<span class="hljs-comment">//已经太大</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<span class="hljs-comment">//已经太小</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;j &lt; n - <span class="hljs-number">2</span>;j++) &#123;<br>                <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) &#123;<span class="hljs-comment">//已经太大</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[j] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<span class="hljs-comment">//已经太小</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> left = j + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[left] + nums[right] + nums[i] + nums[j];<br>                    <span class="hljs-keyword">if</span>(sum == target) &#123;<br>                        ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt; &#123;nums[i], nums[j], nums[left], nums[right]&#125;);<br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                        left++;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) &#123;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <br>                        left++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迷迭香的记事本：怎么写博客</title>
    <link href="/2024/05/27/%E8%BF%B7%E8%BF%AD%E9%A6%99%E7%9A%84%E8%AE%B0%E4%BA%8B%E6%9C%AC%EF%BC%9A%E6%80%8E%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/05/27/%E8%BF%B7%E8%BF%AD%E9%A6%99%E7%9A%84%E8%AE%B0%E4%BA%8B%E6%9C%AC%EF%BC%9A%E6%80%8E%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1><p>目前，如果misery想要写一篇博客，本地步骤为： 1.打开创建在<code>D:</code>的<code>blog</code>文件夹 2.右键，<code>git bash here</code>，输入<code>hexo new blog 'YOUR_BLOG_NAME'</code>3.进入<code>source\_post</code>文件夹中，找到step2创建的YOUR_BLOG_NAME.md文件，用vscode打开，进行编辑4.回到bash，输入<code>hexo g</code>重新生成静态页面，选择性输入<code>hexo s</code>预览效果5. 输入<code>hexo d</code>上传到github</p><h1id="hexo-d后博客未发生变化"><code>hexo d</code>后博客未发生变化?</h1><p>如果step5执行后，repository中看得见变化，能找到博客，但是网页并未发生变化，则回到<code>/blog</code>下的bash中输入<code>hexo clean</code>清除缓存（删除<code>/public</code>文件夹），重新从step4执行即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day2</title>
    <link href="/2024/05/23/leetcode-day2/"/>
    <url>/2024/05/23/leetcode-day2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第二天就有所松懈了，拖到晚上才写，拓展题也没写完，今天的没那么无脑，所以用老本行C++写</p></blockquote><h1 id="有序数组的平方"><ahref="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组的平方</a></h1><p>打眼一瞧，这题就是拿正负数平方之后大小不定来考人，结合卡哥想练的双指针，不难想到左右指针比绝对值大小一个一个插入，虽然这样是从大到小，不过有<code>reverse()</code>可以用，比较方便，也没有增加时间复杂度，还是<spanclass="math inline">\(O(n)\)</span>，下附代码，不甚完美，可点击链接去看官解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(nums[left]) &lt; <span class="hljs-built_in">abs</span>(nums[right])) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums[right] * nums[right]);<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(nums[left]) &gt;= <span class="hljs-built_in">abs</span>(nums[right])) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums[left] * nums[left]);<br>                left++;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="长度最小的子数组"><ahref="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a></h1><p><strong>题目</strong></p><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其总和大于等于 <code>target</code>的长度最小的 连续子数组<code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>这题是滑动窗口，由于做过多次，所以记得比较清楚，直接写了，结果遇到不少问题，WA了一发才解决，对于区间开闭的把握还不纯熟……<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> target &lt;= nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">1</span>, sum = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right &lt;= nums.<span class="hljs-built_in">size</span>() &amp;&amp; left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span>(sum &lt; target &amp;&amp; right &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>                sum += nums[right++];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt;= target &amp;&amp; left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>) ans = right - left;<br>                <span class="hljs-keyword">else</span> ans = <span class="hljs-built_in">min</span>(ans, right - left);<br>                sum -= nums[left++];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="拓展水果成篮">拓展——<ahref="https://leetcode.cn/problems/fruit-into-baskets/">水果成篮</a></h1><p>这题是卡哥关于滑动窗口的拓展题1，小生不才，WA了五发才过，思路一直不清，将思路转换为代码语言也不准确。</p><blockquote><p>大概描述思路：</p><p>俩篮子我用俩变量bucket1、bucket2来模拟，含左右顺序，俩指针做滑动窗口代表当前能摘的树。一个ans作为结果一直维护一个最大值，每遇到新树，则将left前进到第二种水果第一次出现的地方，right重新从left处开始走。至于第一次出现的位置我用一个<code>pair</code>来存。</p></blockquote><p>下附代码，官解与我不同，使用了哈希表，我也想用，苦于set和map系列语法掌握不牢，没写出来……<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fruits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(fruits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; bucket1, bucket2;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">1</span>;<br>        bucket1.first = fruits[left];<br>        bucket1.second = left;<br>        bucket2.first = <span class="hljs-number">-1</span>;<br>        bucket2.second = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; right &lt; fruits.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(fruits[right] == bucket1.first) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fruits[right] == bucket2.first) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bucket2.first == <span class="hljs-number">-1</span>)&#123;<br>                bucket2.first = fruits[right];<br>                bucket2.second = right;<br>                ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                left = bucket2.second;<br>                bucket1.first = bucket2.first;<br>                bucket1.second = left;<br>                bucket2.first = <span class="hljs-number">-1</span>;<br>                bucket2.second = <span class="hljs-number">-1</span>;<br>                right = left;<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>leetcode 官方题解：<ahref="https://leetcode.cn/problems/fruit-into-baskets/solutions/1893352/shui-guo-cheng-lan-by-leetcode-solution-1uyu/">水果成篮</a></p><h1 id="拓展最小覆盖子串">拓展——<ahref="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></h1><p>吐了，写的全没了，不记了，直接抛出灵神题解算了，哈希方法的确妙，还有less对于检索的优化。</p><p><ahref="https://leetcode.cn/problems/minimum-window-substring/solutions/2713911/liang-chong-fang-fa-cong-o52mn-dao-omnfu-3ezz/">灵茶山艾府题解</a></p><h1 id="螺旋矩阵ii"><ahref="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵II</a></h1><p>这题经典模拟，之前做过多次，这次一把过，左sir讲过优雅的四循环，评论区也是优雅的四循环，所以我也优雅的四循环，但还是不够优雅。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, bottom = n - <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> map[n][n];<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(k &lt;= n*n) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = left;t &lt;= right;t++) <br>                map[top][t] = k++;<br>            top++;<br>            <span class="hljs-keyword">if</span>(k &gt; n*n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = top;r &lt;= bottom;r++) <br>                map[r][right] = k++;<br>            right--;<br>            <span class="hljs-keyword">if</span>(k &gt; n*n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b = right;b &gt;= left;b--)<br>                map[bottom][b] = k++;<br>            bottom--;<br>            <span class="hljs-keyword">if</span>(k &gt; n*n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = bottom;l &gt;= top;l--)<br>                map[l][left] = k++;<br>            left++;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; t;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>                t.<span class="hljs-built_in">push_back</span>(map[i][j]);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(t);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>数组部分总体不难，主要是双指针和滑动窗口思想，双指针有快慢指针和左右指针，滑动窗口偏贪心一点，大体是right向前去满足条件，满足之后收紧left寻找最优，最后综合所有最优选出整体最优。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day1</title>
    <link href="/2024/05/22/leetcode-day1/"/>
    <url>/2024/05/22/leetcode-day1/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><ahref="https://leetcode.cn/problems/binary-search/">二分查找</a></h1><p>之前用C++刷过不止一遍，所以这次用java重写，没想到遇到了语法问题，尴尬……</p><ul><li>参数给的<code>int[] nums</code>，跟C的普通数组一样吗？那我怎么得到长度呢？java有<code>sizeof()</code>吗？</li><li>我第一时间想递归，但是怎么传被分割后的数组呢？</li></ul><p>搜索学习一波后了解到，java的<code>int[]</code>类型可以获取长度，具体见下：</p><h2 id="java数组语法小记">java数组语法小记</h2><h3 id="length属性">length属性</h3><ul><li><code>length</code>是数组的一个属性，用于获取数组的长度。</li><li>这是数组对象的一个公共属性，不是类的成员。</li></ul><p>例如： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <br>System.out.println(nums.length); <span class="hljs-comment">// 输出数组的长度：5</span><br></code></pre></td></tr></table></figure> ### 其他可用的操作</p><p>虽然length是唯一一个直接通过点符号<code>.</code>访问的数组属性，但数组对象还可以通过一些标准的类库方法进行操作。例如：</p><ol type="1"><li><p><strong>Arrays 类：</strong></p><p>Arrays 类提供了许多静态方法来操作数组，例如排序、搜索、比较、填充等。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays; <br><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;; <br>Arrays.sort(nums); <span class="hljs-comment">// 对数组进行排序</span><br>System.out.println(Arrays.toString(nums)); <span class="hljs-comment">// 将数组转换为字符串并输出：[1, 1, 3, 4, 5]</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>System 类：</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System 类提供了一些方法来进行数组的复制等操作。<br><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <br><span class="hljs-type">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>System.arraycopy(nums, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>, nums.length); <span class="hljs-comment">// 复制数组</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>Collections 类（适用于对象数组）：</strong>对于对象数组，可以使用 Collections类的方法进行排序、搜索等操作，但对于基本类型数组（如 int[]），需要使用Arrays 类的方法。</p></li></ol><h3 id="数组的其他特性">数组的其他特性</h3><ul><li><p><strong>数组是对象：</strong><br />在Java中，所有的数组类型都是对象，并且继承自<code>java.lang.Object</code> 类。</p></li><li><p><strong>多维数组：</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] matrix = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125; &#125;;<br>System.out.println(matrix.length); <span class="hljs-comment">// 输出二维数组的行数：3 </span><br>System.out.println(matrix[<span class="hljs-number">0</span>].length); <span class="hljs-comment">// 输出二维数组的第一行的列数：3</span><br></code></pre></td></tr></table></figure></p><ul><li>Java支持多维数组，通过嵌套数组的方式实现。</li></ul></li><li><p><strong>无法改变大小：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <br>list.add(<span class="hljs-number">1</span>); list.add(<span class="hljs-number">2</span>); <br>System.out.println(list.size()); <span class="hljs-comment">// 输出列表的大小：2</span><br></code></pre></td></tr></table></figure></p></li><li><p>数组一旦创建，其大小是固定的。如果需要一个可以动态调整大小的数组，可以使用ArrayList 或其他集合类。</p></li></ul><h2 id="代码实现递归版">代码实现（递归版）</h2><p>至于具体算法细节，仍然是carl所教的左闭右开和左闭右闭</p><p><strong>左闭右开</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchHelp(<span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, nums, target);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchHelp</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span>(begin == end) &#123;<br>            <span class="hljs-keyword">return</span> target == nums[begin] ? begin : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end - begin) / <span class="hljs-number">2</span> + begin;<br>        <span class="hljs-keyword">if</span>(target &lt;= nums[mid]) <span class="hljs-keyword">return</span> searchHelp(begin, mid, nums, target);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> searchHelp(mid + <span class="hljs-number">1</span>, end, nums, target);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <strong>左闭右闭</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchHelp(<span class="hljs-number">0</span>, nums.length, nums, target);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchHelp</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= end - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(begin &gt; end - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> target == nums[begin] ? begin : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end - begin) / <span class="hljs-number">2</span> + begin;<br>        <span class="hljs-keyword">if</span>(target &lt; nums[mid]) <span class="hljs-keyword">return</span> searchHelp(begin, mid, nums, target);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> searchHelp(mid , end, nums, target);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> # 二分拓展——在排序数组中查找元素的第一个和最后一个位置</p><p><ahref="https://leetcode.cn/problems/binary-search/">题目链接</a></p><p>还没做此题时，算法群中有人讨论，瞄到了“二分定位然后发散找边界”的思路，窃以为很有道理，然另一群友diss：“全是一样的就成了<spanclass="math inline">\(O(n)\)</span>了”，有道理哈。</p><p>自己做的时候的确直觉想到"二分定位然后发散"的思路，但是有意避免，于是想到两次二分分别定左右边界。下附代码，与官方题解区别在于，官方使用了一个<code>lower</code>标志位来区分左右边界，把两次二分合成一个方法。而我的代码直接写了两次，把等号换地方。记得第一次二分后把right弄回去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt;= target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left &gt;= nums.length || nums[left] != target) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">else</span> ans[<span class="hljs-number">0</span>] = left;<br>        right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt;= target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        ans[<span class="hljs-number">1</span>] = right;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="移除元素"><ahref="https://leetcode.cn/problems/remove-element/">移除元素</a></h1><p>此题貌似是力扣新手村的一道题，以前错过多次，感叹于自己的菜，于是这次还记得解法，但仍然没有一把AC，在去重的时候没有考虑好只有一个元素和空表的情况。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">while</span>(right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[right] == val) right--;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span>(nums[right] == val &amp;&amp; left &lt; right) right--;<br>            <span class="hljs-keyword">while</span>(nums[left] != val &amp;&amp; left &lt; right) left++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = temp;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>第一天打卡，希望能够坚持下去，同时笔者还在看dolphinscheduler，看不懂啊……想参加开源之夏，但是好像截止前连项目都看不懂，抓紧时间，加油加油！</p><p>(更新：想peach了，没参加成，申请书都没写完，明年一定)</p><p><strong>ps</strong>算法群里遇到一个问题，在遍历数组的时候，<code>fast &lt; nums.size()</code>就AC，<code>fast &lt;= nums.size() - 1</code>就RE，原来是因为：</p><p>vector的size方法返回的是无符号整数，减一之后不会变-1，而是变大，条件就无效了。</p><p>空vector才会碰见的坑，长见识了。</p><p>​</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
