<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode_day36</title>
    <link href="/2024/07/03/leetcode-day36/"/>
    <url>/2024/07/03/leetcode-day36/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/unique-paths/description/">62.不同路径</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/unique-paths-ii/">63.不同路径Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/integer-break/description/">343.整数拆分</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/unique-binary-search-trees/description/">96.不同的二叉搜索树</a> <span class="label label-warning">medium</span></li></ul><h1 id="不同路径">62. 不同路径</h1><p><strong>题目：</strong></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start”）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>思路：</strong></p><p>由于方向定死只能朝着目标走，不允许走回头路，所以走到一个格子只可能从其左边或上面来到，那么这就不难直接想出递推公式：</p>$$ dp[i][j] =<span class="math display">\[\begin{cases}1, &amp; \text {$i = 1 or j = 1$} \\dp[i - 1][j] + dp[i][j - 1], &amp; \text {else}\end{cases}\]</span><p>$$</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="不同路径ⅱ">63. 不同路径Ⅱ</h1><p><strong>题目：</strong></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start”）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>其实思路差不多，由于笔者追求尽可能少的改动，只加了一行代码就想过关，结果被特殊用例坑了两发WA😭，怎么障碍物会出现在起点和终点啊，落地成盒+通天河老鼋是吧🤡</p>          </div><p>仍然动态规划，只是状态转移方程要改一下，应该遍历整个地图，如果发现障碍物，就把这一格的dp置零表示此路不通，由于笔者代码有点问题，所以还另有改动，在地图边缘的格子不能无脑置1，得继承上一格数值，防止跳过了障碍物。</p><p>carl的代码也有类似思想</p><h2 id="代码-1">代码</h2><h3 id="个人代码">个人代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>(), n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> || obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">1</span>) dp[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) dp[i][j] = i == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="官解代码">官解代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = obstacleGrid.<span class="hljs-built_in">size</span>(), m = obstacleGrid.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>).<span class="hljs-built_in">size</span>();<br>        vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">f</span>(m);<span class="hljs-comment">//压缩了dp数组</span><br><br>        f[<span class="hljs-number">0</span>] = (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>);<span class="hljs-comment">//起点能不能走</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//遇障置零</span><br>                    f[j] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//非首列</span><br>                    f[j] += f[j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>利用滚动数组压缩空间，滚动数组就是上一篇只用3个变量来压缩整个dp数组的思想，抛弃掉之前不用的状态，只获取最终状态，这里也一样，从上到下的路径是继承的，而从左到右的路径是累加的。而外层大循环就是改变行，每行都会继承上一行的结果。# 343. 整数拆分</p><p><strong>题目：</strong></p><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2），并使这些整数的乘积最大化。</p><p>返回 你可以获得的最大乘积 。</p><p><strong>思路：</strong></p><p>本来该用dp的，但是数学直觉给我指了另一条路，高中学过基本不等式，有口诀为“和定积最大，积定和最小”，而此处就是“和定”，由基本不等式最值条件可知，每个数应该尽量相等（尽量是因为得是整数，不然必须相等），而拆分的数量简单一推就知道先增后减：</p><p>比如12：</p><ul><li>分为2个数6*6=36</li><li>分为3个数4 * 4 * 4 = 64</li><li>分为4个数<span class="math inline">\(3^4=81\)</span></li><li>分为5个数2 * 2 * 2 * 3 * 3 = 72</li><li>分为6个数<span class="math inline">\(2^6=64\)</span></li></ul><p>先增后减，所以从2开始一直增加拆分数，一旦积开始减少，就说明到达最值点了。</p><p><del>官解的数学证明好复杂，看起来很抽象啊，导数大题只得了6分的我看不懂，还是不等式选修秒杀更舒服</del></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//和定积最大，基本不等式定调均分</span><br>    <span class="hljs-comment">//随便举几个例子可大致知道k先增后减，存在峰值</span><br>    <span class="hljs-comment">//但均分不好实现，如10分为2233或2224，均分应该使方差最小</span><br>    <span class="hljs-comment">//逐步除法也许可以实现最均分，尝试一下</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>;k &lt;= n;k++) &#123;<span class="hljs-comment">//等分数量</span><br>            <span class="hljs-type">int</span> m = n, temp = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k;i &gt; <span class="hljs-number">0</span>;i--) &#123;<span class="hljs-comment">//已经获得的加子数量</span><br>                temp *= m / i;<br>                m -= m / i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(temp &gt; ans) ans = temp;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>均分方法蒙对了，没严格证明，至少能AC</p><h1 id="不同的二叉搜索树">96. 不同的二叉搜索树</h1><p><strong>题目：</strong></p><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>思路：</strong></p><p>有点多项式定理的感觉，<del>沉睡的高中数学之魂复燃？</del>，画图可能比较好理解，但是图书馆要闭馆了，没时间画图了。</p><p>根据其示例可以得到提示：以不同的数做根来分类讨论，以4为例</p><ul><li>若1作根，则剩余3个数形成的BST个数就是当前BST的个数总数，由示例得到为5</li><li>若2作根，则剩余2个数3、4只能在右子树，当前BST总数就是2节点BST的总数2</li><li>若3作根，则4只能在右子树，左子树是2节点BST总数2</li><li>若4作根，则1、2、3都在左子树，就是3节点BST总数，5</li></ul><p>所以4节点BST总数为5+2+2+5。</p><p>由此发散，联想多项式定理，可得状态转移方程：</p>$$ dp[i] =<span class="math display">\[\begin{cases}1, &amp; \text {$i = 0 or i = 1$} \\\sum_{root=1}^i dp[root-1]*dp[i-root], &amp; \text {$i &gt; 1$}\end{cases}\]</span><p>$$</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++) &#123;<span class="hljs-comment">//节点数</span><br>            <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;root &lt;= i;root++) &#123;<span class="hljs-comment">//谁做根</span><br>                temp += dp[root - <span class="hljs-number">1</span>] * dp[i - root];<br>            &#125;<br>            dp[i] = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day35</title>
    <link href="/2024/07/03/leetcode-day35/"/>
    <url>/2024/07/03/leetcode-day35/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/fibonacci-number/">509.斐波那契数</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/climbing-stairs/description/">70.爬楼梯</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">746.使用最小花费爬楼梯</a> <span class="label label-success">easy</span></li></ul><h1 id="斐波那契数">509. 斐波那契数</h1><p><strong>题目：</strong></p><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code>表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由<code>0</code> 和 <code>1</code>开始，后面的每一项数字都是前面两项数字的和。也就是：</p><blockquote><p>F(0) = 0，F(1) = 1</p><p>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p></blockquote><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>思路：</strong></p><p>由于是dp训练，所以不能直接递归或套公式。</p><p>递推公式题目有，直接dp，没有优化空间复杂度。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="爬楼梯">70. 爬楼梯</h1><p><strong>题目：</strong></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>思路：</strong></p><ol type="1"><li>只有45个数，打表🤓</li><li>直接dp！</li><li>套斐波那契公式🤓</li></ol><p>dp递归公式如下：</p><p><span class="math display">\[dp[n]=\begin{cases}1, &amp; \text {$n=1$} \\2, &amp; \text {$n=2$} \\dp[n-1]+dp[n-2], &amp; \text {$n&gt;3$}\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="使用最小花费爬楼梯">746. 使用最小花费爬楼梯</h1><p><strong>题目：</strong></p><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>思路：</strong></p><p>直接dp！递推公式如下：</p><p><span class="math display">\[dp[n]=\begin{cases}0, &amp; \text {$n = 1 or 0$} \\min(dp[n-1]+cost[n-1], dp[n-2]+cost[n-2]), &amp; \text {$n&gt;1$}\end{cases}\]</span></p><p>没有优化空间复杂度，感觉可有可无，优化也不复杂，具体优化方法见<ahref="https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html">代码随想录| 使用最小花费爬楼梯</a></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(cost.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(cost[<span class="hljs-number">0</span>], cost[<span class="hljs-number">1</span>]);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size() + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= cost.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[cost.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day34</title>
    <link href="/2024/07/01/leetcode-day34/"/>
    <url>/2024/07/01/leetcode-day34/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/merge-intervals/description/">56.合并区间</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/monotone-increasing-digits/">738.单调递增的数字</a> <span class="label label-warning">medium</span></li><li><a href=""></a> <span class="label label-danger">hard</span></li></ul><h1 id="合并区间">56. 合并区间</h1><p><strong>题目：</strong></p><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] =[starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p><strong>思路：</strong></p><p>与昨天的重叠区间类型问题一样，按开始点排序，有重合就合并，没重合就新维护</p><div class="note note-light">            <p>忽然诧异怎么这道题显示已解决，查看提交记录发现这道题在几个月前做过，当初WA4发才做出来结果击败5%，真是感慨</p><p>回首向来萧瑟处，也无风雨也无晴，虽然一直感觉在蹉跎人生，但实际上我还是有一点小小的进步，加油共勉！</p>          </div><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; b )</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> left = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], right = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; intervals.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt; right) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;left, right&#125;);<br>                left = intervals[i][<span class="hljs-number">0</span>];<br>                right = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>            right = <span class="hljs-built_in">max</span>(right, intervals[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;left, right&#125;);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="单调递增的数字">738. 单调递增的数字</h1><p><strong>题目：</strong></p><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y时，我们称这个整数是单调递增的。</p><p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>没做出来，做的时候脑子有点不舒服，所以歇逼了</p>          </div><p>此题局部最优策略为，如果数字本身就满足“单调递增”要求，则直接返回该数字即可，若出现反例，即高位大于低位，则将高位减1低位置9</p><p>将此局部最优策略应用至全局即可得到最优解，具体代码实现方式见注释。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>&#123;<br>        string strNum = <span class="hljs-built_in">to_string</span>(N);<br>        <span class="hljs-type">int</span> flag = strNum.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// flag用来标记赋值9从哪里开始</span><br>        <span class="hljs-comment">// 设置为超限默认值，为了防止第二个for循环在flag没有被赋值的情况下执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = strNum.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-comment">//倒序遍历数位，若连续出现高位大于低位，则连续减一高位并记录计划变为9的位数</span><br>            <span class="hljs-keyword">if</span> (strNum[i - <span class="hljs-number">1</span>] &gt; strNum[i] ) &#123;<span class="hljs-comment">//如果出现高位大于低位，则将高位减1，同时记录低位位数为flag</span><br>                flag = i;<br>                strNum[i - <span class="hljs-number">1</span>]--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = flag; i &lt; strNum.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-comment">//由于从后往前，所以最后得到的计划变9位将是最高的，把后面所有数变9只会增大数字从而得到最优解</span><br>            strNum[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span>(strNum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="监控二叉树">968. 监控二叉树</h1><p><strong>题目：</strong></p><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象</strong>。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>思路：</strong></p><p><del>不会做😭，抄了</del></p><p>由于涉及二叉树，可以套路化地想到尝试递归遍历，题目所求最少摄像头数量，最少一般是贪心或者dp，那就得分析状态，考虑局部最优全局最优或者状态之间的转移。</p><p>在这道题中，一个节点的状态有三种：放了摄像头+被覆盖+没覆盖，关于二叉树的状态容易联想到从两个子树的状态得到当前root树的状态，那么又可以想到：如果子树的根left或者right有摄像头+仅仅被覆盖+没被覆盖这三种状态，这三种状态转移到整个树的状态的方式就为：1. 如果left或right有一个没被覆盖，则root需要放置摄像头； 2.如果left或者right有一个有摄像头，则root不需要放置； 3.如果left和right都只是被覆盖，那么root需要补一个摄像头。</p><p>但这并没有取最优化，仅仅只是状态转移，所以不是dp。</p><p>dp做法官方题解和灵神的不太一样，树形dp没看懂，dp做法以后再看吧。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//0:无覆盖，1：有摄像头，2：有覆盖</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) &#123;<br>            result++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) result++;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day33</title>
    <link href="/2024/07/01/leetcode-day33/"/>
    <url>/2024/07/01/leetcode-day33/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452.用最少数量的箭引爆气球</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/non-overlapping-intervals/description/">435.无重叠区间</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/partition-labels/description/">763.划分字母区间</a> <span class="label label-warning">medium</span></li></ul><h1 id="用最少数量的箭引爆气球">452. 用最少数量的箭引爆气球</h1><p><strong>题目：</strong></p><p>有一些球形气球贴在一堵用 XY平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] =[x_start, x_end] 表示水平直径在 x_start 和x_end之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x处射出一支箭，若有一个气球的直径的开始和结束坐标为 x_start，x_end，且满足 x_start ≤ x ≤ x_end，则该气球会被 引爆 。可以射出的弓箭的数量没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p><p><strong>思路：</strong></p><p>按照直观思维，肯定要找重叠部分，再按贪心分析，局部最优是射重叠部分，全局最优是尽可能多射重叠部分来减少箭数</p><p>此时不妨画个图来分析，脑子好也可以直接想象，用线段表示气球直径范围，以下图为例，很容易看出答案是两根箭，但是我们是如何得出答案的呢，背后的依赖逻辑是什么</p><figure><img src="https://s3.bmp.ovh/imgs/2024/07/01/7513d5db99cbc545.png"alt="帮助分析线段图" /><figcaption aria-hidden="true">帮助分析线段图</figcaption></figure><p>此时发散思维，不难想到跟开始和结束点有关，此前做过类似题则更容易想到，以结束点为标准，从左往右开始射，必须照顾到最早结束的气球，否则就会漏掉，那么我们就能得到如下贪心策略：（大白话版）</p><p>按起点排序，记录气球结束点按最近的来，若结束点超过了这个最近结束点，则一支箭就不够了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//按起点排序，记录气球结束点按最近的来，若结束点超过了这个最近结束点，则一支箭就不够了</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> end = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> nextBallon = <span class="hljs-number">0</span>;<span class="hljs-comment">//新的起点</span><br>        <span class="hljs-type">int</span> arrow = <span class="hljs-number">1</span>;<span class="hljs-comment">//箭数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; points.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(end &lt; points[i][<span class="hljs-number">0</span>]) &#123;<br>                nextBallon = i;<br>                arrow++;<br>                end = points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>            end = <span class="hljs-built_in">min</span>(end, points[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arrow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="无重叠区间">435. 无重叠区间</h1><p><strong>题目：</strong></p><p>给定一个区间的集合 intervals ，其中 intervals[i] = [start_i, end_i]。返回需要移除区间的最小数量，使剩余区间互不重叠 。</p><p><strong>思路：</strong></p><p>由于之前做过一道安排活动的题目，大概意思就是有很多活动(区间)，请在不重叠的前提下安排尽可能多的活动。与此题很像</p><p>安排活动题就是按结束时间从早到晚排序，先安排早的，这样就有局部最优：留出更多的时间给之后的活动，如果结束时间相同，则为了多，选择更短的活动，以留出更多时间给更早的活动</p><p>那么这道题也可以迁移这个策略，移除最少就是保留最多嘛。</p><p>这道题比较经典，carl给了很多思路，建议阅读：<ahref="https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 无重叠区间</a></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] == b[<span class="hljs-number">1</span>] ? a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>] : a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">//移除最少那就保留最多，移除长的，保留短的</span><br>    <span class="hljs-comment">//保留最多就要流出足够多的时间给后面的区间，所以结束时间要早</span><br>    <span class="hljs-comment">//那么应该按结束时间排序，如果结束相同，那么选择开始时间最晚的</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> save = <span class="hljs-number">1</span>;<span class="hljs-comment">//保留的活动数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; intervals.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &lt; end) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                save++;<br>                end = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - save;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="划分字母区间">763. 划分字母区间</h1><p><strong>题目：</strong></p><p>给你一个字符串 s。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是s 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><p><strong>思路：</strong></p><p>一开始有点懵，然后迁移之前的思路想到可以将字母出现的范围视作区间，那就又成了区间不重叠问题。</p><p>但这个思路编码有点复杂，速度也不快</p><p>carl的直截了当思路简直优雅👍:</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20201222191924417.png"alt="太巧妙辣！" /><figcaption aria-hidden="true">太巧妙辣！</figcaption></figure><h2 id="代码-2">代码</h2><h3 id="个人14代码">个人14%代码😭</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//尽可能多的片段，且是分割，是连续的，只在前面出现的字母，统计各字母首次和默次出现构成区间</span><br>    <span class="hljs-comment">//按区间开始排序，目的是分出尽可能多的组，原理相同</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; points;<span class="hljs-comment">//存各字母的区间</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-comment">//获取s中各字母的区间</span><br>        points = <span class="hljs-built_in">getSection</span>(s);<br>        <span class="hljs-comment">//写代码能力太弱，有点费时间啊……</span><br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> right = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; points.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; right) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>                left = points[i][<span class="hljs-number">0</span>];<br>            &#125;<br>            right = <span class="hljs-built_in">max</span>(right, points[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">getSection</span>(string s) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">alpha</span>(<span class="hljs-number">26</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>));<span class="hljs-comment">//全部字母都留出空</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(alpha[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">-1</span>) alpha[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>] = i;<span class="hljs-comment">//起点只记一次</span><br>            alpha[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>] = i;<span class="hljs-comment">//终点不断更新</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; alpha.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(alpha[i][<span class="hljs-number">0</span>] != <span class="hljs-number">-1</span>) res.<span class="hljs-built_in">push_back</span>(alpha[i]);<span class="hljs-comment">//结果只记录出现过的</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl优雅代码">carl优雅代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        <span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// i为字符，hash[i]为字符出现的最后位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 统计每一个字符最后出现的位置</span><br>            hash[S[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            right = <span class="hljs-built_in">max</span>(right, hash[S[i] - <span class="hljs-string">&#x27;a&#x27;</span>]); <span class="hljs-comment">// 找到字符出现的最远边界</span><br>            <span class="hljs-keyword">if</span> (i == right) &#123;<br>                result.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day31</title>
    <link href="/2024/06/30/leetcode-day31/"/>
    <url>/2024/06/30/leetcode-day31/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/gas-station/description/">134.加油站</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/candy/description/">135.分发糖果</a> <span class="label label-danger">hard</span></li><li><ahref="https://leetcode.cn/problems/lemonade-change/description/">860.柠檬水找零</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406.根据身高重建队列</a> <span class="label label-warning">medium</span></li></ul><h1 id="加油站">134. 加油站</h1><p><strong>题目：</strong></p><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1个加油站需要消耗汽油 cost[i]升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 gas 和 cost，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。如果存在解，则 保证 它是 唯一 的。</p><p><strong>思路：</strong></p><p>贪心算法是从局部最优一直推到整体最优，那么对于解从起点开始的每一小段，肯定油都是有剩的，即∑gas[i]- ∑cost[i] &gt; 0，如果有一段内的油少于需要，则肯定不是解从开头的段</p><p>开一个数组loss表示loss[i] = gas[i] -cost[i]，肯定从正数开始，如果加到中间变负了，证明从开始到这里都不行，换下一站做起点，不断搜索即可。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">loss</span><span class="hljs-params">((<span class="hljs-type">int</span>)gas.size())</span></span>;<br>        <span class="hljs-type">int</span> sumg = <span class="hljs-number">0</span>, sumc = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; gas.<span class="hljs-built_in">size</span>();i++) &#123;<br>            loss[i] = gas[i] - cost[i];<br>            sumg += gas[i];<br>            sumc += cost[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sumg &lt; sumc) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//油不够，直接-1</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; loss.<span class="hljs-built_in">size</span>()) &#123;<br>            sum += loss[i++];<br>            <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>) &#123;<br>                sum = <span class="hljs-number">0</span>;<br>                ans = i;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i == ans) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//回到起点</span><br>            <span class="hljs-keyword">if</span>(ans &gt; <span class="hljs-number">0</span> &amp;&amp; i == loss.<span class="hljs-built_in">size</span>()) i = <span class="hljs-number">0</span>;<span class="hljs-comment">//循环，注意起点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="分发糖果">135. 分发糖果</h1><p><strong>题目：</strong></p><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><p><strong>思路：</strong></p><p>个人击败5%思路：</p><ul><li>如果相比上一个更大，则糖果比上一个人多一个，这没得说</li><li>如果相比上一个相同，则先置为1，后续再操作</li><li>如果更小，此时需要往前维护糖果大小关系，细节见代码</li></ul><p>carl思路：</p><p>两次遍历，分别维护两种相邻情况的糖果大小关系，顺序维护递增的加一关系，倒序维护递减的关系，巧妙啊</p><h2 id="代码-1">代码</h2><h3 id="个人5代码">个人5%代码😭</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//需要注意的就是1234321这种例子，不能想当然按照两格滑动窗口解题，也不能左右同时走</span><br>    <span class="hljs-comment">//往前，如果比前一个小，则置位1，同时维护之前的大小关系，直到遇到下降</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candys</span><span class="hljs-params">(ratings.size())</span></span>;<br>        candys[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; ratings.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candys[i] = candys[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ratings[i] == ratings[i - <span class="hljs-number">1</span>]) candys[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ratings[i] &lt; ratings[i - <span class="hljs-number">1</span>]) &#123;<br>                candys[i] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(candys[i - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)  &#123;<span class="hljs-comment">//维护先前的大小关系，必须倒着加回去</span><br>                <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>) &#123;<br>                    candys[j]++;<br>                    <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; candys[j] &lt; candys[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; ratings[j] &gt;= ratings[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span>;<br>                    j--;<br>                &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; candys.<span class="hljs-built_in">size</span>();i++) sum += candys[i];<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl代码">carl代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candyVec</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 从前向后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candyVec[i] = candyVec[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从后向前</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] ) &#123;<br>                candyVec[i] = <span class="hljs-built_in">max</span>(candyVec[i], candyVec[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 统计结果</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candyVec.<span class="hljs-built_in">size</span>(); i++) result += candyVec[i];<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="柠檬水找零">860. 柠檬水找零</h1><p><strong>题目：</strong></p><p>在柠檬水摊上，每一杯柠檬水的售价为 5美元。顾客排队购买你的产品，（按账单 bills支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 bills ，其中 bills[i] 是第 i位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false。</p><p><strong>思路：</strong></p><p>很简单，记住5块有多少，10块有多少，遇到10块补5块，遇到20优先给出10块，没有10块就全给5块，中间给不出就false，能找完就true</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>&#123;<br>        <span class="hljs-type">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : bills) &#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">5</span>) five++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">10</span>) ten++, five--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ten == <span class="hljs-number">0</span>) five -= <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">else</span> ten--, five--;<br>            <span class="hljs-keyword">if</span>(ten &lt; <span class="hljs-number">0</span> || five &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="根据身高重建队列">406. 根据身高重建队列</h1><p><strong>题目：</strong></p><p>假设有打乱顺序的一群人站成一个队列，数组 people表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第i 个人的身高为 hi ，前面 <strong>正好</strong> 有 ki 个身高大于或等于 hi的人。</p><p>请你重新构造并返回输入数组 people所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj,kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p><strong>思路：</strong></p><p>有两个标准，不难想到应该先用身高排序，由高到低，其中相同身高的k由低到高，因为这样才能更便捷地调换位置，满足k的需要。</p><p>然后按照k来插入即可。注意使用list，底层由链表实现，插入效率较高，这题对于语法要求还有点高，得多熟悉这些不那么常用的API。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; p1, vector&lt;<span class="hljs-type">int</span>&gt; &amp; p2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> p1[<span class="hljs-number">0</span>] == p2[<span class="hljs-number">0</span>] ? p1[<span class="hljs-number">1</span>] &lt; p2[<span class="hljs-number">1</span>] : p1[<span class="hljs-number">0</span>] &gt; p2[<span class="hljs-number">0</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que; <span class="hljs-comment">// list底层是链表实现，插入效率比vector高的多</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 插入到下标为position的位置</span><br>            std::list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = que.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">while</span> (position--) &#123;<br>                it++;<br>            &#125;<br>            que.<span class="hljs-built_in">insert</span>(it, people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(que.<span class="hljs-built_in">begin</span>(), que.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day30</title>
    <link href="/2024/06/22/leetcode-day30/"/>
    <url>/2024/06/22/leetcode-day30/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/jump-game/description/">55.跳跃游戏</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/jump-game-ii/description/">45.跳跃游戏II</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/">1005.K次取反后最大化的数组和</a> <span class="label label-success">easy</span></li></ul><h1 id="买卖股票的最佳时机ii">122. 买卖股票的最佳时机II</h1><p><strong>题目：</strong></p><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><p><strong>思路：</strong></p><p>披着medium皮的easy题，统计所有上升就好了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) res += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="跳跃游戏">55. 跳跃游戏</h1><p><strong>题目：</strong></p><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回false 。</p><p><strong>思路：</strong></p><p>从终点倒着走，不断找能跳到当前的点，并将其更新为新的终点，如果最后终点来到了0，就找到了，反之则没有</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> end = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//4</span><br>        <span class="hljs-type">int</span> newend = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;<span class="hljs-comment">//3</span><br>        <span class="hljs-keyword">while</span>(newend &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(end - newend &gt; nums[newend]) newend--;<br>            <span class="hljs-keyword">else</span> &#123;<br>                end = newend;<br>                newend--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(end == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="跳跃游戏ii">45.跳跃游戏II</h1><p><strong>题目：</strong></p><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p><p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><ul><li>0 &lt;= j &lt;= nums[i]</li><li>i + j &lt; n</li></ul><p>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n -1]。</p><p><strong>思路：</strong></p><p>贪心就是贪个最远能到达的距离，当前在一个地方，这个地方前面有一个范围，范围呢每个点又有范围，找的就是有最远范围的下一个点。</p><p>写得感觉有点冗余，过用例的时候错一个改一条，突然就AC了，没细察。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> current = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(current &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> currentMaxRange = current + nums[current];<br>            <span class="hljs-keyword">if</span>(currentMaxRange &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> nextStepMaxRange = currentMaxRange;<br>            <span class="hljs-type">int</span> nextStep = current;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = current + <span class="hljs-number">1</span>;i &lt;= currentMaxRange;i++) &#123;<br>                <span class="hljs-keyword">if</span>(nextStepMaxRange &lt; i + nums[i]) &#123;<br>                    nextStepMaxRange = i + nums[i];<br>                    nextStep = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nextStepMaxRange &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans + <span class="hljs-number">2</span>;<br>            current = nextStep;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="k次取反后最大化的数组和">1005.K次取反后最大化的数组和</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p><ul><li>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。</li></ul><p>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p><p>以这种方式修改数组后，返回数组 可能的最大和 。</p><p><strong>思路：</strong></p><p>见<ahref="https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html">代码随想录</a></p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp);       <span class="hljs-comment">// 第一步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 第二步</span><br>            <span class="hljs-keyword">if</span> (A[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>) &#123;<br>                A[i] *= <span class="hljs-number">-1</span>;<br>                K--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) A[A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>; <span class="hljs-comment">// 第三步</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) result += a;        <span class="hljs-comment">// 第四步</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day29</title>
    <link href="/2024/06/21/leetcode-day29/"/>
    <url>/2024/06/21/leetcode-day29/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/assign-cookies/description/">455.分发饼干</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/wiggle-subsequence/description/">376.摆动序列</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/maximum-subarray/description/">53.最大子数组和</a> <span class="label label-warning">medium</span></li></ul><h1 id="分发饼干">455. 分发饼干</h1><p><strong>题目：</strong></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j分配给孩子 i，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>思路：</strong></p><p>见<ahref="https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 分发饼干</a></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123;<br>                result++;<br>                index--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="摆动序列">376. 摆动序列</h1><p><strong>题目：</strong></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7,3) 是正负交替出现的。</p><p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5]不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度。</p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 1000</li><li>0 &lt;= nums[i] &lt;= 1000</li></ul><p><strong>思路：</strong></p><p>符号转换一次就记一次数。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sign = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(nums[i] - nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                sign = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                sign = <span class="hljs-number">0</span>;<br>            &#125;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最大子数组和">53. 最大子数组和</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><p><strong>思路：</strong></p><p>见<ahref="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 最大子数组和</a></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = INT_MIN;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            sum += nums[i];<br>            res = <span class="hljs-built_in">max</span>(res, sum);<br>            <span class="hljs-keyword">if</span>(sum &lt;= <span class="hljs-number">0</span>) sum = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day28</title>
    <link href="/2024/06/19/leetcode-day28/"/>
    <url>/2024/06/19/leetcode-day28/</url>
    
    <content type="html"><![CDATA[<p>期末复习压力大，简单写写，暑假再补</p><p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/non-decreasing-subsequences/description/">491.非递减子序列</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/permutations/description/">46.全排列</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/permutations-ii/description/">47.全排列Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/reconstruct-itinerary/description/">332.重新安排行程</a> <span class="label label-danger">hard</span></li><li><a href=""></a></li><li><a href=""></a></li></ul><h1 id="非递减子序列">491. 非递减子序列</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素。你可以按 任意顺序 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>思路：</strong></p><p>难点在于去重，例如[1,2,3,1,1]这样的用例，就要注意不要在解空间树第一层重复取1，最后得到重复的[1,1]和[1,1,1]，解空间树单层去重方法为在单层递归中创建一个作用域仅限于单层递归函数内的记录变量数组，用过就记录，之后再用就跳过，具体代码实现方法见下</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">-101</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; nums, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(<span class="hljs-number">210</span>, <span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">//这就是作用域仅在单层的记录变量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; pre) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[nums[i] + <span class="hljs-number">100</span>]) <span class="hljs-keyword">continue</span>;<br>            used[nums[i] + <span class="hljs-number">100</span>] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            pre = nums[i];<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            pre = !temp.<span class="hljs-built_in">empty</span>() ? temp.<span class="hljs-built_in">back</span>() : <span class="hljs-number">-101</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="全排列">46. 全排列</h1><p><strong>题目：</strong></p><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以按任意顺序 返回答案。</p><p><strong>思路：</strong></p><p>在程序设计课上写那么久，之前一直踩坑全局used，这下终于能尽情全局used了，手速题，10min秒了</p><p>carl哥的方法明明和我一样，只是把used下传了，但就是快，也许是语法因素？</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(used[i]) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        used.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">backtrack</span>(nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="全排列ⅱ">47. 全排列Ⅱ</h1><p><strong>题目：</strong></p><p>给定一个可包含重复数字的序列 nums ，按任意顺序返回所有不重复的全排列。</p><p><strong>思路：</strong></p><p>又是去重，由于任意顺序，所以可以排序，对于[1,1,2]这样的用例，需要注意的就是不要来两个[1,1,2]，光把前两个1交换了。</p><p>去重标准可设为：相同元素仅允许最先一个作为开头，之后的相同元素不可做开头，但可做后缀。</p><p>翻译成代码就是<code>if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue;</code></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[i]) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        used.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">backtrack</span>(nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="重新安排行程">332. 重新安排行程</h1><p><strong>题目：</strong></p><p>给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi]表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><p>所有这些机票都属于一个从JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p><p>例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。假定所有机票至少存在一种合理的行程。且<strong>所有的机票 必须都用一次 且只能用一次</strong>。</p><p><strong>思路：</strong></p><p>首先看懂题目，类似哥尼斯堡七桥问题，也就是欧拉回路，就是要找到一条路，能把所有路走一遍且不重复，而此题还额外要求字典序最小。</p><p>那么可以直观得到如下思路：</p><ol type="1"><li>找到当前节点能够去到的 所有 下一个节点，按字典序由小到大排好序</li><li>从最小字典序节点开始dfs，如果最后没能用光机票而走入死路，则换次小字典序节点继续寻找，直到找到。</li></ol><p>思路其实不难，主要在于代码实现，carl合理选择了适当的容器来做，代码时间打败98%，但我这次独立完成，主要记录个人解题思路，目前最优解仍为carl的题解，详见：<ahref="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E6%80%9D%E8%B7%AF">代码随想录| 重新安排行程</a>。</p><p>对于我的思路，具体代码实现遇到的问题见代码注释，直接叙述效果不佳</p><h2 id="代码-3">代码</h2><h3 id="个人代码可怜的5">个人代码（可怜的5%😭）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<span class="hljs-comment">//存欧拉道路</span><br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<span class="hljs-comment">//记录哪些tickets的下标已经被用过，即用过的机票</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt; &amp;tickets, string start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == tickets.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//根据start得到接下来的目标，选取可用的机票，按字典序从小到大排列</span><br>        <span class="hljs-comment">//按下标存方便used记录，按名称存不好记录哪些机票用过了，后续会出问题，于是两个合在一起存，排序自定义</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, string&gt;&gt; nextPort;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; tickets.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(!used[i] &amp;&amp; tickets[i][<span class="hljs-number">0</span>] == start) &#123;<br>                nextPort.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, string&gt;(i, tickets[i][<span class="hljs-number">1</span>]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nextPort.<span class="hljs-built_in">begin</span>(), nextPort.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-comment">//遍历接下来的机场，如果找到答案，则直接返回，如果没有，则换次小字典序机场再找</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nextPort.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(used[nextPort[i].first]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//超时尝试剪枝，对于相同机票，可失败后跳过后续所有相同机票</span><br>            <span class="hljs-comment">//剪枝后成功AC，但用时仅超过5%，丢人</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nextPort[i].second == nextPort[i - <span class="hljs-number">1</span>].second) <span class="hljs-keyword">continue</span>;<br>            used[nextPort[i].first] = <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nextPort[i].second);<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtrack</span>(tickets, nextPort[i].second)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            used[nextPort[i].first] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果走到这一步，证明走错，返回false</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, string&gt; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, string&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.second.<span class="hljs-built_in">compare</span>(b.second) &lt; <span class="hljs-number">0</span>;<span class="hljs-comment">//按照字典序排序</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        used.<span class="hljs-built_in">resize</span>(tickets.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<span class="hljs-comment">//记录哪些机票已经被用过</span><br>        path.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<span class="hljs-comment">//起点不会被加入，所以提前加入</span><br>        <span class="hljs-built_in">backtrack</span>(tickets, <span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl的优质代码个人注释版">carl的优质代码个人注释版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//才注意到carl哥把自己实现的方法都private了，细节！</span><br><span class="hljs-comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span><br>unordered_map&lt;string, map&lt;string, <span class="hljs-type">int</span>&gt;&gt; targets;<span class="hljs-comment">// 起点 -&gt; (目的地，剩余可飞次数)</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == ticketNum + <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//找齐了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//回传成功信号，也算剪枝了吧，不用再遍历后续的target了</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (pair&lt;<span class="hljs-type">const</span> string, <span class="hljs-type">int</span>&gt;&amp; target : targets[result[result.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]]) &#123;<span class="hljs-comment">//细节引用，result[result.size() - 1]就是前一个机场，targets[result[result.size() - 1]]就是要遍历的目的地集合</span><br>        <span class="hljs-keyword">if</span> (target.second &gt; <span class="hljs-number">0</span> ) &#123; <span class="hljs-comment">// 该路线还有余票</span><br>            result.<span class="hljs-built_in">push_back</span>(target.first);<span class="hljs-comment">//回溯模板，看不懂只能去复习了</span><br>            target.second--;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(ticketNum, result)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            result.<span class="hljs-built_in">pop_back</span>();<br>            target.second++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        targets.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//细节clear，防止内存里有脏东西</span><br>        vector&lt;string&gt; result;<span class="hljs-comment">//没开成员变量，提高速度，见 全排列的疑惑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;string&gt;&amp; vec : tickets) &#123;<span class="hljs-comment">//vec就是每张票了，俩元素，起点[0]跟终点[1]</span><br>            targets[vec[<span class="hljs-number">0</span>]][vec[<span class="hljs-number">1</span>]]++; <span class="hljs-comment">// 这里就提前给每个目的地集合按字典序排好序了，之后从头遍历就行</span><br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>); <span class="hljs-comment">// 手动加入起始机场</span><br>        <span class="hljs-built_in">backtracking</span>(tickets.<span class="hljs-built_in">size</span>(), result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="n皇后">51. N皇后</h1><p><strong>题目：</strong></p><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code>个皇后放置在 <code>n×n</code>的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong>的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code>分别代表了皇后和空位。</p><p>提示：</p><p><code>1 &lt;= n &lt;= 9</code></p><p><strong>思路：</strong></p><p>按图的深度优先搜索回溯查找所有放置可能，结束条件就是放到了最后一行仍然合法，放一个就在当前基础上往下搜索，写好判断合法函数，注意有两条斜线，经典问题所以不太难，披着hard的中等题吧。</p><h2 id="代码-4">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<span class="hljs-comment">//存放所有解</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, vector&lt;string&gt; &amp;board)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(row == n) &#123;<span class="hljs-comment">//最后一行放下去了，来到了界外</span><br>            ans.<span class="hljs-built_in">push_back</span>(board);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isVaild</span>(n, row, i, board)) <span class="hljs-keyword">continue</span>;<br>            board[row][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            <span class="hljs-built_in">backtrack</span>(n, row + <span class="hljs-number">1</span>, board);<br>            board[row][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">//尝试下一个放置位</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isVaild</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, vector&lt;string&gt; &amp;board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r &lt; n;r++) &#123;<span class="hljs-comment">//检测[row, col]有无同列Queen</span><br>            <span class="hljs-keyword">if</span>(board[r][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> r = row, c = col;<br>        <span class="hljs-keyword">while</span>(r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//检测左上斜线有无Queen</span><br>            <span class="hljs-keyword">if</span>(board[r--][c--] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        r = row, c = col;<br>        <span class="hljs-keyword">while</span>(r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; n) &#123;<span class="hljs-comment">//检测右上斜线有无Queen</span><br>            <span class="hljs-keyword">if</span>(board[r--][c++] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">board</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        <span class="hljs-built_in">backtrack</span>(n, <span class="hljs-number">0</span>, board);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="解数独">37. 解数独</h1><p><strong>题目：</strong></p><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 遵循如下规则：</p><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3宫内只能出现一次。（请参考示例图）</li></ul><p>数独部分空格内已填入了数字，空白格用 '.' 表示。</p><p>示例一：</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/202011171912586.png"alt="示例一" /><figcaption aria-hidden="true">示例一</figcaption></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],<br><br>[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],<br><br>[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br><br>输出：[[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>],<br><br>[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>],<br><br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>],<br><br>[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],<br><br>[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],<br><br>[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],<br><br>[<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>],<br><br>[<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],<br><br>[<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br><br>解释：输入的数独如上图所示，唯一有效的解决方案如下所示：<br><br>![answer](https://code-thinking<span class="hljs-number">-1253855093.</span>file.myqcloud.com/pics/<span class="hljs-number">20201117191340669.</span>png)<br><br>图源：[代码随想录](https://programmercarl.com/<span class="hljs-number">0037.</span><span class="hljs-comment">%E8%A7%A3%E6%95%B0%E7%8B%AC.html#%E6%80%9D%E8%B7%AF)</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><div class="note note-light">            <p>没写出来，想着用n皇后的思路一个一个回溯暴力填的，结果一堆bug😭</p><p>记录一下错误思路：在回溯函数里我传入了上一个被填位置的row和col，想着每次向下递归就能知道上次在哪里，结果会出现：一行填到最后一个没法填了，退回去清空倒数第二格后再跳过把最后一格填了，留着空格子不管直接下一行……</p><p>问题出在返回false的时机上，其实到没法填的时候就已经可以返回false了，然后会到上一格接着试下一个数字。</p>          </div><p>这道题回溯没有单独设置终止条件，如果有传参的话也许可以加一条到了8行9列就返回，不过也可以不加，循环跑完自然就会结束。</p><h2 id="代码-5">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//先行再列，逐个试错</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r &lt; <span class="hljs-number">9</span>;r++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">9</span>;i++) &#123;<span class="hljs-comment">//先填满row行</span><br>                <span class="hljs-keyword">if</span>(board[r][i] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">9</span>;j++) &#123;<span class="hljs-comment">//为(r, i)尝试所有可能数字</span><br>                    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isValid</span>(board, r, i, j)) <span class="hljs-keyword">continue</span>;<br>                    board[r][i] = <span class="hljs-string">&#x27;0&#x27;</span> + j;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtrack</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    board[r][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//没得填了，返回false</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp; board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;c &lt; <span class="hljs-number">9</span>;c++) <span class="hljs-keyword">if</span>(board[row][c] == <span class="hljs-string">&#x27;0&#x27;</span> + num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r &lt; <span class="hljs-number">9</span>;r++) <span class="hljs-keyword">if</span>(board[r][col] == <span class="hljs-string">&#x27;0&#x27;</span> + num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = row / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;r &lt; (row / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)*<span class="hljs-number">3</span>;r++) &#123;<span class="hljs-comment">//宫格</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c = col / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;c &lt; (col / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)*<span class="hljs-number">3</span>;c++) &#123;<br>                <span class="hljs-keyword">if</span>(board[r][c] == <span class="hljs-string">&#x27;0&#x27;</span> + num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">backtrack</span>(board);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day27</title>
    <link href="/2024/06/18/leetcode-day27/"/>
    <url>/2024/06/18/leetcode-day27/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/restore-ip-addresses/description/">93.复原IP地址</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/subsets/description/">78.子集</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集Ⅱ</a><span class="label label-warning">medium</span></li></ul><h1 id="复原ip地址">93. 复原IP地址</h1><p><strong>题目：</strong></p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255之间组成，且不能含有前导 0），整数之间用 '.' 分隔。</p><p>例如："0.1.2.201" 和 "192.168.1.1" 是 <strong>有效</strong> IP地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是<strong>无效</strong> IP 地址。 给定一个只包含数字的字符串 s，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP地址</strong>，这些地址可以通过在 s 中插入 '.' 来形成。你<strong>不能</strong> 重新排序或删除 s 中的任何数字。你可以按<strong>任何</strong> 顺序返回答案。</p><p><strong>思路：</strong></p><p>回溯做了几天，对于简单的解空间树怎么分支比较熟悉了，这题就先按长度从1到3分割，然后下传起点，如果第四段仍然合法，则找到一个答案，不断递归回溯寻找所有答案即可。</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933.png"alt="解空间树.图源：代码随想录" /><figcaption aria-hidden="true">解空间树.图源：<ahref="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E6%80%9D%E8%B7%AF">代码随想录</a></figcaption></figure><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    string temp;<br>    <span class="hljs-type">int</span> seg = <span class="hljs-number">4</span>;<span class="hljs-comment">//剩余段数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(seg &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(seg == <span class="hljs-number">0</span> &amp;&amp; begin &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() - i &gt; seg * <span class="hljs-number">3</span> &amp;&amp; i - begin &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//后续太多，直接剪枝\提前判断位数剪枝</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, begin, i)) &#123;<br>                <span class="hljs-keyword">if</span>(begin &gt; <span class="hljs-number">0</span>) temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                temp += <span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + begin, s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>                seg--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">backtrack</span>(s, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span>(!temp.<span class="hljs-built_in">empty</span>() &amp;&amp; temp.<span class="hljs-built_in">back</span>() != <span class="hljs-string">&#x27;.&#x27;</span>) temp.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">if</span>(!temp.<span class="hljs-built_in">empty</span>()) temp.<span class="hljs-built_in">pop_back</span>();<br>            seg++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &lt; end &amp;&amp; s[begin] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(begin &lt;= end) &#123;<br>            num *= <span class="hljs-number">10</span>;<br>            num += s[begin++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= num &amp;&amp; num &lt;= <span class="hljs-number">255</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">backtrack</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="子集">78. 子集</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> ，数组中的元素<strong>互不相同</strong>。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 <strong>任意顺序</strong>返回解集。</p><p><strong>思路：</strong></p><p>也是很容易套上模板的回溯，不过<strong>不能不求甚解依赖模板</strong>，还是要想清楚代码逻辑。这题是求子集，高中就学过n个元素的集合有2^n个子集，虽然跟这没啥关系，不过可以认识到求子集就是求元素个数从0~n的关于全集nums的组合，所以可以分别求长度为i，i从0到n，的组合，那就是从nums里抓i个的组合，就变成了该题的上一题：<ahref="https://leetcode.cn/problems/combinations/">77. 组合</a>了。</p><div class="note note-light">            <p>对于错误思路的反思：</p><p>注意到该题的tag里有<strong>位运算</strong>字样，昨天做错的题目里我也尝试使用位运算模拟<code>bool used[]</code>来记录哪些数字已经被使用过，但实际上是多余的。今天又看见位运算，由于其出现在tag里，所以深信不疑，再次尝试，WA，去掉后，AC。下面逐条分析错误核心，搞清楚什么时候用used记录用过，什么时候不用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<span class="hljs-comment">//此处i从begin开始，已经与之前的结果隔开</span><br>    <span class="hljs-keyword">if</span>(used &gt;&gt; nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//这句等同于：如果nums[i]在之前用过就跳过，但此题nums中无重复元素，所以之前出现的元素之后肯定没出现过，多余</span><br>    used |= <span class="hljs-number">1</span> &lt;&lt; nums[i];<span class="hljs-comment">//在used的第nums[i]位置一</span><br>    temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>, len);<br>    temp.<span class="hljs-built_in">pop_back</span>();<br>    used &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; nums[i]);<span class="hljs-comment">//第nums[i]位复位</span><br>&#125;<br></code></pre></td></tr></table></figure><p>看完发现，used的确多余，但好像没有影响啊，其实WA原因在于<code>used &gt;&gt; nums[i] % 2</code>，%运算符优先级高于&gt;&gt;，所以错了。</p><p>当然，改了还是会错，nums里有负数，这样就越来越复杂了。</p>          </div><h2 id="代码-1">代码</h2><p><strong>第一版</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == len) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>, len);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= nums.<span class="hljs-built_in">size</span>();i++) &#123;<br><br>            <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>, i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p><strong>carl的解</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(temp);<span class="hljs-comment">//提前</span><br>        <span class="hljs-keyword">if</span>(begin &gt;= nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="子集ⅱ">90. 子集Ⅱ</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums，其中可能包含<strong>重复元素</strong>，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按<strong>任意顺序</strong> 排列。</p><p><strong>思路：</strong></p><p>与上一题相比多了重复元素，相当于[1,2,2]的子集注意别回溯出两个[1,2]，可以采用昨天<ahref="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">40.组合总和</a>的相同去重思路。在昨天的blog中已经提到不能简单用used来尝试去重。所以还是乖乖用carl的写法，附图carl的解空间树：</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000918.png"alt="子集Ⅱ解空间树,图源：代码随想录 | 子集Ⅱ" /><figcaption aria-hidden="true">子集Ⅱ解空间树,图源：<ahref="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF">代码随想录| 子集Ⅱ</a></figcaption></figure><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(temp);<br>        <span class="hljs-keyword">if</span>(begin &gt;= nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-comment">//使用这条的前提是要排序哦，不然相同的不挨在一起就麻烦了</span><br>            <span class="hljs-keyword">if</span>(i &gt; begin &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day26</title>
    <link href="/2024/06/17/leetcode-day26/"/>
    <url>/2024/06/17/leetcode-day26/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/combination-sum/description/">39.组合总和</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/combination-sum-ii/description/">40.组合总和Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/palindrome-partitioning/description/">131.分割回文串</a> <span class="label label-warning">medium</span></li></ul><h1 id="组合总和">39. 组合总和</h1><p><strong>题目：</strong></p><p>给你一个<strong>无重复元素</strong>的整数数组 <code>candidates</code>和一个目标整数 <code>target</code> ，找出 <code>candidates</code>中可以使数字和为目标数 <code>target</code> 的 所有<strong>不同组合</strong> ，并以列表形式返回。你可以按<strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以<strong>无限制重复被选取</strong>。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于<code>150</code> 个。</p><p><strong>思路：</strong></p><p>递归挨个选取就行，选了一个之后递归下一个，起点不变，如果和到了target就加入答案，可以在下一步递归前判断当前值是否已经过大了，过大则跳过实现剪枝。比较简单</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidate, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; candidate.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(candidate[i] &gt; target) <span class="hljs-keyword">continue</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(candidate[i]);<br>            <span class="hljs-built_in">backtrack</span>(candidate, target - candidate[i], i);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-keyword">if</span>(candidates.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">backtrack</span>(candidates, target, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="组合总和ⅱ">40. 组合总和Ⅱ</h1><p><strong>题目：</strong></p><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数<code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为<code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用<strong>一次</strong> 。</p><p><strong>注意</strong>：解集不能包含重复的组合。</p><p><strong>提示:</strong></p><p><code>1 &lt;= candidates.length &lt;= 100</code></p><p><code>1 &lt;= candidates[i] &lt;= 50</code></p><p><code>1 &lt;= target &lt;= 30</code></p><p><strong>思路：</strong></p><p>难点主要在于去重，下面举个例子来快速直观体会这道题要去什么重</p><p>对于示例：<code>[10,1,1,7,6,1,5]</code>、<code>target = 8</code>，正确结果应该是<code>[[1,1,1,5],[1,1,6],[1,7]]</code>。题目中<strong>candidate中的每个数字只能用一次</strong>是关键，勿错误理解为每种数字只能用一次，示例<code>[10,1,1,7,6,1,5]</code>中有3个<code>1</code>，当<strong>选中第一个<code>1</code>作为解成员之一</strong>递归下去的时候，由于之前无1，所以已有的解中肯定无1，后面的两个<code>1</code>仍然可用，由答案可见，选中第一个<code>1</code>递归下去已经可以得到全部解了。</p><p>那么<strong>选中第二个<code>1</code>作为解成员之一</strong>递归下去后，后面还有一个<code>1</code>，此时<strong>含有两个<code>1</code>的解</strong>已经出现过了，此时需要去重。</p><p>由上可看出不能简单使用used来阻止使用使用过的下标，因为第一个1把所有解得到后，回溯取消操作会开放used，后面的1又会变得可用，去重失败</p><p>carl哥的代码思路按我理解可以叙述为：<span class="label label-danger">重复元素只能由排前面的重复元素使用</span>，对于上面的示例，就是含有多个1的解只能由第一个1的递归分支得到，后面的如果还是1就不能在解里出现1。</p><p><strong>排前面的重复</strong>即对应carl哥说法的<strong>前一个树枝</strong>，即前一个重复元素的解空间树分支。</p><div class="note note-light">            <p>又瞟了题解才做出来，WA了4发😭😭😭</p><p>脑子抽了没看见<code>1 &lt;= candidates.length &lt;= 100</code>，还乐呵呵地用位运算当used[]用来记录哪些下标被用了，左移右移老半天跟二傻子似的，结果不仅位运算爆longlong，而且用used记录本身就是脱裤子放屁，因为我回溯传了起点begin……</p>          </div><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidate, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; candidate.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(candidate[i] &gt; target) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(i &gt; begin &amp;&amp; candidate[i] == candidate[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//去重关键</span><br>            temp.<span class="hljs-built_in">push_back</span>(candidate[i]);<br>            <span class="hljs-built_in">backtrack</span>(candidate, target - candidate[i], i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-keyword">if</span>(candidates.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtrack</span>(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="分割回文串">131. 分割回文串</h1><p><strong>题目：</strong></p><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回s 所有可能的分割方案。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>没做出来，贴出失败思路：</p><p>分割子串，想到之前做的有关题目了，至少分割操作还是比较熟悉，用迭代器构造新串就好，从首开始分割，分割长度逐渐递增，也就是回溯中的那个for循环，每个分割长度在分割前判断是否是回文串，如果是回文串就分割，不是就接着增大分割长度。</p><p>然后就卡了……没记住或者说想另辟蹊径结果弄巧成拙，没有像模板那样接着回溯下一种可能并取消当前轮次操作继续for循环。</p>          </div><p>接下来是正确思路：</p><p>仍然按照回溯模板，理清递归思路： 1. 递归参数与返回值： 返回值void，参数应该是分割起点，确保能够递归下去接着分割之后的子串 2.递归终止条件，如果真的分割到结尾，那么该条递归调用路线就是正确的，此时temp中即为一个答案，标准就是起点超过了终点，begin大于了string的长度3. 递归操作：逐个尝试分割长度，合法就接着分割，不合法就跳过</p><p>carl哥这次画的解空间树很形象，如下图，失败思路想到了怎么分支，但是没想到怎么判断叶节点，具体的代码写法也写昏了头</p><figure><img src="https://s3.bmp.ovh/imgs/2024/06/17/788a44e4b04795dd.png"alt="解空间树" /><figcaption aria-hidden="true">解空间树</figcaption></figure><h2 id="代码-2">代码</h2><h3 id="一般代码">一般代码</h3><p>之所以叫一般，是因为判断回文串的函数<code>isValid</code>每次调用都要俩指针相向而行，有很多重复操作，提高了时间复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;string&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = begin, right = end;<br>        <span class="hljs-keyword">if</span>(right &gt; s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span>(s[left++] != s[right--]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, begin, i)) &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + begin, s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>));<br>                <span class="hljs-built_in">backtrack</span>(s, i + <span class="hljs-number">1</span>);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-built_in">backtrack</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="动态规划代码">动态规划代码</h3><p>使用动态规划（dynamic programming，DP）直接把所有子串是否是回文串都提前算好，这样后续判断时就只需要O(1)复杂度就可以了</p><p>动态规划状态转移方程为： <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">           ⌜<span class="hljs-number">1</span>, <span class="hljs-selector-tag">i</span> = j <br><br>dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> = +s<span class="hljs-selector-attr">[i]</span>==s<span class="hljs-selector-attr">[j]</span>, <span class="hljs-selector-tag">i</span> = j - <span class="hljs-number">1</span><br><br>           ㇗s<span class="hljs-selector-attr">[i]</span>==s<span class="hljs-selector-attr">[j]</span>ANDdp<span class="hljs-selector-attr">[i+1]</span><span class="hljs-selector-attr">[j-1]</span>,<span class="hljs-keyword">else</span><br></code></pre></td></tr></table></figure><del>不会打latex，好拉的公式，快去配置渲染器！！</del> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;string&gt; temp;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; dp;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(dp[begin][i]) &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + begin, s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>));<br>                <span class="hljs-built_in">backtrack</span>(s, i + <span class="hljs-number">1</span>);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string &amp;s)</span> </span>&#123;<br>        dp.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<span class="hljs-comment">//vector还得resize了才能用</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; s.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> == j) dp[i][j] = s[i] == s[j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == j) dp[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-built_in">isValid</span>(s);<br>        <span class="hljs-built_in">backtrack</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day24</title>
    <link href="/2024/06/15/leetcode-day24/"/>
    <url>/2024/06/15/leetcode-day24/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><a href="https://leetcode.cn/problems/combinations/">77.组合</a></li><li><ahref="https://leetcode.cn/problems/combination-sum-iii/description/">216.组合总和Ⅲ</a></li><li><ahref="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/">17.电话号码的字母组合</a></li></ul><h1 id="前言">前言</h1><p>进入回溯算法篇章，对递归掌握仍然不熟练，尤其是回溯算法，在左的课上写全排列等题目简直惨不忍睹，趁此机会，再次尝试学会回溯算法，每题务必隔天复习重写熟悉</p><p>卡哥的题解也要仔细看，综合多篇题解学习。</p><blockquote><p><strong>文章讲解：</strong>https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html<strong>视频讲解：</strong> https://www.bilibili.com/video/BV1cy4y167mM<strong>代码随想录：</strong>https://programmercarl.com/</p></blockquote><h1 id="组合">77. 组合</h1><p><strong>题目：</strong></p><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>思路：</strong></p><p>多重for循环就行，但是由于层数不定，所以不能直接for，需要靠递归来实现任意层数循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;    <span class="hljs-comment">//回溯模板1：总答案</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;           <span class="hljs-comment">//回溯模板2：单个答案暂存</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == k) &#123;  <span class="hljs-comment">//回溯模板3：递归结束条件：遍历到叶子节点</span><br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start;i &lt;= n - k + temp.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(i);  <span class="hljs-comment">//回溯模板4：选择当前，进入下一步</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-comment">//回溯模板5：取消之前操作，回溯</span><br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="组合总和ⅲ">216. 组合总和Ⅲ</h1><p><strong>题目：</strong></p><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em>。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>思路：</strong></p><p>和上一道题很像，卡哥选题还是很有深意的。熟悉模板写法，给出的代码没有剪枝，剪枝写法参见：</p><p><ahref="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">代码随想录| 组合总和iii</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == k) &#123;<br>            <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start;i &lt;= <span class="hljs-number">9</span>;i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(k, n - i, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">backtracking</span>(k, n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="电话号码的字母组合">17. 电话号码的字母组合</h1><p><strong>题目：</strong></p><p>给定一个仅包含数字 2-9的字符串，返回所有它能表示的字母组合。答案可以按<strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1不对应任何字母。</p><p><strong>思路：</strong></p><p>仍然是不定次数for循环，使用递归来解，同样，剪枝写法参见<ahref="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">代码随想录| 电话号码的字母组合</a></p><p>注意打表方式，值得学习，自己打表还用的unordered_map，结果打出来一堆bug，还是string数组聪明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    string temp;<br>    <span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = &#123;<br>    <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 0</span><br>    <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 1</span><br>    <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-comment">// 2</span><br>    <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-comment">// 3</span><br>    <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-comment">// 4</span><br>    <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-comment">// 5</span><br>    <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-comment">// 6</span><br>    <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-comment">// 7</span><br>    <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-comment">// 8</span><br>    <span class="hljs-string">&quot;wxyz&quot;</span>, <span class="hljs-comment">// 9</span><br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string digits, <span class="hljs-type">int</span> begin_for_string)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> digit = digits[begin_for_string] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        string letter = letterMap[digit];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; letter.<span class="hljs-built_in">size</span>();i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(letter[i]);<br>            <span class="hljs-built_in">backtracking</span>(digits, begin_for_string + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">backtracking</span>(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day23</title>
    <link href="/2024/06/14/leetcode-day23/"/>
    <url>/2024/06/14/leetcode-day23/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669.修剪二叉搜索树</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108.将有序数组转换为二叉搜索树</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">538.把二叉搜索树转换为累加树</a> <span class="label label-warning">medium</span></li></ul><h1 id="修剪二叉搜索树">669. 修剪二叉搜索树</h1><p><strong>题目：</strong></p><p>给你二叉搜索树的根节点 <code>root</code>，同时给定最小边界<code>low</code> 和最大边界<code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树<strong>不应该</strong> 改变保留在树中的元素的相对结构(即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在<strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>思路：</strong></p><p>根据day22的“删除二叉搜索树的节点”，这题就变成了：删除小于low的节点和大于high的节点，那么同样的做法，制定好分类讨论的规则，然后按规则遍历就好</p><h2 id="可以中序遍历吗">可以中序遍历吗？</h2><p>笔者第一版代码惨遭RE和WA，由于是区间，所以笔者“理所应当”地想要中序遍历先把小的全删了，然后再把大的全删了，看似没有问题，就像操作有序数组一样，但笔者实际写出的代码却是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root) &#123;<span class="hljs-comment">//不为空才操作</span><br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);    <span class="hljs-comment">//先左，中序嘛</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; low) &#123;                           <span class="hljs-comment">//然后中，处理当前节点</span><br>            TreeNode * temp = root;                     <span class="hljs-comment">//如果当前的小了</span><br>            root = root-&gt;right;                         <span class="hljs-comment">//让更大一点的右孩子来补位（雷点所在）</span><br>            <span class="hljs-keyword">delete</span> temp;                                <span class="hljs-comment">//删掉当前的</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; high) &#123;                     <span class="hljs-comment">//同理</span><br>            TreeNode * temp = root;<br>            root = root-&gt;left;                          <span class="hljs-comment">//大了就让更小一点的左孩子来补位</span><br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root) root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<span class="hljs-comment">//最后右</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>RE原因：</strong>这题力扣上似乎有点问题，对于<code>[1, null, 2]</code>这个用例，如果delete掉root，就会报错，但本地写好代码run出来是不会报错的，carl对此的解释是：</p><div class="note note-light">            <p>○ 代码加了内存释放，在运行时出错，<code>[1,null,2]</code>这个输入，本地调试时，没有出错。卡哥的代码没有处理内存问题，难道这题不用自己释放内存？把delete的逻辑移除后，就通过了。手动delete反而会出错</p><p>○解答：因为最终答案是删除了原本的根节点，然后返回节点2作为新的根节点也就是答案，为此做了两个实验：1.把right子树的指赋给原本的root，然后最终返回root，可以通过case；2.把root指向right，然后之前用个tmp指向原本root的内存再删除，这次会报错。而报错的原因是释放的内存再次被使用，所以我猜测是LeetCode的判题机在判题的时候应该再次使用了原本子树根节点的那块内存导致的错误，你可以只删除那个会释放根节点的delete语句，其他的释放语句不去掉，结果还是可以通过的，所以你本地输出答案没有错误那说明就是lc自己的问题了，不用太过于纠结。</p>          </div><p>忽略力扣本身原因，关注上述中序代码的逻辑错误，即</p><p><strong>WA原因：</strong></p><p>对于用例[4, 2, 5, null,3]，如下图所示，若范围为[4,5]，那么应该删除2、3，最后得到一棵4、5的链，但是依照上述代码，当递归到节点<code>2</code>时，会发生：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode * temp = root;           <span class="hljs-comment">//记录节点2</span><br>root = root-&gt;right;               <span class="hljs-comment">//将root-&gt;right赋值给root指针变量，意图让右孩子补位</span><br><span class="hljs-keyword">delete</span> temp;                      <span class="hljs-comment">//删掉节点2</span><br></code></pre></td></tr></table></figure><p>问题就出在第二条，原本计划让right来补位，但是实际操作却仅仅是给一个函数里的形式参数赋了值，相当于<strong>用形参root保留了当前的右儿子</strong>，之后递归处理右儿子right实际却处理了右<strong>孙子</strong>，可能会返回右孙子本身或者null，但是最后却返回了右儿子right，相当于跳过了<code>if(root) root-&gt;right = trimBST(root-&gt;right, low, high);</code>语句，会导致修剪不到位，对于上述用例，就会返回[3,4,5]，本应被删除的节点3被保留了。</p><p>看起来被否定的只是代码编写，而中序遍历这个思路似乎仍具有可行性，实际上，硬要保持左中右的教条中序遍历，也是可以的。</p><p>需要改的地方就是：如果根节点被删除，那么就应该返回 <strong>儿子节点的处理结果</strong>，而不仅仅是儿子节点，修改后的中序遍历如下，由于力扣本身原因，省去delete操作避免RE：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-comment">//规则：</span><br>        <span class="hljs-comment">//1. 当前小，删了让右孩子补位</span><br>        <span class="hljs-comment">//2. 当前大，删了让左孩子补位</span><br>        <span class="hljs-comment">//3. 当前合法，处理左右孩子后返回</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//左</span><br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        <span class="hljs-comment">//中</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; low) <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; high) <br>            <span class="hljs-keyword">return</span> root-&gt;left;<br>        <span class="hljs-keyword">else</span><br>            root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>按照官解做完再看这段修改后的“中序”，其实会发现对比下来就是把<code>root-&gt;left = trimBST(root-&gt;left, low, high);</code>这句给摘出来提前了。</p><p><strong>综上</strong></p><p>对于“可以中序吗？”的问题，我的回答是可以，事实上这道题并不需要关注前中后序怎么遍历，这也引出了笔者的一个思维定势：<strong>二叉树的递归都基于前中后序遍历，迭代都基于层序遍历</strong>。不要局限于前中后序遍历，这只是参考，实际就按递归三部曲来就行</p><p><del>这也许是一直看卡哥的代码却没有仔细思考，光看了个大概长相的缘故。😣</del></p><h2 id="正经解答">正经解答</h2><p>对一个小问题想多了，下面给出优雅的正确答案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>            root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="将有序数组转化为二叉搜索树">108. 将有序数组转化为二叉搜索树</h1><blockquote><p>乍一看，想要走捷径，直接拉个有序链表不也是二叉搜索树？</p></blockquote><blockquote><p>实际上题目要求平衡。。切</p></blockquote><p><strong>题目：</strong></p><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵平衡 二叉搜索树。</p><p><strong>思路：</strong></p><p>由于要平衡，所以对半分就行，这样深度差就得到控制，不会退化成链，有点像快排？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>官解整花活，划线方式给整了三种，实际就是一种方法</p>          </div><h1 id="把二叉搜索树转换为累加树">538. 把二叉搜索树转换为累加树</h1><p><strong>题目：</strong></p><p>给出二叉 <strong>搜索</strong>树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater SumTree），使每个节点 <code>node</code> 的新值等于原树中大于或等于<code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>思路：</strong></p><p>把累加树定义看懂就成，就是把一个节点右边的值（比它大的）全加起来变成这个节点的新值。那不就是从右至左累加么，一个右中左顺序遍历，开个int记录前一个节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        root-&gt;right = <span class="hljs-built_in">convertBST</span>(root-&gt;right);<br>        root-&gt;val += pre;<br>        pre = root-&gt;val;<br>        root-&gt;left = <span class="hljs-built_in">convertBST</span>(root-&gt;left);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><del>少有的直接秒杀还和标准答案一模一样，嘿嘿嘿😆</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day22</title>
    <link href="/2024/06/13/leetcode-day22/"/>
    <url>/2024/06/13/leetcode-day22/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">235.二叉搜索树的最近公共祖先</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701.二叉搜索树的插入操作</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450.删除二叉搜索树中的节点</a><span class="label label-warning">medium</span></li></ul><h1 id="二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先</h1><p>与day21的第三题相比，这题多了二叉搜索树这一条件，变得更简单</p><p><strong>题目：</strong></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>思路</strong></p><p>主体思路就是<strong>当root的值在p和q之间时，root就是最近公共祖先了</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == p || root == q || !root) <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//沿用236题的返回条件</span><br>        <span class="hljs-keyword">if</span>(p-&gt;val &gt; q-&gt;val) &#123;<span class="hljs-comment">//先设定p &lt; q</span><br>            TreeNode * temp = p;<br>            p = q;<br>            q = temp;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//如果root在之间，返回</span><br>        <span class="hljs-keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<span class="hljs-comment">//不然就在左子树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<span class="hljs-comment">//不然就在右子树</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树的插入操作">701. 二叉搜索树的插入操作</h1><p><strong>题目：</strong></p><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。你可以返回 任意有效的结果 。</p><p><strong>思路</strong></p><p>不要拘泥于AVL的标准，这只是普通的二叉搜索树，哪怕退化成链都没关系，所以<strong>直接在最底部插入就行</strong></p><p>然后问题转化为:<strong>在二叉搜索树BST中查找val</strong>。当然肯定找不到，但最后会在某个叶子节点处下行碰到null，那么只需要判断走没走到叶子，以及val该插在叶子的左边还是右边</p><p><del>别想着在中途插入了，本菜比卡了一个小时没写出来，看评论区全是“伪装成medium的easy”😭</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) &#123;<br>            TreeNode * node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除二叉搜索树中的节点">450. 删除二叉搜索树中的节点</h1><p><strong>题目：</strong></p><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ul><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ul><p><strong>思路：</strong></p><p>依然别想着AVL的左右旋什么的，别自己给自己上难度，简单暴力地分类讨论就行：</p><ol type="1"><li>没找到<code>val</code>(<code>root</code>是空的)，返回<code>nullptr</code></li><li>要删的是个叶子，直接删了返回<code>nullptr</code></li><li>要删的节点只有一个孩子，删完孩子上来补位，返回这个独生子</li><li>要删的节点有两个孩子，把左子树接到右子树最左边的节点下面当左孩子（这样可以最简单地使树依然合法）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        <span class="hljs-keyword">if</span>(root-&gt;val == key) &#123;<br>            <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>                TreeNode * temp = root-&gt;left;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right &amp;&amp; !root-&gt;left) &#123;<br>                TreeNode * temp = root-&gt;right;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                TreeNode * keeper = root-&gt;right;<br>                <span class="hljs-keyword">while</span>(keeper-&gt;left != <span class="hljs-literal">nullptr</span>) keeper = keeper-&gt;left;<br>                keeper-&gt;left = root-&gt;left;<br>                TreeNode * temp = root-&gt;right;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day21</title>
    <link href="/2024/06/13/leetcode-day21/"/>
    <url>/2024/06/13/leetcode-day21/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530.二叉搜索树的最小绝对差</a><span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/">501.二叉搜索树中的众数</a><span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236.二叉搜索树的最近公共祖先</a><span class="label label-warning">medium</span></li></ul><h1 id="二叉搜索树的最小绝对差">530. 二叉搜索树的最小绝对差</h1><p><strong>题目：</strong>（仅题干，示例请移步力扣）</p><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回<code>树中任意两不同节点值之间的最小差值</code> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>思路：</strong></p><p>由于是二叉搜索树，时刻牢记<span class="label label-info">中序遍历二叉搜索树相当于遍历有序数组</span>，所以大思路就是中序遍历树，并维护一个最小绝对差</p><p>中序遍历这里采用递归法，递归途中需要记录上一个节点的值以求出两数之差</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> &amp;ans, <span class="hljs-type">int</span> &amp; pre)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root) &#123;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;left, ans, pre);<br>            <span class="hljs-keyword">if</span>(pre == <span class="hljs-number">-1</span>) pre = root-&gt;val;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans = <span class="hljs-built_in">min</span>(ans, root-&gt;val - pre);<br>                pre = root-&gt;val;<br>            &#125;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;right, ans, pre);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = INT_MAX, pre = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">traversal</span>(root, ans, pre);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树中的众数">501. 二叉搜索树中的众数</h1><p><strong>题目：</strong></p><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code>，找出并返回 BST 中的所有<code>众数</code>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <code>小于等于</code> 当前节点的值</li><li>结点右子树中所含节点的值 <code>大于等于</code> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p><strong>思路：</strong></p><p>大思路仍然依靠<span class="label label-info">中序遍历二叉搜索树相当于遍历有序数组</span>，问题转换为求出一个有序数组中的众数，那么在遍历时记录每个数的频率，维护一个最大频率</p><p>若该数最后的频率小于最大频率，则不做操作；等于最大频率，则加入答案中；大于最大频率，则更新最大频率，清空当前答案，并将当前数加入答案</p><p>依然是递归中序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-comment">//答案answer</span><br>    <span class="hljs-type">int</span> max_freq = <span class="hljs-number">0</span>;<span class="hljs-comment">//最大频率</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> &amp;cur, <span class="hljs-type">int</span> &amp;freq)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, cur, freq);<span class="hljs-comment">//中序左</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val == cur) &#123;<span class="hljs-comment">//当前数cur还未遍历完，继续加频率freq</span><br>            freq++;<br>            <span class="hljs-keyword">if</span>(max_freq == freq) &#123;<span class="hljs-comment">//如果已经赶上最大频率，加入答案</span><br>                ans.<span class="hljs-built_in">push_back</span>(cur);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(max_freq &lt; freq) &#123;<span class="hljs-comment">//如果已经超过，更新max，清空答案，重新加入cur作为答案</span><br>                max_freq = freq;<br>                ans.<span class="hljs-built_in">clear</span>();<br>                ans.<span class="hljs-built_in">push_back</span>(cur);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cur = root-&gt;val;<span class="hljs-comment">//当前数cur遍历结束，将cur更新为新的数，频率重置</span><br>            freq = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, cur, freq);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cur = root-&gt;val, freq = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(root, cur, freq);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树的最近公共祖先">236. 二叉搜索树的最近公共祖先</h1><p><strong>题目：</strong></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>思路</strong></p><p>初次尝试越想越复杂，以失败告终，原因是单次递归逻辑和终止条件没想明白，</p><p>按照carl的递归三部曲：</p><ol type="1"><li>确定递归返回值和参数。这一步没问题，就按照力扣给的核心方法的定义就可以，返回公共祖先的指针，参数就是两个节点p、q和根节点</li><li>确定递归终止条件。第一个终止条件想到了：“root等于p或者q时，或者root为空”就返回root。之后就开始混乱了，尝试讨论p、q是root的孩子还是孙子还是更远的孩子，遂失败</li><li>确定单次递归逻辑。失败</li></ol><p>我没有分析出：当递归到<code>最近公共祖先的祖先</code>时，返回值也应该是<code>最近公共祖先</code>，也就是说<code>最近公共祖先</code>是会不断向上传递的，这样就就能保证<code>最近</code>而不会得到深度更浅的公共祖先。</p><p>对于<strong>遍历一条路</strong>还是<strong>遍历整棵树</strong>，carl老师的解释令我耳目一新：</p><div class="note note-light">            <p><strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）。</strong></p><p>搜索一条边的写法： <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">if</span> (递归函数(root-&gt;<span class="hljs-built_in">left</span>)) <span class="hljs-keyword">return</span> ;<br><span class="hljs-keyword">if</span> (递归函数(root-&gt;<span class="hljs-built_in">right</span>)) <span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></table></figure> 搜索整个树写法： <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">left</span> = 递归函数(root-&gt;<span class="hljs-built_in">left</span>);  // 左<br><span class="hljs-built_in">right</span> = 递归函数(root-&gt;<span class="hljs-built_in">right</span>); // 右<br><span class="hljs-built_in">left</span>与<span class="hljs-built_in">right</span>的逻辑处理;         // 中 <br></code></pre></td></tr></table></figure></p>          </div><p>由于返回值确定，所以递归时肯定会有东西接住返回值，又由于，递归的参数是root，返回值也是root，所以当递归root左右孩子时，返回值也应该是左右孩子，即必然会有</p><p><code>left = lowestCommonAncestor(root-&gt;left, p, q);</code></p><p>由于这道题不需要对树进行操作，只需要查找遍历，所以<code>left</code>并不是<code>root-&gt;left</code>，即不需要更新。根据carl的区分，我们可以根据这条语句推断我们之后应该进行left和right的逻辑处理，那么就可以合理推测应该判断left和right是否为空，因为如果没有找到必定返回空，而找到p、q才会返回p或者q，那么如果left和right都返回了，就遇到答案（root）了，向上不断返回即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == p || root == q || root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br><br>        TreeNode * left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode * right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> &amp;&amp; right != <span class="hljs-literal">nullptr</span>) <br>            <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><del>对于想了半小时还WA的我来说，这真是段优雅的代码</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day20</title>
    <link href="/2024/06/11/leetcode-day20/"/>
    <url>/2024/06/11/leetcode-day20/</url>
    
    <content type="html"><![CDATA[<p>今日内容</p><p><ahref="https://leetcode.cn/problems/maximum-binary-tree/description/">●654.最大二叉树</a> <ahref="https://leetcode.cn/problems/merge-two-binary-trees/description/">●617.合并二叉树</a> <ahref="https://leetcode.cn/problems/search-in-a-binary-search-tree/">●700.二叉搜索树中的搜索</a> <ahref="https://leetcode.cn/problems/validate-binary-search-tree/description/">●98.验证二叉搜索树</a></p><h1 id="最大二叉树">最大二叉树</h1><h2 id="一般写法">一般写法</h2><p>题目实际上已经给出了递归逻辑，翻译成代码即可</p><p>给定一个不重复的整数数组<code>nums</code>。<code>最大二叉树</code>可以用下面的算法从<code>nums</code>递归地构建:</p><ol type="1"><li>创建一个根节点，其值为<code>nums</code>中的最大值。</li><li>递归地在最大值<code>左边</code>的<code>子数组前缀上</code>构建左子树。</li><li>递归地在最大值<code>右边</code>的<code>子数组后缀上</code>构建右子树。</li></ol><p>返回<code>nums</code>构建的<code>最大二叉树</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) <br>            <span class="hljs-keyword">if</span>(nums[max] &lt; nums[i]) max = i;<br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[max]);<span class="hljs-comment">// 1创建一个根节点，其值为`nums`中的最大值。</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(nums.begin(), nums.begin() + max)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(nums.begin() + max + <span class="hljs-number">1</span>, nums.end())</span></span>;<br>        root-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(left);<span class="hljs-comment">// 2递归地在最大值`左边`的`子数组前缀上`构建左子树。</span><br>        root-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(right);<span class="hljs-comment">// 3递归地在最大值`右边`的`子数组后缀上`构建右子树。</span><br>        <span class="hljs-keyword">return</span> root;<span class="hljs-comment">// 返回最大二叉树</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="单调栈写法">单调栈写法</h2><p>笔者仅根据题目写出递归写法，未想到单调栈写法，此为<ahref="https://leetcode.cn/problems/maximum-binary-tree/solutions/1759348/zui-da-er-cha-shu-by-leetcode-solution-lbeo/">力扣官方题解</a>启发</p><figure><img src="https://s3.bmp.ovh/imgs/2024/06/11/b6ce26fcf0d47d93.png"alt="总体思想图示" /><figcaption aria-hidden="true">总体思想图示</figcaption></figure><div class="note note-light">            <p>因此，我们的任务变为：找出每一个元素左侧和右侧第一个比它大的元素所在的位置。这就是一个经典的单调栈问题了，可以参考<ahref="https://leetcode.cn/problems/next-greater-element-ii/description/">503.下一个更大元素II</a>。如果左侧的元素较小，那么该元素就是左侧元素的右子节点；如果右侧的元素较小，那么该元素就是右侧元素的左子节点。</p>          </div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;  <span class="hljs-comment">//单调栈</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(len, <span class="hljs-number">-1</span>)</span></span>;  <span class="hljs-comment">//每个节点左侧第一个更大的节点</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(len, <span class="hljs-number">-1</span>)</span></span>;  <span class="hljs-comment">//每个节点右侧第一个更大的节点</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">tree</span><span class="hljs-params">(len)</span></span>;  <span class="hljs-comment">//存储树节点</span><br>        <span class="hljs-comment">//使用单减栈 获取left和right  (题目限制元素是不同的)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            tree[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[i]); <span class="hljs-comment">//构造当前节点</span><br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[stk.<span class="hljs-built_in">top</span>()])&#123;  <span class="hljs-comment">//当前节点比栈中元素大 弹栈并给栈中的小元素赋right</span><br>                right[stk.<span class="hljs-built_in">top</span>()] = i;<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!stk.<span class="hljs-built_in">empty</span>())&#123;  <span class="hljs-comment">//当前节点的左侧更大节点就是单减栈的顶部元素</span><br>                left[i] = stk.<span class="hljs-built_in">top</span>();<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        TreeNode* root = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//将每个节点接到自己的父节点上以构造树形结构</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(left[i] == <span class="hljs-number">-1</span> &amp;&amp; right[i] == <span class="hljs-number">-1</span>)&#123;  <span class="hljs-comment">//当前节点为最大值，其为根</span><br>                root = tree[i];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left[i] == <span class="hljs-number">-1</span> || (right[i] != <span class="hljs-number">-1</span> &amp;&amp; nums[left[i]] &gt; nums[right[i]]))&#123; <br>                tree[right[i]]-&gt;left = tree[i];   <span class="hljs-comment">//左侧没有更大的节点或左侧更大值大于右侧更大值，说明当前节点是右侧更大值的左子树的根节点</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tree[left[i]]-&gt;right = tree[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>该代码中的注释来源于题解评论区<ahref="https://leetcode.cn/u/6ifted-ishi2aka1rd/"><span class="citation"data-cites="健">@健</span></a>，本菜比瞪眼看了十分钟没看懂，抄了，挖坑后面来看</p>          </div><h1 id="合并二叉树">合并二叉树</h1><p>简单递归即可</p><ol type="1"><li>确定返回值和参数：就按力扣给的核心函数递归就行，无需另写函数，返回值就是合并后的节点指针，参数就是要合并的两个节点</li><li>确定递归结束条件：如果一方为空则返回另一方，都不空则相加后返回和节点</li><li>确定递归中途操作：合并当前节点对应的左右孩子</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root1) <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span>(!root2) <span class="hljs-keyword">return</span> root1;<br>        root1-&gt;val += root2-&gt;val;<br>        root1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);<br>        root1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树中的搜索">二叉搜索树中的搜索</h1><p>过于简单，知道什么是二叉搜索树就能做，略</p><h1 id="验证二叉搜索树">验证二叉搜索树</h1><p>示例2就已经给出一个容易犯的陷阱：错误地以为只需要左右节点各比根节点小和大就可以了，实际上二叉搜索树需要整个左右子树都比根节点小和大，所以需要注意在想当然递归的时候不要只比较左右节点，还需注意更上层的节点。</p><p>由于是二叉搜索树，条件比较硬，所以可以充分利用二叉搜索树的特性————利用中序遍历获取序列，然后判断该序列是否单调递增就好，若不单调递增，证明不是二叉搜索树</p><p>二叉排序树左子树-根-右子树严格单调递增，标准地画出一棵二叉排序树，并从上到下作其投影可得到严格序列，该序列即是中序遍历序列，并且该序列单调递增</p><p>附图直观一览</p><figure><img src="https://s3.bmp.ovh/imgs/2024/06/11/8bf9279d365104cd.png"alt="二叉排序树的投影与中序遍历" /><figcaption aria-hidden="true">二叉排序树的投影与中序遍历</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; ans;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root) &#123;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; ans2 = ans;<br>        <span class="hljs-built_in">sort</span>(ans2.<span class="hljs-built_in">begin</span>(), ans2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; ans.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(ans[i] != ans2[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; ans2[i] &lt;= ans2[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day18</title>
    <link href="/2024/06/09/leetcode-day18/"/>
    <url>/2024/06/09/leetcode-day18/</url>
    
    <content type="html"><![CDATA[<p>今日内容</p><p>● <ahref="https://leetcode.cn/problems/find-bottom-left-tree-value/">513.找树左下角的值</a>● <a href="https://leetcode.cn/problems/path-sum/description/">112.路径总和</a> <ahref="https://leetcode.cn/problems/path-sum-ii/">113.路径总和ii</a> ● <ahref="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106.从中序与后序遍历序列构造二叉树</a><ahref="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105.从前序与中序遍历序列构造二叉树</a></p><h1 id="找树左下角的值">找树左下角的值</h1><h2 id="递归写法">递归写法</h2><p>递归代表深度优先搜索，所以对于这道题要求的bottom比较好把握，只要维护一个最深深度就行了，对于left，就要在递归逻辑上把握</p><ul><li>当遇到叶子节点，根据深度判断是否维护，注意一定是深度比当前大才维护，不能相等</li><li>当遇到分支节点，先走左再走右</li></ul><p>为什么先走左就能保证最底最左？</p><p>最底可以保证，最左就是第一个遇到，而维护时只维护更深的，就意味着当前答案就是当前深度中第一个遇到的、最左的节点，所以最左也可以保证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; ans = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">findBottomLeftValueHelp</span>(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans.first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findBottomLeftValueHelp</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            <span class="hljs-keyword">if</span>(depth &gt; ans.second) ans = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&#123;root-&gt;val, depth&#125;;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;left) <span class="hljs-built_in">findBottomLeftValueHelp</span>(root-&gt;left, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">findBottomLeftValueHelp</span>(root-&gt;right, depth + <span class="hljs-number">1</span>);<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代写法">迭代写法</h2><p>代表广度优先搜索，或者层序遍历，由于每层从左向右，所以left好把握，对于bottom就要多写点逻辑来把握</p><p>遍历每行时，若遇到叶子节点，则跳过对该层后面节点的判断，仅仅只入队后面节点的子节点，这样就保证了最左。如果队中还有元素，则说明还有更深，继续寻找，最后就会得到答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> ans = root-&gt;val;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>                TreeNode * cur = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                <span class="hljs-keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;<br>                    ans = cur-&gt;val;<br>                    <span class="hljs-keyword">while</span>(++i &lt; size) &#123;<br>                        cur = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                        <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="路径总和">路径总和</h1><p>这题太适合深度优先搜索了，一条路走到头才能判断，那就一条一条走，正符合dfs。</p><p>代码比较简单，注意参数怎么传的，传参步骤减去当前节点值，最后判断是否刚好相等。而非从0加到叶子再判断是否等于target，虽然空间复杂度没变，但是少一个变量更简洁一点</p><p>具体代码不贴，与下一题类似，可同理理解</p><h1 id="路径综合ii">路径综合II</h1><p>仍然是深度优先搜索，只是多了保存答案的步骤，也不难</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">path</span>(root, targetSum, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(), ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">path</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> targetSum, vector&lt;<span class="hljs-type">int</span>&gt; temp, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == targetSum) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        temp.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(root-&gt;left) <span class="hljs-built_in">path</span>(root-&gt;left, targetSum - root-&gt;val, temp, ans);<br>        <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">path</span>(root-&gt;right, targetSum - root-&gt;val, temp, ans);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="从中序和后序构造二叉树">从中序和后序构造二叉树</h1><h2 id="递归写法-1">递归写法</h2><p>经典考题，递归写法核心思想为分割序列为子树的中序和后序，不断分割直到只剩一个，即是叶子节点</p><p>根据后序可以直接确定当前树的根节点，然后在中序中定位左右子树的中序，最后将左右子树的中序和后需继续下传，返回当前根节点</p><p>分割序列采用vector的构造函数，使用迭代器分割</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> size = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> rootval = postorder[size - <span class="hljs-number">1</span>];<br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootval);<br>        <span class="hljs-type">int</span> split;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>            <span class="hljs-keyword">if</span>(inorder[i] == rootval) &#123;<br>                split = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; inleft = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(inorder.<span class="hljs-built_in">begin</span>(), inorder.<span class="hljs-built_in">begin</span>() + split);<br>        vector&lt;<span class="hljs-type">int</span>&gt; inright = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(inorder.<span class="hljs-built_in">begin</span>() + split + <span class="hljs-number">1</span>, inorder.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; postleft = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(postorder.<span class="hljs-built_in">begin</span>(), postorder.<span class="hljs-built_in">begin</span>() + split);<br>        vector&lt;<span class="hljs-type">int</span>&gt; postright = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(postorder.<span class="hljs-built_in">begin</span>() + split, postorder.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>);<br>        root-&gt;left = <span class="hljs-built_in">buildTree</span>(inleft, postleft);<br>        root-&gt;right = <span class="hljs-built_in">buildTree</span>(inright, postright);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="从前序和中序构造二叉树">从前序和中序构造二叉树</h1><h2 id="递归写法-2">递归写法</h2><p>与上一题同理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> rootval = preorder[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> split = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(split;split &lt; preorder.<span class="hljs-built_in">size</span>();split++) &#123;<br>            <span class="hljs-keyword">if</span>(inorder[split] == rootval) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootval);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftpre</span><span class="hljs-params">(preorder.begin() + <span class="hljs-number">1</span>, preorder.begin() + <span class="hljs-number">1</span> + split)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightpre</span><span class="hljs-params">(preorder.begin() + <span class="hljs-number">1</span> + split, preorder.end())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftin</span><span class="hljs-params">(inorder.begin(), inorder.begin() + split)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightin</span><span class="hljs-params">(inorder.begin() + split + <span class="hljs-number">1</span>, inorder.end())</span></span>;<br>        root-&gt;left = <span class="hljs-built_in">buildTree</span>(leftpre, leftin);<br>        root-&gt;right = <span class="hljs-built_in">buildTree</span>(rightpre, rightin);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代写法-1">迭代写法</h2><p>迭代写法思维很巧妙，官方题解写得很严谨，我直接摘抄并加入自己的注解 ：<span class="label label-success">注解格式</span></p><p>原文链接：https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/</p><p>对于前序遍历中的任意两个连续节点 <code>u</code> 和<code>v</code>，根据前序遍历的流程，我们可以知道 <code>u</code> 和<code>v</code> 只有两种可能的关系：</p><p><code>v</code> 是 <code>u</code> 的左儿子。这是因为在遍历到<code>u</code> 之后，下一个遍历的节点就是 <code>u</code> 的左儿子，即<code>v</code>；</p><p><code>u</code> 没有左儿子，并且 <code>v</code> 是 <code>u</code>的某个祖先节点（或者 <code>u</code> 本身）的右儿子。 <span class="label label-success">可以自己画几个树来验证</span> ​</p><p>举一个例子来说明第二种关系的正确性，并在例子中给出我们的迭代算法。</p><p>例子</p><p>我们以树 <figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">        3<br>       / \<br>     <span class="hljs-number"> 9 </span> 20<br>     /  /  \<br>   <span class="hljs-number"> 8 </span><span class="hljs-number"> 15 </span>  7<br>   / \<br> <span class="hljs-number"> 5 </span> 10<br> /<br>4<br></code></pre></td></tr></table></figure> 为例，它的前序遍历和中序遍历分别为</p><p>preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]</p><p>inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]</p><p>我们用一个栈 <code>stack</code>来维护「<strong>当前节点的所有还没有考虑过右儿子的祖先节点</strong>」<span class="label label-success">栈内的元素无论何时都是这一含义，视作未判断过是不是有右孩子的节点</span>，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针<code>index</code> 指向中序遍历的某个位置，初始值为<code>0</code>。<code>index</code>对应的节点是「<strong>当前节点不断往左走达到的最终节点</strong>」，这也是符合中序遍历的，它的作用在下面的过程中会有所体现。</p><p>首先我们将根节点 <code>3</code> 入栈，再初始化 <code>index</code>所指向的节点为<code>4</code>，随后对于前序遍历中的每个节点，我们依次判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p><p>我们遍历 <code>9</code>。<code>9</code> 一定是栈顶节点 <code>3</code>的左儿子。我们使用反证法，假设 <code>9</code> 是 <code>3</code>的右儿子，那么 <code>3</code> 没有左儿子，<code>index</code>应该恰好指向 <code>3</code>，但实际上为<code>4</code>，因此产生了矛盾。所以我们将 <code>9</code> 作为<code>3</code> 的左儿子，并将 <code>9</code> 入栈。</p><p><code>stack = [3, 9]</code></p><p><code>index -&gt; inorder[0] = 4</code></p><p>我们遍历 <code>8</code>，<code>5</code> 和<code>4</code>。同理可得它们都是上一个节点（栈顶节点）的左儿子，所以它们会依次入栈。</p><p><code>stack = [3, 9, 8, 5, 4]</code></p><p><code>index -&gt; inorder[0] = 4</code></p><p>我们遍历 <code>10</code>，这时情况就不一样了。我们发现<code>index</code> 恰好指向当前的栈顶节点 <code>4</code>，也就是说<code>4</code> 没有左儿子，那么 <code>10</code>必须为栈中某个节点的右儿子。那么如何找到这个节点呢？栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的。<span class="label label-success">z左中右与中左右，其中“中”和“左”是相反的</span></p><blockquote><p>这是因为栈中的任意两个相邻的节点，前者都是后者的某个祖先。并且我们知道，栈中的任意一个节点的右儿子还没有被遍历过，说明后者一定是前者左儿子的子树中的节点，那么后者就先于前者出现在中序遍历中。</p></blockquote><p>因此我们可以把 <code>index</code>不断向右移动，并与栈顶节点进行比较。如果 <code>index</code>对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了栈顶节点，所以将<code>index</code> 增加 <code>1</code> 并弹出栈顶节点，直到<code>index</code>对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后一个节点<code>x</code> 就是 <code>10</code> 的双亲节点，这是因为 <code>10</code>出现在了 <code>x</code> 与 <code>x</code>在栈中的下一个节点的中序遍历之间，因此 <code>10</code> 就是<code>x</code> 的右儿子。</p><p>回到我们的例子，我们会依次从栈顶弹出 <code>4</code>，<code>5</code>和 <code>8</code>，并且将 <code>index</code> 向右移动了三次。我们将<code>10</code> 作为最后弹出的节点 <code>8</code>的右儿子<span class="label label-success">栈中没有考虑右孩子</span>，并将 <code>10</code> 入栈。</p><p><code>stack = [3, 9, 10]</code></p><p><code>index -&gt; inorder[3] = 10</code></p><p>我们遍历 <code>20</code>。同理，<code>index</code>恰好指向当前栈顶节点 <code>10</code>，那么我们会依次从栈顶弹出<code>10</code>，<code>9</code> 和 <code>3</code>，并且将<code>index</code> 向右移动了三次。我们将 <code>20</code>作为最后弹出的节点 <code>3</code> 的右儿子，并将 <code>20</code>入栈。</p><p><code>stack = [20]</code></p><p><code>index -&gt; inorder[6] = 15</code></p><p>我们遍历 <code>15</code>，将 <code>15</code> 作为栈顶节点<code>20</code> 的左儿子，并将 <code>15</code> 入栈。</p><p><code>stack = [20, 15]</code></p><p><code>index -&gt; inorder[6] = 15</code></p><p>我们遍历 <code>7</code>。<code>index</code> 恰好指向当前栈顶节点<code>15</code>，那么我们会依次从栈顶弹出 <code>15</code> 和<code>20</code>，并且将 <code>index</code> 向右移动了两次。我们将<code>7</code> 作为最后弹出的节点 <code>20</code> 的右儿子，并将<code>7</code> 入栈。</p><p><code>stack = [7]</code></p><p><code>index -&gt; inorder[8] = 7</code></p><p>此时遍历结束，我们就构造出了正确的二叉树。</p><p><strong>算法</strong></p><p>我们归纳出上述例子中的算法流程：</p><ul><li><p>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p></li><li><p>我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果<code>index</code>恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动<code>index</code>，并将当前节点作为最后一个弹出的节点的右儿子；如果<code>index</code>和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</p></li></ul><p>无论是哪一种情况，我们最后都将当前的节点入栈。</p><p><strong>代码</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!preorder.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        stack&lt;TreeNode*&gt; stk;<br>        stk.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> inorderIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; preorder.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> preorderVal = preorder[i];<br>            TreeNode* node = stk.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;val != inorder[inorderIndex]) &#123;<br>                node-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorderVal);<br>                stk.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>()-&gt;val == inorder[inorderIndex]) &#123;<br>                    node = stk.<span class="hljs-built_in">top</span>();<br>                    stk.<span class="hljs-built_in">pop</span>();<br>                    ++inorderIndex;<br>                &#125;<br>                node-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorderVal);<br>                stk.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day17</title>
    <link href="/2024/06/07/leetcode-day17/"/>
    <url>/2024/06/07/leetcode-day17/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><p><ahref="https://leetcode.cn/problems/balanced-binary-tree/description/">●110.平衡二叉树</a> <ahref="https://leetcode.cn/problems/binary-tree-paths/">● 257.二叉树的所有路径</a> <ahref="https://leetcode.cn/problems/sum-of-left-leaves/description/">●404.左叶子之和</a></p><h1 id="平衡二叉树">平衡二叉树</h1><p>只是判断平衡二叉树，比较简单，按规范化思路来吧，避免一会有感觉秒了，一会没感觉卡了</p><p>递归结束条件：如果左子树不是平衡二叉树 或者 右子树不是平衡二叉树 或者左右子树深度差距大于1</p><p>递归操作：判断左子树是不是平衡二叉树，判断右子树是不是平衡二叉树，获取左右子树深度</p><p>参数及返回值：根节点 + 是否合法的bool值</p><p>原创AC代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//空视作平衡</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;right)) &#123;<span class="hljs-comment">//左右都是</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">getDepth</span>(root-&gt;left) - <span class="hljs-built_in">getDepth</span>(root-&gt;right)) &lt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//左右深度是否匹配</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//空树深度0</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getDepth</span>(root-&gt;left), <span class="hljs-built_in">getDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<span class="hljs-comment">//左右子树最大深度加自己</span><br>&#125;<br></code></pre></td></tr></table></figure>这个时间复杂度较大，O(n^2)，对每一个节点都要单独求深度然后判断，自顶向下</p><p>自底向上做法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getDepth</span>(root) != <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">getDepth</span>(root-&gt;left);<br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//只要一个子树不平衡，整个树就不平衡</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">getDepth</span>(root-&gt;right);<br>    <span class="hljs-keyword">if</span>(right == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(left - right) &lt;= <span class="hljs-number">1</span> ? <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="二叉树的所有路径">二叉树的所有路径</h1><p>递归三步：</p><ol type="1"><li>参数&amp;返回值</li></ol><p>无需返回值，参数有根节点和存路径和答案的数组</p><ol start="2" type="1"><li>递归终止条件</li></ol><p>遇到叶节点</p><ol start="3" type="1"><li>递归逻辑</li></ol><p>没遇到就接着往里插</p><p>比较简单，贴代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        string line;<br>        <span class="hljs-built_in">traversal</span>(root, line);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode * root, string s)</span> </span>&#123;<br>        s += <span class="hljs-built_in">to_string</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) ans.<span class="hljs-built_in">push_back</span>(s);<br>        <span class="hljs-keyword">else</span> &#123;<br>            s += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>            <span class="hljs-keyword">if</span>(root-&gt;left) <span class="hljs-built_in">traversal</span>(root-&gt;left, s);<br>            <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">traversal</span>(root-&gt;right, s);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h2 id="迭代写法">迭代写法</h2><p>用一个栈存节点，一个栈存目前已经走过的路径注意push根节点和其他节点的差异</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        stack&lt;string&gt; path;<br>        stack&lt;TreeNode *&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        path.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">to_string</span>(root-&gt;val));<span class="hljs-comment">//only value</span><br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode * cur = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>            string tem = path.<span class="hljs-built_in">top</span>(); path.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span>(cur-&gt;left) &#123;<br>                st.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                path.<span class="hljs-built_in">push</span>(tem + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">to_string</span>(cur-&gt;left-&gt;val));<span class="hljs-comment">//insert the next value</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur-&gt;right) &#123;<br>                st.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                path.<span class="hljs-built_in">push</span>(tem + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">to_string</span>(cur-&gt;right-&gt;val));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;<span class="hljs-comment">//no next value</span><br>                ans.<span class="hljs-built_in">push_back</span>(tem);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="左叶子之和">左叶子之和</h1><p>需要注意，单独一个根节点不能称作左叶子，只是叶子，但不左</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;<br>            ans = root-&gt;left-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个递归看得有点懵，后面再来仔细理解一下吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day16</title>
    <link href="/2024/06/06/leetcode-day16/"/>
    <url>/2024/06/06/leetcode-day16/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><p><ahref="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">-104.二叉树的最大深度</a> <ahref="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/">-559.n叉树的最大深度</a> <ahref="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">-111.二叉树的最小深度</a> <ahref="https://leetcode.cn/problems/count-complete-tree-nodes/description/">-222.完全二叉树的节点个数</a></p><h1 id="树的最大深度">树的最大深度</h1><p>最大深度指从根到所有节点的长度中最长的那一个，换言之就是要找离根最远的节点然后返回到它的长度。</p><p>用dfs和bfs都行，分别代表递归前后序遍历和层序遍历，对于n叉树而言，仅仅是多比较几次而已，改写难度不大</p><p>下附对于n叉树的bfs遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>    queue&lt;Node *&gt; q;<br>    <span class="hljs-keyword">if</span>(root) q.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>            Node * cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; cur-&gt;children.<span class="hljs-built_in">size</span>();j++) &#123;<br>                q.<span class="hljs-built_in">push</span>(cur-&gt;children[j]);<br>            &#125;<br>        &#125;<br>        ans++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的最小深度">二叉树的最小深度</h1><p>最小深度需要注意，是从根到最近的<strong>叶子节点</strong>的距离，<strong>叶子节点</strong>指没有左右孩子的节点</p><p>所以在遍历时需要注意结束条件，对于层序遍历则判断当前节点是否是叶子，如果是就维护最小深度</p><p>对于递归遍历则根据子节点个数来分类处理，如果左右双全或双无，则直接递归；如果只有一个，就单独递归</p><p>下附递归遍历代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">minDepth</span>(root-&gt;left);<br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">minDepth</span>(root-&gt;right);<br><br>    <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + right;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;right == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;left) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(left, right);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>留坑，lc的最快执行代码中在最后<code>return</code>前把<code>root</code>的左右都指<code>null</code>，意义不明，但是就是快，没想出来为什么</em></p><h1 id="完全二叉树的节点个数">完全二叉树的节点个数</h1><p>用普通二叉树的遍历当然能做，只是不太好，还是用好完全二叉树的特性：<strong>非底层全满，底层从左往右堆</strong></p><p>所以完全二叉树的左右子树深度肯定是一样的，如果不一样，那么再递归，直到递归到完全二叉树或者细粒度足够小时的空节点</p><p>代码贴的carl的，原文链接：<ahref="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录| 完全二叉树的节点个数</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    TreeNode* left = root-&gt;left;<br>    TreeNode* right = root-&gt;right;<br>    <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里初始为0是有目的的，为了下面求指数方便</span><br>    <span class="hljs-keyword">while</span> (left) &#123;  <span class="hljs-comment">// 求左子树深度</span><br>        left = left-&gt;left;<br>        leftDepth++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (right) &#123; <span class="hljs-comment">// 求右子树深度</span><br>        right = right-&gt;right;<br>        rightDepth++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (leftDepth == rightDepth) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day15</title>
    <link href="/2024/06/05/leetcode-day15/"/>
    <url>/2024/06/05/leetcode-day15/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><p><ahref="https://leetcode.cn/problems/binary-tree-level-order-traversal/">-102.层序遍历</a> <ahref="https://leetcode.cn/problems/invert-binary-tree/">-226.翻转二叉树</a> <ahref="https://leetcode.cn/problems/symmetric-tree/">-101.对称二叉树</a></p><h1 id="层序遍历">层序遍历</h1><p>思路就是用队列记录逐层，这样顺序不会变。进入一层时最好记录队列初长度，然后根据长度遍历该层，避免根据队列是否空而判断该层是否遍历结束，便于即时将子节点入队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    TreeNode * cur = root;<br>    queue&lt;TreeNode*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(cur);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            temp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span> (cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(temp);<br>        temp.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="翻转二叉树">翻转二叉树</h1><p>递归版比较简单，太过简单，所以skip</p><p>迭代版就看作在遍历，而且是前序遍历那种单循环，出栈后把左右节点交换，然后压栈左右节点继续就行，给出循环部分的核心代码<del>本来就是核心代码模式，又再核心……</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>    TreeNode* node = st.<span class="hljs-built_in">top</span>();              <span class="hljs-comment">// 中</span><br>    st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>    <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);   <span class="hljs-comment">// 右</span><br>    <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);     <span class="hljs-comment">// 左</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对称二叉树">对称二叉树</h1><p>递归版很简单，写一个辅助函数判断左右节点是不是相等，是树就接着递归，然后从根开始对每一个分支节点的左右孩子判断就行代码没写，偷了个懒😜</p><p>迭代版要难一点，仅限于手写层面，思路不难</p><p>迭代需要用队列或者栈等来存，但是不是按左右顺序挨个入队，而是左右<strong>对应交替</strong>入队，这样方便判断是否相等</p><p>下附carl的漂亮含注释代码，<ahref="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">carl原文链接</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root-&gt;left);   <span class="hljs-comment">// 将左子树头结点加入队列</span><br>        que.<span class="hljs-built_in">push</span>(root-&gt;right);  <span class="hljs-comment">// 将右子树头结点加入队列</span><br>        <br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">// 接下来就要判断这两个树是否相互翻转</span><br>            TreeNode* leftNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            TreeNode* rightNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;  <span class="hljs-comment">// 左节点为空、右节点为空，此时说明是对称的</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span><br>            <span class="hljs-keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;left);   <span class="hljs-comment">// 加入左节点左孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;right); <span class="hljs-comment">// 加入右节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;right);  <span class="hljs-comment">// 加入左节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;left);  <span class="hljs-comment">// 加入右节点左孩子</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day14</title>
    <link href="/2024/06/04/leetcode-day14/"/>
    <url>/2024/06/04/leetcode-day14/</url>
    
    <content type="html"><![CDATA[<p>今日内容： - 递归遍历<br />- 迭代遍历 - 统一迭代</p><p>三道例题：</p><p><ahref="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">前序遍历二叉树</a><ahref="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">中序遍历二叉树</a><ahref="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">后续遍历二叉树</a></p><h1 id="递归遍历">递归遍历</h1><p>太过简单，skip # 迭代遍历（非统一版） 使用栈模拟递归过程：</p><p>前序就是先访问当前节点值，然后压栈右左孩子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    stack&lt;TreeNode*&gt; st;<br>    TreeNode * cur = root;<br>    st.<span class="hljs-built_in">push</span>(cur);<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        cur = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        <span class="hljs-keyword">if</span>(cur-&gt;right) st.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left) st.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>中序就是先存所有左节点，直到遇<code>null</code>再出栈栈顶，访问值后压栈右节点（压栈的所有节点均不为空）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    stack&lt;TreeNode*&gt; st;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    TreeNode * cur = root;<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(cur);<br>            cur = cur-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cur = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>后序比较讨巧，左右中倒序就是中右左，把前序的压栈顺序调换，最后翻转结果就行，就不贴代码了</p><h1 id="统一迭代遍历">统一迭代遍历</h1><p>形式统一的迭代遍历，主要思想是压栈<code>null</code>来<strong>标记</strong>下一个节点需要访问，这样写出来的代码在压栈部分就可以只调换顺序实现三种遍历</p><p>个人感觉比较好理解，最好记住写法，下面以后序为例给出代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; st;<br>    TreeNode * cur = root;<br>    <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)st.<span class="hljs-built_in">push</span>(cur);<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        cur = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br><br>            st.<span class="hljs-built_in">push</span>(cur);<br>            st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-comment">//中</span><br><br>            <span class="hljs-keyword">if</span>(cur-&gt;right) st.<span class="hljs-built_in">push</span>(cur-&gt;right);<span class="hljs-comment">//右</span><br><br>            <span class="hljs-keyword">if</span>(cur-&gt;left) st.<span class="hljs-built_in">push</span>(cur-&gt;left);<span class="hljs-comment">//左</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>            cur = st.<span class="hljs-built_in">top</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day13</title>
    <link href="/2024/06/03/leetcode-day13/"/>
    <url>/2024/06/03/leetcode-day13/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/sliding-window-maximum/description/">239.滑动窗口最大值</a></li><li><a href="">347.前 K 个高频元素</a></li></ul><h1 id="滑动窗口最大值">239.滑动窗口最大值</h1><p>考验对于<code>priority_queue</code>数据结构的了解和掌握程度，不过不能当API选手，得知道怎么手写堆，不求随手手撕出大小顶堆，但是得知道大概写法。</p><h2id="关于priority_queue的感性理解">关于<code>priority_queue</code>的感性理解</h2><p>在lc上看见了评论区大佬，关于<code>priority_queue</code>的比喻描述很形象，特引用至此：</p><blockquote><p>单调队列真是一种让人感到五味杂陈的数据结构，它的维护过程更是如此.....就拿此题来说，队头最大，往队尾方向单调......有机会站在队头的老大永远心狠手辣，当它从队尾杀进去的时候，如果它发现这里面没一个够自己打的，它会毫无人性地屠城，把原先队里的人头全部丢出去，转身建立起自己的政权，野心勃勃地准备开创一个新的王朝.....这时候，它的人格竟发生了一百八十度大反转，它变成了一位胸怀宽广的慈父！它热情地请那些新来的“小个子”们入住自己的王国......然而，这些小个子似乎天性都是一样的——嫉妒心强，倘若见到比自己还小的居然更早入住王国，它们会心狠手辣地找一个夜晚把它们通通干掉，好让自己享受更大的“蛋糕”；当然，遇到比自己强大的，它们也没辙，乖乖夹起尾巴做人。像这样的暗杀事件每天都在上演，虽然王国里日益笼罩上白色恐怖，但是好在没有后来者强大到足以干翻国王，江山还算能稳住。直到有一天，闯进来了一位真正厉害的角色，就像当年打江山的国王一样，手段狠辣，野心膨胀，于是又是大屠城......历史总是轮回的。</p></blockquote><p>似乎没办法贴评论的链接，去description下找吧，应该挺靠前的。</p><p>叛军屠城 = 遇到新最值，<strong>全弹出</strong>; 慈悲为怀 =后续小值有序堆在队头之后;</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; pq;<span class="hljs-comment">//存pair，得带上值得下标方便确定是不是该出队</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">empty</span>()) pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<span class="hljs-comment">//空的直接存</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] &gt;= pq.<span class="hljs-built_in">top</span>().first) &#123;<span class="hljs-comment">//新最值，全出队</span><br>                <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>()) pq.<span class="hljs-built_in">pop</span>();<br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &gt;= k) &#123;<span class="hljs-comment">//已满</span><br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<br>                <span class="hljs-keyword">while</span>(pq.<span class="hljs-built_in">top</span>().second + k &lt;= i)<span class="hljs-comment">//出队已经晚了的,注意得是while</span><br>                    pq.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<br>            <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &gt;= k) ans.<span class="hljs-built_in">push_back</span>(pq.<span class="hljs-built_in">top</span>().first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="前k个高频元素">347.前k个高频元素</h1><p>感觉思路比较简单暴力，用map来记“值-频率”，然后根据“频率数组”建堆排序来降低时间复杂度到O(nlogn)以下。总之是先记再排序。</p><p>不过carl的反其道而行很巧妙，采用小根堆，这样就可以简单地根据队列盈满来出队队头，官解也是小根堆，不过没有简单出队，而是判断当前的和队头的哪个更小，如果队头更小才出队。</p><p>对于pq自定义排序标准的语法不了解，是看过之后才写的，对于这道题</p><p><code>priority_queue</code>的模板类型参数有三，1.要存的类型；2.要存的类型的vector；3.自定义比较方法所在类，自定义比较需重载<code>()</code>运算符</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">cmp</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//用map记录值-频率，通过优先队列或者堆来对前k个频率排序，最后输出前k个元素</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) map[i]++;<br><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, cmp&gt; pq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : map) &#123;<br>            pq.<span class="hljs-built_in">push</span>(it);<br>            <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &gt; k) pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span> (k--)&#123;<br>            <span class="hljs-type">int</span> t = pq.<span class="hljs-built_in">top</span>().first;<br>            ans.<span class="hljs-built_in">push_back</span>(t);<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day11</title>
    <link href="/2024/06/01/leetcode-day11/"/>
    <url>/2024/06/01/leetcode-day11/</url>
    
    <content type="html"><![CDATA[<p>今日内容： - <ahref="https://leetcode.cn/problems/valid-parentheses/description/">20.有效的括号</a>- <ahref="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">1047.删除字符串中所有相邻重复项</a>- <ahref="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150.逆波兰表达式求值</a></p><h1 id="有效的括号">20.有效的括号</h1><p>其实这题跟最后一个逆波兰表达式有关，最后一题是逆波兰表达式求值，但是根据中缀表达式生成逆波兰表达式的算法里就会用到栈来处理中缀中的括号问题。</p><p>所以一个栈直接秒了，思路打开，碰到左括号别傻傻push左括号，而得push右括号，这样就可以直接判断<code>top()</code>了，而不用碰到右括号的时候再来个转换。</p><p><del>没错，我这次就push的左括号，碰到右括号的时候还用ASCII码去算对应的左括号值</del></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stack&lt;<span class="hljs-type">char</span>&gt; b;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) b.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) b.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span>) b.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b.<span class="hljs-built_in">empty</span>() || s[i] != b.<span class="hljs-built_in">top</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> b.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> b.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除字符串中所有相邻重复项">1047.删除字符串中所有相邻重复项</h1><p>如果不告诉用栈做的话，貌似还挺复杂的，不过用栈就很简单了</p><p>压栈前判断栈顶是不是重复，重复就pop，不重复就push，建议从尾到头遍历s，这样全pop出来时顺序还是对的。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() != s[i]) st.<span class="hljs-built_in">push</span>(s[i]);<br>            <span class="hljs-keyword">else</span> st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        string ans;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;!st.<span class="hljs-built_in">empty</span>();i++) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(st.<span class="hljs-built_in">top</span>());<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="逆波兰表达式求值">105.逆波兰表达式求值</h1><p>笔者大一下的Qt课设就是写一个大数计算器，对这逆波兰表达式还是比较熟悉，有了式子，求值就比较简单了，这个题还确保了int不炸。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; tokens.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;+&quot;</span> || tokens[i] == <span class="hljs-string">&quot;-&quot;</span> || tokens[i] == <span class="hljs-string">&quot;*&quot;</span> || tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>                <span class="hljs-type">int</span> num1 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> num2 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;+&quot;</span>) st.<span class="hljs-built_in">push</span>(num1 + num2);<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;-&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 - num1);<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;*&quot;</span>) st.<span class="hljs-built_in">push</span>(num1 * num2);<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 / num1);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(tokens[i]));<br>        &#125;<br>        <span class="hljs-type">int</span> res = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day10</title>
    <link href="/2024/05/31/leetcode-day10/"/>
    <url>/2024/05/31/leetcode-day10/</url>
    
    <content type="html"><![CDATA[<p>此帖仅作打卡用，过于简单，建议跳过 # <ahref="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232.用栈实现队列</a></p><p>根据题意，用俩栈来回倒就行</p><h2 id="code">code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; q1;<br>    stack&lt;<span class="hljs-type">int</span>&gt; q2;<br>    <span class="hljs-built_in">MyQueue</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q2.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> pipe = q2.<span class="hljs-built_in">top</span>();<br>            q2.<span class="hljs-built_in">pop</span>();<br>            q1.<span class="hljs-built_in">push</span>(pipe);<br>        &#125;<br>        q1.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> pipe = q1.<span class="hljs-built_in">top</span>();<br>            q1.<span class="hljs-built_in">pop</span>();<br>            q2.<span class="hljs-built_in">push</span>(pipe);<br>        &#125;<br>        <span class="hljs-type">int</span> ans = q2.<span class="hljs-built_in">top</span>();<br>        q2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> pipe = q1.<span class="hljs-built_in">top</span>();<br>            q1.<span class="hljs-built_in">pop</span>();<br>            q2.<span class="hljs-built_in">push</span>(pipe);<br>        &#125;<br>        <span class="hljs-keyword">return</span> q2.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">empty</span>() &amp;&amp; q2.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="用队列实现栈"><ahref="https://leetcode.cn/problems/implement-stack-using-queues/">225.用队列实现栈</a></h1><p>一个双端队列完事</p><h2 id="code-1">code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    deque&lt;<span class="hljs-type">int</span>&gt; d1;<br>    <span class="hljs-built_in">MyStack</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        d1.<span class="hljs-built_in">push_front</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> p = d1.<span class="hljs-built_in">front</span>();<br>        d1.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> d1.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> d1.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day4</title>
    <link href="/2024/05/30/leetcode-day4/"/>
    <url>/2024/05/30/leetcode-day4/</url>
    
    <content type="html"><![CDATA[<h1 id="两两交换链表中的节点"><ahref="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24.两两交换链表中的节点</a></h1><p>​链表貌似就是虚头+双指针+遍历，回到老家的感觉，注意对空节点的检查就好，题不难</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode * virhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        virhead-&gt;next = head;<br>        ListNode * left = virhead;<br>        ListNode * right = head;<br>        <span class="hljs-keyword">while</span>(right &amp;&amp; right-&gt;next) &#123;<br>            left-&gt;next = right-&gt;next;<br>            right-&gt;next = right-&gt;next-&gt;next;<br>            left-&gt;next-&gt;next = right;<br>            left = right;<br>            right = right-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> virhead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除链表的倒数第n个节点"><ahref="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19.删除链表的倒数第n个节点</a></h1><p>算脑筋急转弯吧，不过之前做过，已经没有难度了，思路就是让fast先走n步，再和slow一起走，这样fast走到最后slow就是倒数第n个了。</p><blockquote><p>​评论区在diss官解的“一次遍历”说法，去搜了一下，看见了宫水三叶前辈的帖，下为结论：</p><p>我们应该用「对数组的访问次数」来定义遍历多少次，而不是「利用 for循环的个数」来定义。 上述无论那种方法，对数组访问次数都是一样的。</p><p>出处：<ahref="https://developer.aliyun.com/article/905822">为什么「一次遍历」要比「两次遍历」慢（含小实验代码） | Java 刷题打卡-阿里云开发者社区 (aliyun.com)</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode * vir = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        vir-&gt;next = head;<br>        ListNode * fast = vir;<br>        ListNode * slow = vir;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        ListNode * t = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> t;<br>        <span class="hljs-keyword">return</span> vir-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="链表相交"><ahref="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">链表相交</a></h1><p>思路比较原始，都走一遍，把屁股对齐，长的先走几步把优势消耗，然后一起走找交点。</p><p>官解的追及思路更优雅，不过复杂度相同。<ahref="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solutions/1395092/lian-biao-xiang-jiao-by-leetcode-solutio-2kne/">官解</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode * vir = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        vir-&gt;next = head;<br>        ListNode * fast = vir;<br>        ListNode * slow = vir;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        ListNode * t = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> t;<br>        <span class="hljs-keyword">return</span> vir-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="环形链表ii"><ahref="https://leetcode.cn/problems/linked-list-cycle-ii/description/">环形链表II</a></h1><p>数学题，刚开始没推出来，注意把环分成走过的b段和没走过的c段，这样就很直观了，贴个图帮助理解</p><figure><img src="https://s3.bmp.ovh/imgs/2024/05/31/868052041ecc7ee9.jpg"alt="环形链表示意图" /><figcaption aria-hidden="true">环形链表示意图</figcaption></figure><p><em>公式中a对应图中x，y对应b，z对应c</em></p><p>求的是a，slow被碰到时离入口还差c，所以此时再来个指针从头开始一起走，碰到的时候刚好就是等式两边，即入口。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode * fast = head;<br>        ListNode * slow = head;<br>        <span class="hljs-keyword">while</span>(fast) &#123;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(!fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast == slow) &#123;<br>                ListNode * ans = head;<br>                <span class="hljs-keyword">while</span>(ans != slow) &#123;<br>                    ans = ans-&gt;next;<br>                    slow = slow-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>不太难，链表问题不大，注意空指针检查就行。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day3</title>
    <link href="/2024/05/30/leetcode-day3/"/>
    <url>/2024/05/30/leetcode-day3/</url>
    
    <content type="html"><![CDATA[<p>​ # <ahref="https://leetcode.cn/problems/remove-linked-list-elements/description/">203.移除链表元素</a></p><p>看见链表跟回家一样，大一走来就研究链表，被-&gt;和 .的用法confuse了好久，然后链表操作信手拈来，现在实现个线性表、栈、队列都是拿链表来实现，数组都不会写了……</p><p>题很简单，拿java练练语法好了，就连java都是一把过： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        h.next = head;<br>        ListNode cur = h;<br>        <span class="hljs-keyword">while</span>(cur.next != null) &#123;<br>            <span class="hljs-keyword">if</span>(cur.next.val == val) &#123;<br>                cur.next = cur.next.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>                cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="设计链表"><ahref="https://leetcode.cn/problems/design-linked-list/description/">707.设计链表</a></h1><p>群友遇到问题，跟着debug了一会，本来不想做的，给出修改后的群友代码吧，收获也有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(index--)<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; index;i++)<br></code></pre></td></tr></table></figure><p>就是这上面俩是等效的，不够之前知道，算加深印象吧，毕竟while(index--)这样的写法不常见，但是字少。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;<br>        <span class="hljs-type">int</span> val;<br>        LNode* next;<br>        <span class="hljs-built_in">LNode</span>(<span class="hljs-type">int</span> v):<span class="hljs-built_in">val</span>(v),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125; <span class="hljs-comment">//构造函数</span><br>       <span class="hljs-comment">// LNode(int v)&#123; val=v,next=nullptr;&#125;</span><br>    &#125;;<br>    <span class="hljs-built_in">MyLinkedList</span>() &#123;<br>        <span class="hljs-comment">//建立空链表</span><br>        lsize=<span class="hljs-number">0</span>;<br>        lhead=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;=lsize) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        LNode* p=lhead;<br>        <span class="hljs-comment">//从第一个实际数据开始遍历，当循环结束，一定是p指向了Index位置</span><br>        <span class="hljs-keyword">while</span>(index--)<br>            p=p-&gt;next;<br>        p=p-&gt;next;<br>        <span class="hljs-keyword">return</span> p-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//将val插入作为第一个节点，即头结点的下一个</span><br>        LNode* np=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(val);<br>        np-&gt;next=lhead-&gt;next;<br>        lhead-&gt;next=np;<br>        lsize++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//在最后增加节点</span><br>        LNode* np=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(val);<br>        LNode* p=lhead;<br>        <span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            p=p-&gt;next;<br>        &#125;<br>        np-&gt;next=p-&gt;next;<br>        p-&gt;next=np;<br>        lsize++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&gt;lsize) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(index == lsize) &#123;<br>            <span class="hljs-built_in">addAtTail</span>(val);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        LNode* np=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(val);<br>        LNode* p=lhead;<br>        <span class="hljs-keyword">while</span>(index--)<br>            p=p-&gt;next;<br>        np-&gt;next=p-&gt;next;<br>        p-&gt;next=np;<br>        lsize++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;=lsize) <span class="hljs-keyword">return</span>;<br>        LNode* p=lhead;<br>        <span class="hljs-keyword">while</span>(index--)<br>            p=p-&gt;next;<br>        LNode* tmp=p-&gt;next;<br>           p-&gt;next=p-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        lsize--;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> lsize;<br>    LNode* lhead;<br>&#125;;<br></code></pre></td></tr></table></figure> # <ahref="https://leetcode.cn/problems/reverse-linked-list/description/">206.反转链表</a>主要看了下递归做法，对于递归还是很迷，这次也没有一次写出来。</p><p>将后续部分看作已经反转完成，所以当前节点的下一个节点的下一个应该变成当前，即：</p><p><code>cur-&gt;next-&gt;next = cur;</code></p><p>对于头节点，再加一个next指null，就完成了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode * virHead = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> virHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure> ​</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day8</title>
    <link href="/2024/05/29/leetcode_day8/"/>
    <url>/2024/05/29/leetcode_day8/</url>
    
    <content type="html"><![CDATA[<h1 id="反转字符串ii"><ahref="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">反转字符串II</a></h1><p>按题意模拟即可，重写reverse方法，方便直接根据下标反转<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i += k) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span>*k == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">reverse</span>(s, begin, i / <span class="hljs-number">2</span>);<br>                begin = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= end) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">while</span>(begin &lt; end)&#123;<br>            <span class="hljs-type">char</span> c = s[begin];<br>            s[begin] = s[end];<br>            s[end] = c;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="替换数字"><ahref="https://programmercarl.com/kama54.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html">替换数字</a></h1><p>预先扩充好空间，然后<strong>从后向前</strong>扫描 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>        <span class="hljs-type">int</span> sOldIndex = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计数字的个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 扩充字符串s的大小，也就是将每个数字替换成&quot;number&quot;之后的大小</span><br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + count * <span class="hljs-number">5</span>);<br>        <span class="hljs-type">int</span> sNewIndex = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 从后往前将数字替换为&quot;number&quot;</span><br>        <span class="hljs-keyword">while</span> (sOldIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (s[sOldIndex] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[sOldIndex] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;r&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;e&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;m&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;u&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;n&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                s[sNewIndex--] = s[sOldIndex];<br>            &#125;<br>            sOldIndex--;<br>        &#125;<br>        cout &lt;&lt; s &lt;&lt; endl;       <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> # <ahref="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">反转单词</a>思路比较巧，全部反转，然后再反转单词，这样就得到了词序反转，注意删除空格<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">auto</span> it1 = s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">auto</span> it2 = s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(it2 != s.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">while</span>(*it2 != <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; it2 != s.<span class="hljs-built_in">end</span>()) it2++;<br>            <span class="hljs-built_in">reverse</span>(it1, it2);<br>            <span class="hljs-keyword">while</span>(*it2 == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; it2 != s.<span class="hljs-built_in">end</span>()) it2++;<br>            it1 = it2;<br>        &#125;<br>        it1=s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(it1!=s.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(it1==s.<span class="hljs-built_in">begin</span>() &amp;&amp; *it1 == <span class="hljs-string">&#x27; &#x27;</span>) s.<span class="hljs-built_in">erase</span>(it1);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*it1 == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; *<span class="hljs-built_in">next</span>(it1) == <span class="hljs-string">&#x27; &#x27;</span>) s.<span class="hljs-built_in">erase</span>(it1);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">next</span>(it1) == s.<span class="hljs-built_in">end</span>() &amp;&amp; *it1 == <span class="hljs-string">&#x27; &#x27;</span>) s.<span class="hljs-built_in">erase</span>(it1);<br>            <span class="hljs-keyword">else</span> it1++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure> # <ahref="https://programmercarl.com/kama55.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html">右旋字符串</a>思路与反转单词差不多，整体局部反转活用就行 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    string s;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//获取长度</span><br><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 整体反转</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + n); <span class="hljs-comment">// 先反转前一段，长度n</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + n, s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 再反转后一段</span><br><br>    cout &lt;&lt; s &lt;&lt; endl;<br><br>&#125; <br></code></pre></td></tr></table></figure>字符串和数组很像，后面的kmp上难度，前面的比较简单，略过即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day7</title>
    <link href="/2024/05/28/leetcode_day7/"/>
    <url>/2024/05/28/leetcode_day7/</url>
    
    <content type="html"><![CDATA[<h1 id="四数相加"><ahref="https://leetcode.cn/problems/4sum-ii/description/">454.四数相加</a></h1><blockquote><p>视频讲解: <ahref="https://www.bilibili.com/video/BV1Md4y1Q7Yh/">学透哈希表，map使用有技巧！LeetCode：454.四数相加II</a></p><p>文章讲解：<ahref="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html">454.四数相加</a></p></blockquote><p>之前做过，知道用map，但是太久没用过map，一时间不知道怎么用map，干瞪眼十几分钟，最后看了题解，思路有，但是map的用法限制了我……</p><h2id="unordered_map怎么在算法题中使用">unordered_map怎么在算法题中使用</h2><p>unordered_map是std命名空间下的，所以自己写ACM模式的时候记得加<code>std::</code></p><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td><code>map</code></td><td>红黑树</td><td>key有序</td><td>key不重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td><code>multimap</code></td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td><code>unordered_map</code></td><td>哈希表</td><td>key无序</td><td>key不重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>由该表能看出，unordered_map查找的效率最高，但是内部元素无序</p><p>适用于：当作记录型变量用于需要多次查找的场合</p><p><strong>创建unordered_map</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//注意给出两个模板类型变量</span><br>unordered_map&lt;type1, type2&gt; map;<br><span class="hljs-comment">//设定初值方法</span><br>unordered_map&lt;t1, t2&gt; map = &#123;&#123;key1, value1&#125;, &#123;key2, value2&#125;, ……&#125;;<br>vector&lt;pair&lt;t1, t2&gt;&gt; v = &#123;&#123;key1, value1&#125;, &#123;key2, value2&#125;, ……&#125;;  <br><span class="hljs-comment">//使用既有pair数组初始化</span><br><span class="hljs-function">unordered_map&lt;<span class="hljs-type">int</span>, string&gt; <span class="hljs-title">map</span><span class="hljs-params">(v.begin(), v.end())</span></span>;<br></code></pre></td></tr></table></figure><p><strong>插入一个元素进map</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果要记录的是&lt;key, value&gt;</span><br>map[key] = value;<br><span class="hljs-comment">//或者复杂点</span><br>map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;type1, type2&gt;(key, value));<br><span class="hljs-comment">//如果记录key出现几次</span><br>map[key]++;<span class="hljs-comment">//[]被重载过，即使没有key也会创建一个并赋值1</span><br></code></pre></td></tr></table></figure><p><strong>map的迭代器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用迭代器访问key和value</span><br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map;<br><span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">begin</span>();<br>it-&gt;first = key;<span class="hljs-comment">//it视作一个pair&lt;int, string&gt;元素，用-&gt;访问key和value</span><br>it-&gt;second = value;<span class="hljs-comment">//说白了就是用first和second</span><br></code></pre></td></tr></table></figure><p><strong>map的增删改查方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> type1&amp; key)</span>    <span class="hljs-comment">//返回key在map中的位置，没有就指end()</span></span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">const</span> type1&amp; key)</span>    <span class="hljs-comment">//返回哈希桶中关键码为key的键值对的个数</span></span><br><span class="hljs-function">insert    <span class="hljs-comment">//插入键值对</span></span><br><span class="hljs-function">erase     <span class="hljs-comment">//删除键值对</span></span><br></code></pre></td></tr></table></figure><p>注意<code>erase</code>方法是使用迭代器删除元素，传入的参数指向目标的迭代器，而返回下一个元素的迭代器，用<code>for</code>遍历删除时不要 <code>iter++</code>，应该使用<code>iter = map.erase(iter)</code></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : nums1) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b : nums2) &#123;<br>                <span class="hljs-type">int</span> sum = a + b;<br>                map1[sum]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : nums3) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b : nums4) &#123;<br>                <span class="hljs-keyword">if</span>(map1.<span class="hljs-built_in">count</span>(-a-b)) <br>                    ans += map1[-a-b];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="赎金信"><ahref="https://leetcode.cn/problems/ransom-note/description/">383.赎金信</a></h1><blockquote><p>Carl文章&amp;视频链接：<ahref="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html">代码随想录| 383.赎金信</a></p></blockquote><p>看覆不覆盖就完了，用 <code>char alpha[26]</code>或者开一个<code>map</code>都行，一次遍历 <code>++</code>，一次遍历<code>--</code>，缺了就 <code>false</code>，不缺就 <code>true</code></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : magazine) &#123;<br>            map[c]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : ransomNote) &#123;<br>            <span class="hljs-keyword">if</span>(map[c]) map[c]--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="三数之和双指针"><ahref="https://leetcode.cn/problems/3sum/description/">15.三数之和（双指针）</a></h1><blockquote><p>Carl文章&amp;视频链接：<ahref="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录| 三数之和</a></p></blockquote><p>该题看起来是<ahref="https://leetcode.cn/problems/two-sum/description/">两数之和</a>的拓展，所以自然想到用双指针，但是有3个数，得3个指针，所以拆分子问题，一个指针在大循环里移动，小循环内使用两数之和的方法查找。</p><p>还得去重操作，没有关注，WA了几发，哈希做法需要大量剪枝没看。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">2</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> target = -nums[i];<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>                <span class="hljs-type">int</span> sum = nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>(sum == target) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    left++;<br>                    right--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target) &#123;<br>                    left++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <br>                    right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="四数之和双指针"><ahref="https://leetcode.cn/problems/4sum/description/">四数之和（双指针）</a></h1><blockquote><p>Carl文章&amp;视频链接：<ahref="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录| 四数之和</a></p></blockquote><p>跟三数之和差不多，继续拆分子问题套循环，不过又多了剪枝操作</p><p>还得注意范围，此题会爆 <code>int</code>，得用<code>long long</code></p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>      <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">3</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) &#123;<span class="hljs-comment">//已经太大</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<span class="hljs-comment">//已经太小</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;j &lt; n - <span class="hljs-number">2</span>;j++) &#123;<br>                <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) &#123;<span class="hljs-comment">//已经太大</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[j] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<span class="hljs-comment">//已经太小</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> left = j + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[left] + nums[right] + nums[i] + nums[j];<br>                    <span class="hljs-keyword">if</span>(sum == target) &#123;<br>                        ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt; &#123;nums[i], nums[j], nums[left], nums[right]&#125;);<br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                        left++;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) &#123;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <br>                        left++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迷迭香的记事本：怎么写博客</title>
    <link href="/2024/05/27/%E8%BF%B7%E8%BF%AD%E9%A6%99%E7%9A%84%E8%AE%B0%E4%BA%8B%E6%9C%AC%EF%BC%9A%E6%80%8E%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/05/27/%E8%BF%B7%E8%BF%AD%E9%A6%99%E7%9A%84%E8%AE%B0%E4%BA%8B%E6%9C%AC%EF%BC%9A%E6%80%8E%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1><p>目前，如果misery想要写一篇博客，本地步骤为： 1.打开创建在<code>D:</code>的<code>blog</code>文件夹 2.右键，<code>git bash here</code>，输入<code>hexo new blog 'YOUR_BLOG_NAME'</code>3.进入<code>source\_post</code>文件夹中，找到step2创建的YOUR_BLOG_NAME.md文件，用vscode打开，进行编辑4.回到bash，输入<code>hexo g</code>重新生成静态页面，选择性输入<code>hexo s</code>预览效果5. 输入<code>hexo d</code>上传到github</p><h1id="hexo-d后博客未发生变化"><code>hexo d</code>后博客未发生变化?</h1><p>如果step5执行后，repository中看得见变化，能找到博客，但是网页并未发生变化，则回到<code>/blog</code>下的bash中输入<code>hexo clean</code>清除缓存（删除<code>/public</code>文件夹），重新从step4执行即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day2</title>
    <link href="/2024/05/23/leetcode-day2/"/>
    <url>/2024/05/23/leetcode-day2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第二天就有所松懈了，拖到晚上才写，拓展题也没写完，今天的没那么无脑，所以用老本行C++写</p></blockquote><h1 id="有序数组的平方"><ahref="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组的平方</a></h1><p>打眼一瞧，这题就是拿正负数平方之后大小不定来考人，结合卡哥想练的双指针，不难想到左右指针比绝对值大小一个一个插入，虽然这样是从大到小，不过有<code>reverse()</code>可以用，比较方便，也没有增加时间复杂度，还是O(n)，下附代码，不甚完美，可点击链接去看官解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">​<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(nums[left]) &lt; <span class="hljs-built_in">abs</span>(nums[right])) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums[right] * nums[right]);<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(nums[left]) &gt;= <span class="hljs-built_in">abs</span>(nums[right])) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums[left] * nums[left]);<br>                left++;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="长度最小的子数组"><ahref="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a></h1><p>​ 题目：给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其总和大于等于 <code>target </code>的长度最小的 连续子数组<code>[numsl, numsl+1, ..., numsr-1, numsr] </code>，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>这题是滑动窗口，由于做过多次，所以记得比较清楚，直接写了，结果遇到不少问题，WA了一发才解决，对于区间开闭的把握还不纯熟……<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> target &lt;= nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">1</span>, sum = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right &lt;= nums.<span class="hljs-built_in">size</span>() &amp;&amp; left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span>(sum &lt; target &amp;&amp; right &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>                sum += nums[right++];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt;= target &amp;&amp; left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>) ans = right - left;<br>                <span class="hljs-keyword">else</span> ans = <span class="hljs-built_in">min</span>(ans, right - left);<br>                sum -= nums[left++];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="拓展水果成篮">拓展——<ahref="https://leetcode.cn/problems/fruit-into-baskets/">水果成篮</a></h1><p>​这题是卡哥关于滑动窗口的拓展题1，小生不才，WA了五发才过，思路一直不清，将思路转换为代码语言也不准确。</p><blockquote><p>大概描述思路：</p></blockquote><blockquote><p>俩篮子我用俩变量bucket1、2来模拟，含左右顺序，俩指针做滑动窗口代表当前能摘的树。一个ans作为结果一直维护一个最大值，每遇到新树，则将left前进到第二种水果第一次出现的地方，right重新从left处开始走。至于第一次出现的位置我用一个<code>pair</code>来存。</p></blockquote><p>下附代码，官解与我不同，使用了哈希表，我也想用，苦于set和map系列语法掌握不牢，没写出来……<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fruits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(fruits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; bucket1, bucket2;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">1</span>;<br>        bucket1.first = fruits[left];<br>        bucket1.second = left;<br>        bucket2.first = <span class="hljs-number">-1</span>;<br>        bucket2.second = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; right &lt; fruits.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(fruits[right] == bucket1.first) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fruits[right] == bucket2.first) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bucket2.first == <span class="hljs-number">-1</span>)&#123;<br>                bucket2.first = fruits[right];<br>                bucket2.second = right;<br>                ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                left = bucket2.second;<br>                bucket1.first = bucket2.first;<br>                bucket1.second = left;<br>                bucket2.first = <span class="hljs-number">-1</span>;<br>                bucket2.second = <span class="hljs-number">-1</span>;<br>                right = left;<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>leetcode 官方题解：<ahref="https://leetcode.cn/problems/fruit-into-baskets/solutions/1893352/shui-guo-cheng-lan-by-leetcode-solution-1uyu/">水果成篮</a></p><h1 id="拓展最小覆盖子串">拓展——<ahref="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></h1><p>吐了，写的全没了，不记了，直接抛出灵神题解算了，哈希方法的确妙，还有less对于检索的优化。</p><p><ahref="https://leetcode.cn/problems/minimum-window-substring/solutions/2713911/liang-chong-fang-fa-cong-o52mn-dao-omnfu-3ezz/">灵茶山艾府题解</a></p><h1 id="螺旋矩阵ii"><ahref="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵II</a></h1><p>这题经典模拟，之前做过多次，这次一把过，左sir讲过优雅的四循环，评论区也是优雅的四循环，所以我也优雅的四循环，但还是不够优雅。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, bottom = n - <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> map[n][n];<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(k &lt;= n*n) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = left;t &lt;= right;t++) <br>                map[top][t] = k++;<br>            top++;<br>            <span class="hljs-keyword">if</span>(k &gt; n*n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = top;r &lt;= bottom;r++) <br>                map[r][right] = k++;<br>            right--;<br>            <span class="hljs-keyword">if</span>(k &gt; n*n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b = right;b &gt;= left;b--)<br>                map[bottom][b] = k++;<br>            bottom--;<br>            <span class="hljs-keyword">if</span>(k &gt; n*n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = bottom;l &gt;= top;l--)<br>                map[l][left] = k++;<br>            left++;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; t;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>                t.<span class="hljs-built_in">push_back</span>(map[i][j]);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(t);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="总结">​总结</h1><p>数组部分总体不难，主要是双指针和滑动窗口思想，双指针有快慢指针和左右指针，滑动窗口偏贪心一点，大体是right向前去满足条件，满足之后收紧left寻找最优，最后综合所有最优选出整体最优。</p><p>​</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day1</title>
    <link href="/2024/05/22/leetcode-day1/"/>
    <url>/2024/05/22/leetcode-day1/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><ahref="https://leetcode.cn/problems/binary-search/">二分查找</a></h1><p>之前用C++刷过不止一遍，所以这次用java重写，没想到遇到了语法问题，尴尬……</p><ul><li>参数给的<code>int[] nums</code>，跟C的普通数组一样吗？那我怎么得到长度呢？java有<code>sizeof()</code>吗？</li><li>我第一时间想递归，但是怎么传被分割后的数组呢？</li></ul><p>搜索学习一波后了解到，java的<code>int[]</code>类型可以获取长度，具体见下：</p><h2 id="java数组语法小记">java数组语法小记</h2><h3 id="length属性">length属性</h3><ul><li>"length"是数组的一个属性，用于获取数组的长度。</li><li>这是数组对象的一个公共属性，不是类的成员。</li></ul><p>例如： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <br>System.out.println(nums.length); <span class="hljs-comment">// 输出数组的长度：5</span><br></code></pre></td></tr></table></figure> ### 其他可用的操作虽然length是唯一一个直接通过点符号（.）访问的数组属性，但数组对象还可以通过一些标准的类库方法进行操作。例如：</p><ol type="1"><li><p><strong>Arrays 类：</strong></p><p>Arrays 类提供了许多静态方法来操作数组，例如排序、搜索、比较、填充等。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays; <br><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;; <br>Arrays.sort(nums); <span class="hljs-comment">// 对数组进行排序</span><br>System.out.println(Arrays.toString(nums)); <span class="hljs-comment">// 将数组转换为字符串并输出：[1, 1, 3, 4, 5]</span><br></code></pre></td></tr></table></figure></p></li><li><p>​<strong>System 类：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System 类提供了一些方法来进行数组的复制等操作。<br><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <br><span class="hljs-type">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>System.arraycopy(nums, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>, nums.length); <span class="hljs-comment">// 复制数组</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>Collections 类（适用于对象数组）：</strong>对于对象数组，可以使用 Collections类的方法进行排序、搜索等操作，但对于基本类型数组（如 int[]），需要使用Arrays 类的方法。</p></li></ol><h3 id="数组的其他特性">​数组的其他特性</h3><ul><li><strong>数组是对象：</strong>-在Java中，所有的数组类型都是对象，并且继承自 java.lang.Object 类。</li><li><strong>多维数组：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] matrix = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125; &#125;;<br>System.out.println(matrix.length); <span class="hljs-comment">// 输出二维数组的行数：3 </span><br>System.out.println(matrix[<span class="hljs-number">0</span>].length); <span class="hljs-comment">// 输出二维数组的第一行的列数：3</span><br></code></pre></td></tr></table></figure><ul><li>Java支持多维数组，通过嵌套数组的方式实现。</li></ul></li><li><strong>无法改变大小：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <br>list.add(<span class="hljs-number">1</span>); list.add(<span class="hljs-number">2</span>); <br>System.out.println(list.size()); <span class="hljs-comment">// 输出列表的大小：2</span><br></code></pre></td></tr></table></figure></li><li>数组一旦创建，其大小是固定的。如果需要一个可以动态调整大小的数组，可以使用ArrayList 或其他集合类。</li></ul><h2 id="代码实现递归版">​代码实现（递归版）</h2><p>至于具体算法细节，仍然是carl所教的左闭右开和左闭右闭</p><p><strong>左闭右开</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchHelp(<span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, nums, target);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchHelp</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span>(begin == end) &#123;<br>            <span class="hljs-keyword">return</span> target == nums[begin] ? begin : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end - begin) / <span class="hljs-number">2</span> + begin;<br>        <span class="hljs-keyword">if</span>(target &lt;= nums[mid]) <span class="hljs-keyword">return</span> searchHelp(begin, mid, nums, target);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> searchHelp(mid + <span class="hljs-number">1</span>, end, nums, target);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <strong>左闭右闭</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchHelp(<span class="hljs-number">0</span>, nums.length, nums, target);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchHelp</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= end - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(begin &gt; end - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> target == nums[begin] ? begin : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end - begin) / <span class="hljs-number">2</span> + begin;<br>        <span class="hljs-keyword">if</span>(target &lt; nums[mid]) <span class="hljs-keyword">return</span> searchHelp(begin, mid, nums, target);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> searchHelp(mid , end, nums, target);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> # ​二分拓展——在排序数组中查找元素的第一个和最后一个位置 <ahref="https://leetcode.cn/problems/binary-search/">题目链接</a></p><p>还没做此题时，算法群中有人讨论，瞄到了“二分定位然后发散找边界”的思路，窃以为很有道理，然另一群友diss：“全是一样的就成了O(n)了”，有道理哈。</p><p>自己做的时候的确直觉想到"二分定位然后发散"的思路，但是有意避免，于是想到两次二分分别定左右边界。下附代码，与官方题解区别在于，官方使用了一个"lower"标志位来区分左右边界，把两次二分合成一个方法。而我的代码直接写了两次，把等号换地方。记得第一次二分后把right弄回去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt;= target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left &gt;= nums.length || nums[left] != target) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">else</span> ans[<span class="hljs-number">0</span>] = left;<br>        right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt;= target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        ans[<span class="hljs-number">1</span>] = right;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="移除元素"><ahref="https://leetcode.cn/problems/remove-element/">移除元素</a></h1><p>​此题貌似是力扣新手村的一道题，以前错过多次，感叹于自己的菜，于是这次还记得解法，但仍然没有一把AC，在去重的时候没有考虑好只有一个元素和空表的情况。下附鄙人代码，未深入优化，恐有瑕疵，望读者建言：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">while</span>(right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[right] == val) right--;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span>(nums[right] == val &amp;&amp; left &lt; right) right--;<br>            <span class="hljs-keyword">while</span>(nums[left] != val &amp;&amp; left &lt; right) left++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = temp;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>第一天打卡，希望能够坚持下去，同时笔者还在看dolphinscheduler，看不懂啊……想参加开源之夏，但是好像截止前连项目都看不懂，抓紧时间，加油加油！</p><p><strong>ps</strong>算法群里遇到一个问题，在遍历数组的时候，<code>fast &lt; nums.size()</code>就AC，<code>fast &lt;= nums.size() - 1</code>就RE，原来是因为：</p><p>vector的size方法返回的是无符号整数，减一之后不会变-1，而是变大，条件就无效了。</p><p>空vector才会碰见的坑，长见识了。</p><p>​</p><p>​</p><p>​ ​ ​</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
