<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode_day51</title>
    <link href="/2024/07/12/leetcode-day51/"/>
    <url>/2024/07/12/leetcode-day51/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/trapping-rain-water/description/">42.接雨水</a> <span class="label label-danger">hard</span></li><li><a href="">84. 柱状图中最大的矩形</a> <span class="label label-danger">hard</span></li></ul><h1 id="接雨水">42. 接雨水</h1><p><strong>题目：</strong></p><p>给定 n 个非负整数表示每个宽度为 1的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure><imgsrc="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png"alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br />输出：6<br />解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1]表示的高度图，在这种情况下，可以接 6个单位的雨水（蓝色部分表示雨水）。</p><p><strong>思路：</strong></p><p>由木桶效应，水量由最短板决定，所以这里每一格的水量由左右两边最低的柱子决定，同时还要减去自己的高度。</p><p>那么就需要知道每一格左右两边的最高柱子，取其小作为水面高度，减去自身高度即为水深。</p><p><strong>求左右两边的某最值，且为一维数组，就尝试用单调栈。</strong></p><p><strong>个人版</strong>：设左右两个栈，底到顶递增，由于左右两柱子不接水，从左到右遍历就左栈只入栈最左柱，右栈入栈[2:size- 1]，然后取两个栈顶中较小的。</p><p>计算完当前柱，要把当前柱入栈左栈，注意维护大小关系，若当前高度等于右栈的栈底最大值，则要移除右栈的栈底。故数据结构用deque</p><p><strong>carl版</strong>：一个栈就够了，栈规则相同递增，如果遇到比栈顶大的，就逐个出栈计算值，直到栈空或遇到左高柱。一次取当前柱(右柱)，栈顶柱(凹陷)，栈次顶柱(左柱)，算中间凹陷的水量。</p><ul><li>另有双指针版，两个数组left、right分别表示heights[i]对应的左边最大值left[i]和右边最大值right[i]，初始先从左到右遍历得到left，从右到左遍历得到right，再遍历整个计算水量。需要注意维护和初始化</li></ul><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(height.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        deque&lt;<span class="hljs-type">int</span>&gt; left, right;<br>        left.<span class="hljs-built_in">push_front</span>(height[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt; height.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">while</span>(!right.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; right.<span class="hljs-built_in">back</span>()) &#123;<br>                right.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            right.<span class="hljs-built_in">push_back</span>(height[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i++) &#123;<br>            <span class="hljs-type">int</span> l = left.<span class="hljs-built_in">front</span>(), r = right.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">min</span>(l, r) - height[i] &gt; <span class="hljs-number">0</span>) ans += <span class="hljs-built_in">min</span>(l, r) - height[i];<br>            <span class="hljs-keyword">while</span>(!left.<span class="hljs-built_in">empty</span>() &amp;&amp; left.<span class="hljs-built_in">back</span>() &lt; height[i]) &#123;<br>                left.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            left.<span class="hljs-built_in">push_back</span>(height[i]);<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">1</span> &amp;&amp; right.<span class="hljs-built_in">front</span>() == height[i]) right.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>carl版： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (height.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 可以不加</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">// 存着下标，计算的时候用下标对应的柱子高度</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (height[i] &lt; height[st.<span class="hljs-built_in">top</span>()]) &#123;     <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">if</span> (height[i] == height[st.<span class="hljs-built_in">top</span>()]) &#123;  <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 注意这里是while</span><br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[st.<span class="hljs-built_in">top</span>()], height[i]) - height[mid];<br>                        <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意减一，只求中间宽度</span><br>                        sum += h * w;<br>                    &#125;<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure> # 84. 柱状图中最大的矩形</p><p><strong>题目：</strong></p><p>给定 n个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><figure><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>输入：heights = [2,1,5,6,2,3]<br />输出：10<br />解释：最大的矩形为图中红色区域，面积为 10</p><p><strong>思路：</strong></p><p>要么追求高度，要么追求宽度，都得兼顾，每次计算都算包含当前柱的矩形面积，需要知道<strong>左边不小于自己的最远的柱子，右边不小于自己的最远的柱子</strong>。</p><p><strong>单调栈</strong>：不小于自己的最远柱，那么入栈不小于的，<strong>碰到比栈顶小的就说明不能再贪宽度了</strong>，否则就损失高度了，此时逐个出栈计算面积，刚开始高窄，后面矮宽，总有一个最大，直到栈空或比栈顶大。</p><p><strong>双指针</strong>：</p><p>左右都遍历，与上面相同的顺序，只是每次循环内要再循环一次往找过的地方针对当前柱找<strong>不小于的最远柱</strong>，可以利用已经计算的left和right数组跳跃寻找。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heights.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> heights[<span class="hljs-number">0</span>];<br>        &#125;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        heights.<span class="hljs-built_in">insert</span>(heights.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);<br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; heights.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[st.<span class="hljs-built_in">top</span>()] &gt; heights[i]) &#123;<br>                <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                    <span class="hljs-type">int</span> right = i;<br>                    <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">top</span>();<br>                    ans = <span class="hljs-built_in">max</span>(ans, heights[mid] * (right - left - <span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>双指针： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-comment">//左边大于自己的最远的，右边大于自己的最远的</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(heights.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(heights.size(), heights.size())</span></span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; heights.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-type">int</span> t = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(t &gt;= <span class="hljs-number">0</span> &amp;&amp; heights[t] &gt;= heights[i]) t = left[t];<br>            left[i] = t;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = heights.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-type">int</span> t = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(t &lt; heights.<span class="hljs-built_in">size</span>() &amp;&amp; heights[t] &gt;= heights[i]) t = right[t];<br>            right[i] = t;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; heights.<span class="hljs-built_in">size</span>();i++) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, heights[i] * (right[i] - left[i] - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="小结">小结</h1><p>单调栈适用于找一维数组上，每个元素左右最大最小之类的最值。</p><p>设定好规则后，只需入栈符合规则的，遇到违背规则的就逐个出栈处理，直到符合规则，注意初始化以使栈内元素都能得到处理，防止漏解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day50</title>
    <link href="/2024/07/11/leetcode-day50/"/>
    <url>/2024/07/11/leetcode-day50/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/daily-temperatures/description/">739.每日温度</a> <span class="label label-warning">medium</span></li><li><a href="">496.下一个更大元素 I</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/next-greater-element-ii/description/">503.下一个更大元素II</a><span class="label label-warning">medium</span></li></ul><h1 id="每日温度">739. 每日温度</h1><h2 id="题目"><strong>题目：</strong></h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer，其中 answer[i] 是指对于第 i天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用0 来代替。</p><p>示例 1: 输入: temperatures = [73,74,75,71,69,72,76,73]<br />输出: [1,1,4,2,1,1,0,0]<br />示例 2:<br />输入: temperatures = [30,40,50,60]<br />输出: [1,1,1,0]<br />示例 3:<br />输入: temperatures = [30,60,90]<br />输出: [1,1,0]</p><h2 id="思路"><strong>思路：</strong></h2><h3 id="首次思路">首次思路</h3><p>既然是单调栈专题，之前遇到过单调栈，但只有模糊的认识：单调栈就是有一个特殊入栈出栈规则的栈，这个规则构成了单调。</p><p>于是“照虎画猫”，开一个栈，使其从栈底到栈顶非递减，即：<br />- 元素比栈顶小或相等，入栈 - 元素比栈顶大，不断出栈直至比栈顶小或空</p><p>遍历到最后栈内的都是没有升高的，在初始化时就置零，之后就不用管了直接返回。</p><p>写的时候就能悟到，栈里面存下标要方便得多，于是写出下面的<ahref="#自己的-每日温度">代码</a></p><h3 id="carl思路">carl思路</h3><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。</strong></p><ul><li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况:入栈</li><li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况：入栈</li><li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况：不断出栈到不大于或空</li></ul><p>栈内存下标。</p><h2 id="代码">代码</h2><h3 id="自己的-每日温度">自己的-每日温度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; temperatures.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>()) &#123;<br>                st.<span class="hljs-built_in">push</span>(i);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[st.<span class="hljs-built_in">top</span>()] &lt; temperatures[i]) &#123;<br>                    ans[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl的-每日温度">carl的-每日温度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; T)</span> </span>&#123;<br>        <span class="hljs-comment">// 递增栈</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(T.size(), <span class="hljs-number">0</span>)</span></span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; T.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (T[i] &lt; T[st.<span class="hljs-built_in">top</span>()]) &#123;                       <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T[i] == T[st.<span class="hljs-built_in">top</span>()]) &#123;               <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; T[i] &gt; T[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况三</span><br>                    result[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="下一个更大元素-i">496.下一个更大元素 I</h1><p><strong>题目：</strong></p><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的第一个 比 x 大的元素。</p><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0开始计数，其中nums1 是 nums2 的子集。</p><p>对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j]的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</p><p>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i]是如上所述的 下一个更大元素 。</p><p>示例 1：<br />输入：nums1 = [4,1,2], nums2 = [1,3,4,2].<br />输出：[-1,3,-1]<br />解释：nums1 中每个值的下一个更大元素如下所述：<br />- 4 ，用加粗斜体标识，nums2 =[1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br />- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。<br />- 2 ，用加粗斜体标识，nums2 =[1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br />示例 2： 输入：nums1 = [2,4], nums2 = [1,2,3,4].<br />输出：[3,-1]<br />解释：nums1 中每个值的下一个更大元素如下所述：<br />- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。 - 4，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1。<br />提示：<br />- <span class="math inline">\(1 &lt;= nums1.length &lt;= nums2.length&lt;= 1000\)</span><br />- <span class="math inline">\(0 &lt;= nums1[i], nums2[i] &lt;=10^4\)</span><br />- nums1和nums2中所有整数 互不相同<br />- nums1 中的所有整数同样出现在 nums2 中</p><h2 id="思路-1"><strong>思路：</strong></h2><h3 id="首次思路-1">首次思路</h3><p>俩for循环暴力搜索，我自己用单调栈好像也没优化到哪里去……</p><h3 id="carl的思路">carl的思路</h3><p>用map记忆化遍历，再遍历nums2，这样就不用在外面套一层nums1</p><h2 id="代码-1">代码</h2><h3 id="自己的-下一个最大元素i">自己的-下一个最大元素I</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums1.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-type">int</span> next = <span class="hljs-number">-1</span>;<span class="hljs-comment">//还没找到，先设置-1</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; nums2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums2[j] == nums1[i]) &#123;<br>                    next = nums2[j];<span class="hljs-comment">//找到了，开始找大</span><br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(next == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//没找到继续找</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums2[j] &gt; next) &#123;<br>                    ans[i] = nums2[j];<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl的-下一个最大元素i">carl的-下一个最大元素I</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums1.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">// key:下标元素，value：下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            umap[nums1[i]] = i;<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">count</span>(nums2[st.<span class="hljs-built_in">top</span>()]) &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 看map里是否存在这个元素</span><br>                    <span class="hljs-type">int</span> index = umap[nums2[st.<span class="hljs-built_in">top</span>()]]; <span class="hljs-comment">// 根据map找到nums2[st.top()] 在 nums1中的下标</span><br>                    result[index] = nums2[i];<br>                &#125;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="下一个更大元素ii">503.下一个更大元素II</h1><h2 id="题目-1"><strong>题目：</strong></h2><p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0]），返回 nums 中每个元素的 下一个更大元素 。</p><p>数字 x 的 下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出-1 。<br />示例 1:<br />输入: nums = [1,2,1]<br />输出: [2,-1,2]<br />解释: 第一个 1 的下一个更大的数是 2；<br />数字 2 找不到下一个更大的数；<br />第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br />示例 2:<br />输入: nums = [1,2,3,4,3]<br />输出: [2,3,4,-1,4]<br />提示:<br /><span class="math inline">\(1 &lt;= nums.length &lt;=10^4\)</span><br /><span class="math inline">\(-10^9 &lt;= nums[i] &lt;=10^9\)</span><br />## <strong>思路：</strong> ### 我的思路</p><p>循环走就行，栈底的肯定最先被再次访问到，如果再次访问到栈底，那就退出，但是栈底还得用一次来挤出靠后的小元素，所以出循环得放在处理元素的后面。</p><p>既然要访问栈底，那用deque模拟栈。剩下的和之前如出一辙。</p><p>运行下来好像我的更快一点点，吼吼吼。 ### carl的思路</p><p>妙哉，把nums倍增一段，就算循环了，可以物理上直接倍增nums，也可以循环的时候把for的次数改成nums.size()*2，下标取模算法倍增。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[dq.<span class="hljs-built_in">back</span>()] &lt; nums[i]) &#123;<br>                ans[dq.<span class="hljs-built_in">back</span>()] = nums[i];<br>                dq.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; i == dq.<span class="hljs-built_in">front</span>()) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//不能放while开头，会少处理</span><br>            <span class="hljs-keyword">if</span>(ans[i] == <span class="hljs-number">-1</span>) dq.<span class="hljs-built_in">push_back</span>(i);<br>            i = (i+<span class="hljs-number">1</span>) % n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>carl的 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">// 模拟遍历两边nums，注意一下都是用i % nums.size()来操作</span><br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="hljs-built_in">size</span>()] &gt; nums[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                result[st.<span class="hljs-built_in">top</span>()] = nums[i % nums.<span class="hljs-built_in">size</span>()];<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day49</title>
    <link href="/2024/07/10/leetcode-day49/"/>
    <url>/2024/07/10/leetcode-day49/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/palindromic-substrings/description/">647.回文子串</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516.最长回文子序列</a> <span class="label label-warning">medium</span></li></ul><h1 id="回文子串">647. 回文子串</h1><p><strong>题目：</strong></p><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p><strong>思路：</strong></p><ol type="1"><li>确定dp含义<br />dp[i][j]表示区间s[i:j]是不是回文串<br /></li><li>确定状态转移<br /></li></ol><ul><li>s[i] == s[j]<ul><li>j - i &lt;= 1，i和j相同或挨着，dp[i][j] = true;</li><li>else，dp[i][j] = dp[i+1][j-1]，看内部是不是回文串</li></ul></li><li>s[i] != s[j]：对不上，s[i:j]不可能是回文串了，false<br /></li></ul><ol start="3" type="1"><li>初始化<br />全false</li></ol><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; s.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j]) &#123;<br>                    <span class="hljs-keyword">if</span>(i == j || i + <span class="hljs-number">1</span> == j || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                        ans++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="双指针写法">双指针写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">//复习双指针写法</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            ans += <span class="hljs-built_in">count</span>(s, i, i);<br>            ans += <span class="hljs-built_in">count</span>(s, i, i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> mid1, <span class="hljs-type">int</span> mid2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(mid2 &gt;= s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = mid1, right = mid2;<br>        <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(s[left] == s[right]) res++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            left--, right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最长回文子串">516. 最长回文子串</h1><p><strong>题目：</strong></p><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong><br />- 输入：s = "bbbab" - 输出：4 - 解释：一个可能的最长回文子序列为 "bbbb"。</p><p><strong>提示：</strong><br />- 1 &lt;= s.length &lt;= 1000 - s 仅由小写英文字母组成</p><p><strong>思路：</strong></p><ol type="1"><li>确定dp含义：<br />dp[i][j]表示区间s[i:j]内的最长回文子串长度<br /></li><li>确定状态转移：<br /></li></ol><ul><li>s[i] == s[j]<ul><li>i == j，dp[i][j]=1</li><li>dp[i][j] = dp[i-1][j-1]+2</li></ul></li><li>s[i] != s[j]: max(dp[i-1][j], dp[i][j-1])</li></ul><ol start="3" type="1"><li>初始化<br />相等的ij就置1</li></ol><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) dp[i][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;j &lt; s.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j]) &#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="其他">其他</h1><p>动态规划跟着carl刷完了，提亮看起来貌似也有这么多，但其中过半都不是自己独立做出来的，看一半题解再做、看了一半还是不会于是全抄……动态规划仍然有很多要学，仍然要多做题，今天的两道题都没有做出来，找其他的回文题仍然不会。</p><p>在做dp专题时其实有很多题的难点是想到要用dp，而做专题本身就已经告诉你每道题都可以用dp，而且carl的题安排精妙，相邻的题很多都是相同的套路，如果单拿出来做，我大概率是做不出出来的，上周周赛的Q4很像完全背包专题中的一道题，但写出来不是TLE就是WA，看评论才发现不能直接dp，所以刷题之路任重道远，戒骄戒躁，不能太依赖题解，要多自己独立思考，更不能潜移默化地被评论、tag提示。不能3分钟没思路就跑去看题解了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day48</title>
    <link href="/2024/07/09/leetcode-day48/"/>
    <url>/2024/07/09/leetcode-day48/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/distinct-subsequences/description/">115.不同的子序列</a> <span class="label label-danger">hard</span></li><li><a href="">583. 两个字符串的删除操作</a> <span class="label label-warning">medium</span></li><li><a href="">72. 编辑距离</a> <span class="label label-warning">medium</span></li></ul><h1 id="不同的子序列">115. 不同的子序列</h1><p><strong>题目：</strong></p><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在<code>s</code> 的 子序列 中 <code>t</code> 出现的个数，结果需要对 <spanclass="math inline">\(10^9 + 7\)</span> 取模。</p><blockquote><p><strong>示例 1：</strong></p><p><strong>输入：</strong> <code>s</code> = <code>"rabbbit"</code>,<code>t</code> = <code>"rabbit"</code></p><p><strong>输出：</strong> 3</p><p><strong>解释：</strong></p><p>如下所示, 有 3 种可以从 <code>s</code> 中得到 <code>"rabbit"</code>的方案。 - <u>rabb</u>b<u>it</u> - <u>ra</u>b<u>bbit</u> -<u>rab</u>b<u>bit</u></p></blockquote><p><strong>思路：</strong></p><ol type="1"><li><p>明确dp数组含义：两个子序列，仍然按照之前的老办法，二维dp，大小比串长度多1，方便初始化，<spanclass="math inline">\(dp[i][j]\)</span>含义为：在<spanclass="math inline">\(s[0:i-1]\)</span>中，<spanclass="math inline">\(t[0:j-1]\)</span>出现的个数。</p></li><li><p>建立状态转移方程：整体分为两种情况：</p><ul><li><span class="math inline">\(s[i-1] ==t[j-1]\)</span>：此时最新的s[i-1]和t[j-1]相同：<ul><li><p>如果算上<span class="math inline">\(s[i-1]\)</span>，<spanclass="math inline">\(t\)</span>就会被消耗一个，此时子序列个数就为<spanclass="math inline">\(dp[i-1][j-1]\)</span>，表示<code>s[0:i-1]中t[0:j-1]出现次数</code></p></li><li><p>但根据示例可看出：即使<spanclass="math inline">\(s[i-1]==t[j-1]\)</span>，<spanclass="math inline">\(s[i-1]\)</span>也可以不用于匹配，这时子序列个数就为<spanclass="math inline">\(dp[i-1][j]\)</span>，表示<code>s[0:i-2]</code>中<code>t[0:j-1]</code>出现次数</p></li></ul></li><li><span class="math inline">\(s[i-1] ≠t[j-1]\)</span>：此时最新的<spanclass="math inline">\(s[i-1]\)</span>和<spanclass="math inline">\(t[j-1]\)</span>不相同，意味着s中未出现新的t，所以只继承前面的结果<spanclass="math inline">\(dp[i-1][j]\)</span>，表示<code>s[0:i-2]</code>中<code>t[0:j-1]</code>出现的次数</li></ul><p>由此可构建出状态转移方程：</p></li></ol><p><span class="math display">\[dp[i][j]\ =\begin{cases}1, &amp; \text{$j=0,\ i&gt;0$} \\0, &amp; \text{$i=0,\ j&gt;0$} \\dp[i-1][j-1]+dp[i-1][j], &amp; \text{$s[i-1]=t[j-1],\ i,\ j&gt;0$} \\dp[i-1][j], &amp; \text{$s[i-1]=t[j-1],\ i,\ j&gt;0$}\end{cases}\]</span></p><p>根据状态转移方程可知需由左上遍历到右下</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt; (t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= t.<span class="hljs-built_in">size</span>();j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= s.<span class="hljs-built_in">size</span>();i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= t.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<span class="hljs-comment">//</span><br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)dp[s.<span class="hljs-built_in">size</span>()][t.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="两个字符串的删除操作">583. 两个字符串的删除操作</h1><p><strong>题目：</strong></p><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得<code>word1</code> 和 <code>word2</code>相同所需的最小步数。</p><p>每步可以删除任意一个字符串中的一个字符。</p><p><strong>示例 1：</strong></p><ul><li>输入: <code>word1</code> = <code>"sea"</code>, <code>word2</code> =<code>"eat"</code></li><li>输出: 2</li><li>解释: 第一步将 <code>"sea"</code> 变为 <code>"ea"</code> ，第二步将<code>"eat "</code>变为 <code>"ea"</code></li></ul><p><strong>思路：</strong></p><p>二维dp：</p><ol type="1"><li>确定dp数组以及下标含义</li></ol><p><span class="math inline">\(dp[i][j]\)</span>表示<spanclass="math inline">\(word1[0:i-1]\)</span>和<spanclass="math inline">\(word2[0:j-1]\)</span>达到相等需要的最小步数</p><ol start="2" type="1"><li>确定递推公式</li></ol><ul><li><span class="math inline">\(word1[i-1] ==word2[j-1]\)</span>时，无需删除，直接继承之前状态</li><li><span class="math inline">\(word1[i-1] ≠ word2[j-1]\)</span>时：<ul><li>删<span class="math inline">\(word1[i-1]\)</span>，步数为<spanclass="math inline">\(dp[i-1][j]+1\)</span></li><li>删<span class="math inline">\(word2[j-1]\)</span>，步数为<spanclass="math inline">\(dp[i][j-1]+1\)</span></li><li>都删了，步数为<span class="math inline">\(dp[i-1][j-1]+2 =dp[i-1][j] + 1\)</span>，和前两种情况相同</li></ul></li></ul><p>状态转移方程为：</p><p><span class="math display">\[dp[i][j]\ =\begin{cases}i, &amp; \text{$i&gt;0,j=0$} \\j, &amp; \text{$j&gt;0,i=0$} \\min(dp[i-1][j], dp[i][j-1])+1, &amp; \text{$i,\ j&gt;0,\word_1[i]≠word_2[j]$} \\dp[i-1][j-1], &amp; \text{else}\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= word2.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= word2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-built_in">size</span>()][word2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="编辑距离">72. 编辑距离</h1><p><strong>题目：</strong></p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将<code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>思路：</strong></p><p>经过前几题，这题要理解到插入其实相当于删除，在一个串中插入，就相当于在另一个串中删除</p><ol type="1"><li>确定dp数组以及下标含义</li></ol><p><span class="math inline">\(dp[i][j]\)</span>表示<spanclass="math inline">\(word1[0:i-1]\)</span>和<spanclass="math inline">\(word2[0:j-1]\)</span>达到相等需要的最小操作数</p><ol start="2" type="1"><li>确定递推公式</li></ol><ul><li><span class="math inline">\(word1[i-1] ==word2[j-1]\)</span>时，无需操作，直接继承之前状态</li><li><span class="math inline">\(word1[i-1] ≠ word2[j-1]\)</span>时：<ul><li>删<span class="math inline">\(word1[i-1]\)</span>，步数为<spanclass="math inline">\(dp[i-1][j]+1\)</span></li><li>删<span class="math inline">\(word2[j-1]\)</span>，步数为<spanclass="math inline">\(dp[i][j-1]+1\)</span></li><li>替换其中一个，步数为<spanclass="math inline">\(dp[i-1][j-1]+1\)</span></li></ul></li></ul><p>状态转移方程为：</p><p><span class="math display">\[dp[i][j]\ =\begin{cases}i, &amp; \text{$i&gt;0,j=0$} \\j, &amp; \text{$j&gt;0,i=0$} \\min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1, &amp; \text{$i,\ j&gt;0,\word_1[i]≠word_2[j]$} \\dp[i-1][j-1], &amp; \text{else}\end{cases}\]</span></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= word2.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= word2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]&#125;) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-built_in">size</span>()][word2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git提交PR</title>
    <link href="/2024/07/08/%E8%AE%B0%E4%B8%80%E6%AC%A1git%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E7%BB%8F%E5%8E%86/"/>
    <url>/2024/07/08/%E8%AE%B0%E4%B8%80%E6%AC%A1git%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E7%BB%8F%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="本文背景">本文背景</h1><p>期末考完想向学长的资料公开仓库贡献一些资料，顺便帮助建设一下混个contributor当当。但是只在自己的大小号上实践过PR(pullrequest)操作的我头一次向别人的repo(repository)提交PR，遂记录过程中遇到的问题和解决方法，倒逼自己搞清楚其中原因。同时也作为提交PR的教程作参考。</p><p>本文关于git操作的说法偏向浅显易懂，稍有啰嗦，如有原理性错误，烦请批评指正，联系方式见<ahref="https://novelyear.github.io/about/">关于页</a>。</p><h1 id="问题描述">问题描述</h1><ol type="1"><li><p>我在GitHub上fork了别人的仓库，然后将fork的仓库pull到本地进行修改，修改后push到fork的仓库的master分支，然后又在github上直接在main分支上新增了内容，请问我该如何将远程仓库的main上的新内容和远程仓库上master分支的内容融合，两个内容并无重合，都是新内容。如何合并分支并提交PR？</p></li><li><p>我在本地又修改了文件，在main分支上commit了该修改，并push到远程仓库上，但是并未发生改变，我更新了远程仓库，然后在main分支fetch了，随后发现本地修改的文件又回到了原状，于是重新修改，并切换到master分支add和commit，在切换回main分支并fetch和pull之后，merge时提示冲突，应该如何解决？</p></li></ol><h1 id="提交pr前的准备工作">提交PR前的准备工作</h1><blockquote><p>提交PR首先得先改好才能交 ## fork目标repo进入目标repo的首页，即页面栏显示<code>Code</code>字样、域名末尾为repo名称的页。</p></blockquote><p>点击fork，将在自己的名下新建一个同名repo，相当于把对方的repo复制到了自己名下，这样就可以任意修改内容而不至于对原repo的内容造成影响，并且，<strong>只有fork了才能向原仓库提交PR</strong>。## 拿到本地进行修改这时名下已经有了一个同名repo，在本地新建个文件夹用来装这个repo的内容，在这个文件夹里打开gitbash，在fork来的repo里复制链接，<code>git pull</code>到本地。</p><blockquote><p>若读者尚未将git与github绑定，请参见：</p></blockquote><p>此时可用<code>git branch</code>查看当前分支，大概率是<code>master</code>，因为<code>git pull</code>只给远程分支不给本地分支名默认为<code>master</code>。</p><p>用<code>git remote -v</code>查看当前远程分支，如果没有，就<code>git remote add BRANCH_NAME URL</code>添加，url就是repo的链接,BRANCH_NAME就是远程分支的名字，一般设置成<code>origin</code>。</p><p>然后就可以开始在本地修改内容啦！</p><h2 id="修改完提交到远程仓库">修改完提交到远程仓库</h2><p>修改完后，再回到gitbash，<code>git add .</code>和<code>git commit</code>，可用<code>git status</code>查看跟踪(add)和提交(commit)的状态。</p><p><code>git push origin master</code>，就当你的远程分支名字是origin，将分支master提交到origin分支上去，即上传到远程仓库。</p><h1 id="提交pr">提交PR</h1><p>此时回到fork来的repo，点击contribute，会显示当前已经领先原repo多少个commit，直接openpr，描述一下修改内容，点击提交就成功提交了PR。</p><h3 id="问题1解决过程">问题1解决过程</h3><blockquote><p>问题1可对应到实际场景中自己工作完成慢了，别人先交了PR过了，自己还得去迎合别人的分支，解决完冲突才能提交。</p></blockquote><p>我在本地修改完后还未提交前，在远程仓库上直接做了修改，这导致我的远程仓库除了我本地修改的内容外，还有其他内容与本地master分支不一样，所以不能直接push</p><p>先在本地再创建一个main分支<code>git checkout main</code>，然后将最新的远程仓库pull到main分支，在本地合并main和master分支<code>git merge master</code></p><p>由于master和远程分支origin修改的地方不同，所以不会有冲突，直接merge成功，然后在main分支上再add、commit、push。</p><p>其实也可以将main融进master中，使master始终最新，方便进一步修改。</p><h3 id="问题2解决过程">问题2解决过程</h3><blockquote><p>问题2对应到实际场景中提交了PR结果被打回重造，这期间又有人交了PR还过了，不得不再去融合别人的分支，可恨的是这个人和你修改的文件还是同一个，还不能直接merge。</p></blockquote><p>仍然在main中pull最新的远程仓库，如果是fork来的，还要先在github上同步。</p><p>然后gitmerge，会显示冲突的文件，在本地打开文件(推荐使用vscode等支持git的IDE，会高亮显示冲突)，找到冲突的地方，会有明显的标志，类似于：<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>// changes from main branch<br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br>// changes from master branch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; master<br></code></pre></td></tr></table></figure>这时需要选择采用当前的分支、采用另一个分支还是融合内容，融合好后才能merge。之后就一般流程：add、commit、push。</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day47</title>
    <link href="/2024/07/08/leetcode-day47/"/>
    <url>/2024/07/08/leetcode-day47/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/longest-common-subsequence/">1143.最长公共子序列</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/uncrossed-lines/">1035.不相交的线</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/is-subsequence/">392.判断子序列</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/maximum-subarray/description/">53.最大子数组和</a> <span class="label label-warning">medium</span></li></ul><h1 id="最长公共子序列">1143. 最长公共子序列</h1><p><strong>题目：</strong></p><p>给定两个字符串 <code>text1</code> 和<code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong>的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code>。</p><p>一个字符串的 <strong>子序列</strong>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但<code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li></ul><p>两个字符串的 <code>公共子序列</code>是这两个字符串所共同拥有的子序列。</p><p><strong>思路：</strong></p><p>有两个string，公共子序列出现的地方可能不同，需要i和j两个变量来记录公共子序列在两个string里的范围，以范围逐渐扩张来实现状态的不断推进，二维动态规划。</p><p><strong>1. 确定dp数组含义</strong></p><p><span class="math inline">\(dp[i][j]\)</span>表示字符串<spanclass="math inline">\(text_1\)</span>长度为i的前缀，即<spanclass="math inline">\(text1[0:i]\)</span>，和<spanclass="math inline">\(text_2\)</span>长度为j的前缀的最长公共子序列的长度。</p><p><strong>2. 确定状态转移方程</strong></p><p><span class="math display">\[dp[i][j]\ =\begin{cases}dp[i-1][j-1]+1, &amp; \text{$text_1[i-1]=text_2[j-1]$} \\max(dp[i-1][j],\ dp[i][j-1]), &amp; \text{$text_1[i-1]≠text_2[j-1]$}\end{cases}\]</span></p><p>解释：</p><ul><li>当<spanclass="math inline">\(text_1[i-1]=text_2[j-1]\)</span>时，<spanclass="math inline">\(text_1\)</span>长度为<spanclass="math inline">\(i\)</span>的前缀结尾与<spanclass="math inline">\(text_2\)</span>长度为<spanclass="math inline">\(j\)</span>的前缀结尾相同，在长度为<spanclass="math inline">\(i-1\)</span>和<spanclass="math inline">\(j-1\)</span>的最长公共子序列基础上再加一，即<spanclass="math inline">\(dp[i-1][j-1]+1\)</span></li><li>当<spanclass="math inline">\(text_1[i-1]≠text_2[j-1]\)</span>时，相当于末尾没对上，这时不能在之前的基础上加一，需要继承之前的结果，而之前有两个前缀：<ul><li><span class="math inline">\(text_1[0:i-1]\)</span>和<spanclass="math inline">\(text_2[0:j]\)</span>的最长公共子序列</li><li><span class="math inline">\(text_2[0:j-1]\)</span>和<spanclass="math inline">\(text_1[0:i]\)</span>的最长公共子序列</li></ul></li><li>取其中最大值。</li></ul><p><strong>3. 初始化</strong></p><p>为了方便初始化，dp数组的大小设置成了<spanclass="math inline">\((text_1.size()+1)*(text_2.size()+1)\)</span>表示一个左闭右开的区间，同时也以下标表示前缀长度。</p><p>此时<spanclass="math inline">\(dp[0][0]\)</span>实际无意义，所以初始化<spanclass="math inline">\(0\)</span>，遍历都从<spanclass="math inline">\(0\)</span>开始。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= text1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= text2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(text1[i - <span class="hljs-number">1</span>] != text2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.<span class="hljs-built_in">size</span>()][text2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="不相交的线">1035. 不相交的线</h1><p><strong>题目：</strong></p><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和<code>nums2</code> 中的整数。</p><p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和<code>nums2[j]</code> 的直线，这些直线需要同时满足：</p><ul><li><code>nums1[i] == nums2[j]</code></li><li>且绘制的直线不与任何其他连线（非水平线）相交。</li></ul><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p><p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p><figure><img src="https://assets.leetcode.com/uploads/2019/04/26/142.png"alt="盗链lc" /><figcaption aria-hidden="true">盗链lc</figcaption></figure><p><strong>思路：</strong></p><p>看图就会发现，这简直就是上一道题换皮，直接套代码就行。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxUncrossedLines</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-comment">//换皮最长公共子序列</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= nums1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= nums2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums1.<span class="hljs-built_in">size</span>()][nums2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="判断子序列">392. 判断子序列</h1><p><strong>题目：</strong></p><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断<strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>"ace"</code>是<code>"abcde"</code>的一个子序列，而<code>"aec"</code>不是）。</p><p><strong>进阶：</strong></p><p>如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k &gt;=10亿，你需要依次检查它们是否为 T的子序列。在这种情况下，你会怎样改变代码？</p><p><strong>思路：</strong></p><p>双指针，短的匹配到再走，长的一直走，短的走到头则是子序列。</p><p>动态规划：</p><ul><li>参考1143题的初始化方法，dp数组初始化为<spanclass="math inline">\((s.size()+1)*(t.size()+1)\)</span>，使<spanclass="math inline">\(dp[0][0]\)</span>无意义。遍历都从1开始。</li><li><span class="math inline">\(dp[i][j]\)</span>代表<spanclass="math inline">\(s[0:i-1]\)</span>和<spanclass="math inline">\(t[0:j-1]\)</span>公共子序列长度</li><li>状态转移方程为：</li></ul><p><span class="math display">\[dp[i][j]\ =\begin{cases}dp[i-1][j-1]+1, &amp; \text{$s[i-1]=t[j-1], i,j&gt;0$} \\dp[i][j-1], &amp; \text{$else$}\end{cases}\]</span></p><ul><li>匹配到则推进状态，公共子序列长度加一</li><li>未匹配则继承状态，注意<spanclass="math inline">\(s\)</span>不前进而<spanclass="math inline">\(t\)</span>前进，代表继续在<spanclass="math inline">\(t\)</span>中寻找<spanclass="math inline">\(s[i]\)</span></li></ul><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &gt; t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//开大一个，方便处理0情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= t.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<span class="hljs-comment">//匹配，i和j都往前走</span><br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<span class="hljs-comment">//未匹配，s不能动，t往前走</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()][t.<span class="hljs-built_in">size</span>()] == s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//如果s走到最后，则是</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最大子数组和">53. 最大子数组和</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><p><strong>思路：</strong></p><p>依据贪心的思路，可以迁移到动态规划来，贪心就是和为负之后，就对之后没有贡献了，直接抛弃，将下一个作为新起点重新计算子数组和，动态规划也可以这样：</p><ul><li><span class="math inline">\(dp[i]\)</span>代表以<spanclass="math inline">\(nums[i]\)</span>结尾的最大子数组和</li><li>若<spanclass="math inline">\(dp[i-1]&lt;0\)</span>，则抛弃，以当前<spanclass="math inline">\(nums[i]\)</span>作为新起点：<spanclass="math inline">\(dp[i] = nums[i]\)</span></li><li>若<spanclass="math inline">\(dp[i-1]&gt;=0\)</span>，则继承结果：<spanclass="math inline">\(dp[i] = dp[i-1]+nums[i]\)</span></li><li><span class="math inline">\(dp[0]\)</span>按意义该初始化为<spanclass="math inline">\(nums[0]\)</span></li><li>用一个变量记录其中最大的子数组和</li></ul><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(dp[i - <span class="hljs-number">1</span>] &lt;= <span class="hljs-number">0</span>) dp[i] = nums[i];<br>            <span class="hljs-keyword">else</span> dp[i] = dp[i - <span class="hljs-number">1</span>] + nums[i];<br>            ans = <span class="hljs-built_in">max</span>(dp[i], ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day45</title>
    <link href="/2024/07/07/leetcode-day45/"/>
    <url>/2024/07/07/leetcode-day45/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674.最长连续递增子序列</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718.最长重复子数组</a> <span class="label label-warning">medium</span></li></ul><h1 id="最长递增子序列">300. 最长递增子序列</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code>是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>思路：</strong></p><p><span class="math inline">\(dp[i]\)</span>表示以<spanclass="math inline">\(nums[i]\)</span>结尾的最长递增子序列长度，强制以<spanclass="math inline">\(nums[i]\)</span>结尾为的是方便状态转移，状态转移方程为：</p><p><span class="math display">\[dp[i]\ =\begin{cases}1, &amp; \text{$i = 1$} \\max(dp[j] + 1, dp[i]), &amp; \text{$i &gt; 1,\ j=0,1,2,……,i-1$}\end{cases}\]</span></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; i;j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[j] + <span class="hljs-number">1</span>, dp[i]);<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最长连续递增子序列">674. 最长连续递增子序列</h1><p><strong>题目：</strong></p><p>给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 <code>l</code> 和<code>r</code>（<code>l &lt; r</code>）确定，如果对于每个<code>l &lt;= i &lt; r</code>，都有<code>nums[i] &lt; nums[i + 1]</code> ，那么子序列<code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code>就是连续递增子序列。</p><p><strong>思路：</strong></p><p>这题感觉就像贪心一样，一直换起点就好，dp换起点就是重新把长度改成1</p><p>dp[i]表示以i结尾的最长连续递增序列长度，状态转换方程为：</p><p><span class="math display">\[dp[i]\ =\begin{cases}1, &amp; \text{$nums[i] ≤ nums[i - 1]$}\\dp[i - 1] + 1, &amp; \text{$nums[i]≥nums[i-1]$}\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-number">1</span>;<br><br>            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最长重复子数组">718. 最长重复子数组</h1><p><strong>题目：</strong></p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度 。</p><p><strong>思路：</strong></p><p>由于两个数组的公共子数组起点可能不一样，所以得用<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>分别表示从<spanclass="math inline">\(nums1\)</span>的<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(nums2\)</span>的<spanclass="math inline">\(j\)</span>开始。</p><p>状态转移方程为：(前提条件都为<code>nums1[i] == nums2[j]</code>)</p><p><span class="math display">\[dp[i][j]\ =\begin{cases}1, &amp; \text{$i=0\ or\ j=0$} \\dp[i-1][j-1]+1, &amp; \text{else}\end{cases}\]</span></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; nums2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums1[i] != nums2[j]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) dp[i][j]  = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                ans = <span class="hljs-built_in">max</span>(ans, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day44</title>
    <link href="/2024/07/07/leetcode-day44/"/>
    <url>/2024/07/07/leetcode-day44/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188.买卖股票的最佳时机Ⅳ</a> <span class="label label-danger">hard</span></li><li><a href="">309. 最佳买卖股票时机含冷冻期</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714.买卖股票的最佳时机含手续费</a> <span class="label label-warning">medium</span></li></ul><h1 id="买卖股票的最佳时机ⅳ">188. 买卖股票的最佳时机Ⅳ</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中<code>prices[i]</code> 是某支给定的股票在第 <code>i</code>天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code>笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code>次。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>思路：</strong></p><p>股票题3只能买两次，设置了5个状态，无、1有、1无、2有、2无，迁移到这里就是无 + k组有无，一共<span class="math inline">\(2*k+1\)</span>个状态。</p><p>使用三维dp时空复杂度太过感人，就不写思路了，直接写carl的二维简化版思路：</p><p><span class="math inline">\(dp[i][j]\)</span>表示第<spanclass="math inline">\(i\)</span>天的情况，<spanclass="math inline">\(j\)</span>为状态：</p><ul><li><span class="math inline">\(0\)</span>表示无操作</li><li><span class="math inline">\(1\)</span>表示第一次卖掉</li><li><span class="math inline">\(2\)</span>表示第一次买入</li><li><span class="math inline">\(3\)</span>表示第二次卖掉</li><li><span class="math inline">\(4\)</span>表示第二次买入</li><li>……</li><li><span class="math inline">\(2k-1\)</span>表示第<spanclass="math inline">\(k\)</span>次卖掉</li><li><span class="math inline">\(2k\)</span>表示第<spanclass="math inline">\(k\)</span>次买入</li></ul><p>可见偶数表示买入，奇数表示卖出，详细解释见代码注释：</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt; <span class="hljs-number">2</span> * k;j += <span class="hljs-number">2</span>)<br>      dp[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>];<span class="hljs-comment">//首日买入都是直接减</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>;j += <span class="hljs-number">2</span>) &#123;<br>        dp[i][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j] - prices[i]);<span class="hljs-comment">//i天前交易j+1次不买 = 昨天前交易j+1次没买/昨天前交易j次买了，今天卖掉</span><br>        dp[i][j + <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + prices[i]);<span class="hljs-comment">//i天前交易j+2次买 = 昨天前交易j+1次就买了，今天卖掉/昨天就交易j+2次，已经卖了</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>*k];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最佳买卖股票时机含冷冻期">309. 最佳买卖股票时机含冷冻期</h1><p><strong>题目：</strong></p><p>给定一个整数数组prices，其中第 prices[i] 表示第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>思路：</strong></p><p>没想出来，状态设置出了问题</p><p>卖出后会有冷冻期，由于只有一支股票，所以冷冻期只能无操作，则一天会有4个状态：</p><ul><li>0：无操作</li><li>1：卖出</li><li>2：买入</li><li>3：冷冻期</li></ul><p><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/518d5baaf33f4b2698064f8efb42edbf.png" /></p><p>知道这个就好写代码了</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-comment">//可多次，但不能连续</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//0无操作，1卖，2买，3冷冻</span><br>    dp[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>      dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>      dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] + prices[i]);<br>      dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] - prices[i]);<span class="hljs-comment">//昨天买好/昨天冷冻今天买</span><br>      dp[i][<span class="hljs-number">3</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机含手续费">714. 买卖股票的最佳时机含手续费</h1><p><strong>题目：</strong></p><p>给定一个整数数组 <code>prices</code>，其中<code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数<code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>思路：</strong></p><p>题目的注意指出每组买卖只需要交一次手续费，那设置在卖出时缴纳手续费，其余代码同股票2题一样</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//0buy, 1sell</span><br>    dp[<span class="hljs-number">0</span>] = &#123;-prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] - prices[i]);<br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] + prices[i] - fee);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day43</title>
    <link href="/2024/07/07/leetcode-day43/"/>
    <url>/2024/07/07/leetcode-day43/</url>
    
    <content type="html"><![CDATA[<p>今日内容：股票专题日🤑</p><ul><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121.买卖股票的最佳时机</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122.买卖股票的最佳时机Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123.买卖股票的最佳时机Ⅲ</a> <span class="label label-danger">hard</span></li></ul><h1 id="买卖股票的最佳时机">121. 买卖股票的最佳时机</h1><p><strong>题目：</strong></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素<code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在<strong>未来的某一个不同的日子</strong>卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回<code>0</code> 。</p><p><strong>思路：</strong></p><p>很明显的状态转移，昨天买了和昨天没有买两种情况，昨天买了今天就卖或者持有，昨天没买今天就买或者继续观望，最后返回今天卖了或不卖中的最大值。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = prices.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], -prices[i]);<span class="hljs-comment">//昨天买了；昨天没买今天买</span><br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], prices[i] + dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>]);<span class="hljs-comment">//昨天没买；昨天买了今天卖</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[(len - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<span class="hljs-comment">//卖了肯定比拿手里强，返回卖了的</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机ⅱ">122. 买卖股票的最佳时机Ⅱ</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code>表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候<strong>最多</strong> 只能持有 <strong>一股</strong>股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 你能获得的 <strong>最大</strong> 利润 。</p><p><strong>思路：</strong></p><p>与上一题的区别在于，这题可以多次买卖，如果按贪心来做的话，直接累积上升就可以。</p><p>按dp来做，仍然保留买与没买的状态区别，对于买的状态要修改，上一道题只能买一次，所以买必定是第一次，从0开始算盈亏。这里就需要记录之前的盈亏，因为买不一定是第一次。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-comment">//dp非滚动写法</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    dp[<span class="hljs-number">0</span>] = &#123;-prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//0买，1不买</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-comment">//与上一题的区别：-prices[i]变成了dp[i-1 % 2][1] - prices[i]，在昨天没买的基础上计算</span><br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] - prices[i]); <span class="hljs-comment">//i天买，昨天买了不能再买/昨天没买今天买</span><br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] + prices[i]); <span class="hljs-comment">//i天不买，昨天没买/昨天买了今天卖掉</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机ⅲ">123. 买卖股票的最佳时机Ⅲ</h1><p><strong>题目：</strong></p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第<code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成<strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>思路：</strong></p><p>只能买两次，所以变复杂了很多，<del>不愧是hard，一下给我干趴下了</del>，思路是抄的，没想出来😭</p><p>根据之前的经验，可以分为买和不买两种状态，由于这里只能买卖两次，所以分为四种状态（或者说阶段 ）：</p><ul><li>第一次还没买</li><li>第一次买了在手里</li><li>第二次还没买（第一次已经卖掉了）</li><li>第二次卖掉了</li></ul><p>每个状态都可以如之前一样分别由昨天和今天来得到，取最大值，于是得到如下代码</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<span class="hljs-comment">// 相当于第一天买了卖再买，可不能设成0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>      dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<span class="hljs-comment">//第一次有，昨天就买了；昨天没有，今天才买第一个</span><br>      dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<span class="hljs-comment">//第一次没有，昨天就没有；昨天有，今天才卖掉第一个</span><br>      dp[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<span class="hljs-comment">//第二次有，昨天就有；昨天没有，今天才买第二个</span><br>      dp[i][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);<span class="hljs-comment">//第二次没有，昨天就没有；昨天有，今天才卖掉第二个</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<span class="hljs-comment">//</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day42</title>
    <link href="/2024/07/07/leetcode-day42/"/>
    <url>/2024/07/07/leetcode-day42/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/house-robber/">198.打家劫舍</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/house-robber-ii/description/">213.打家劫舍Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/house-robber-iii/description/">337.打家劫舍Ⅲ</a> <span class="label label-warning">medium</span></li></ul><h1 id="打家劫舍">198. 打家劫舍</h1><p><strong>题目：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><ul><li><p>示例 1：</p></li><li><p>输入：[1,2,3,1]</p></li><li><p>输出：4</p></li><li><p>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。</p></li><li><p>示例 2：</p></li><li><p>输入：[2,7,9,3,1]</p></li><li><p>输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 =9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12。</p></li><li><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 400</li></ul></li></ul><p><strong>思路：</strong></p><p>跟着随想录刷题相当于做题看了tag，所以有思路提示，一开始就知道能够用动态规划来解。</p><p>dp[i]代表打劫[0, i]区间内的房屋的最高金额，状态转换方程如下：</p><p><span class="math display">\[dp[i]\ =\begin{cases}nums[0], &amp; \text{$i\ =\ 0$} \\max(nums[0],\ nums[1]), &amp; \text{$i\ =\ 1$} \\max(dp[i - 2] + nums[i],\ dp[i - 1]), &amp; \text{else}\end{cases}\]</span></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) dp[i] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>      <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>  &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="打家劫舍ⅱ">213. 打家劫舍Ⅱ</h1><p><strong>题目：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈</strong>，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下</strong>，今晚能够偷窃到的最高金额。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>一开始想复杂了：由于循环，所以从某处开始，相当于把上一个给去掉，然后仍然按线性来遍历，于是遍历物品，把每种物品都做一次开头再遍历背包，然后选出最多的一个。这样时间复杂度来到了<spanclass="math inline">\(O(n^2)\)</span></p>          </div><p>实际上这道题和前一道题区别不大，多出的循环机制可以分成两种情况：</p><ul><li>含首不含尾 <imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160821374-20230310134003961.jpg" /></li><li>含尾不含首 <imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160842491-20230310134008133.jpg" /></li></ul><p>所以只需要两种情况都走一遍取最大值就好了。 ## 代码</p><h3 id="自己过题的复杂代码">自己过题的复杂代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<span class="hljs-comment">//每个nums[i]作起点的初始化</span><br>      dp[i][<span class="hljs-number">0</span>] = nums[i];<br>      dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[i], nums[(i+<span class="hljs-number">1</span>)%nums.<span class="hljs-built_in">size</span>()]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;j &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;j++) &#123;<span class="hljs-comment">//每个i都做一次起点，都打劫一遍，去掉i之前的一个</span><br>        dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">2</span>] + nums[(i + j) % nums.<span class="hljs-built_in">size</span>()], dp[i][j - <span class="hljs-number">1</span>]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>      ans = <span class="hljs-built_in">max</span>(ans, dp[i][nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl的更优代码">carl的更优代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> result1 = <span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>); <span class="hljs-comment">// 情况二</span><br>        <span class="hljs-type">int</span> result2 = <span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 情况三</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result1, result2);<br>    &#125;<br>    <span class="hljs-comment">// 198.打家劫舍的逻辑</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (end == start) <span class="hljs-keyword">return</span> nums[start];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[start] = nums[start];<br>        dp[start + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start + <span class="hljs-number">2</span>; i &lt;= end; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[end];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><ahref="https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 打家劫舍Ⅱ</a></p><h1 id="打家劫舍ⅲ">337. 打家劫舍Ⅲ</h1><p><strong>题目：</strong></p><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为<code>root</code> 。</p><p>除了 <code>root</code>之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong>，房屋将自动报警。</p><p>给定二叉树的 <code>root</code> 。返回<strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额 。</p><p><strong>思路：</strong></p><p><strong>暴力递归：</strong></p><p>跟之前的按监控的题很像，然后思维定势直接后序遍历了，结果美美TLE。又用map来记录已经算过的值防止重复计算，这才AC。</p><p>这个思路和监控题很类似，当前树有两种打劫法：</p><ul><li>打劫儿子，放过根和孙子</li><li>打劫根和孙子，放过儿子</li></ul><p>只要找出最大的就行了。</p><p><strong>树形DP：</strong></p><p>由于是树，还是单向指针，所以不能像之前那样靠dp[i -2]来做到间隔抢劫，得不断上传“抢没抢”的信息，所以每次递归都要返回两个值，抢了当前节点的最大赃款和不抢当前节点的最大赃款。</p><p>递归终止条件自然是遇到null，直接返回0就行，遍历肯定后序遍历，因为处理root得先得到子树的信息，那么单层遍历就是先左再右，最后求出抢root的最大赃款和不抢root的最大赃款，全都返回，再返回最大的一个。</p><h2 id="代码-1">代码</h2><h3 id="暴力递归">暴力递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  unordered_map&lt;TreeNode *, <span class="hljs-type">int</span>&gt; map;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, grandson = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>      <span class="hljs-keyword">return</span> root-&gt;val;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right) &#123;<br>      <span class="hljs-keyword">if</span>(map[root-&gt;right]) right = map[root-&gt;right];<br>      <span class="hljs-keyword">else</span> &#123;<br>        right = <span class="hljs-built_in">rob</span>(root-&gt;right);<br>        map[root-&gt;right] = right;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(!map[root-&gt;right-&gt;left]) &#123;<br>        map[root-&gt;right-&gt;left] = <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;left);<br>      &#125;<br>      grandson += map[root-&gt;right-&gt;left];<br>      <span class="hljs-keyword">if</span>(!map[root-&gt;right-&gt;right]) map[root-&gt;right-&gt;left] = <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;right);<br>      grandson += map[root-&gt;right-&gt;right];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;left)&#123;<br>      <span class="hljs-keyword">if</span>(map[root-&gt;left]) left = map[root-&gt;left];<br>      <span class="hljs-keyword">else</span> &#123;<br>        left = <span class="hljs-built_in">rob</span>(root-&gt;left);<br>        map[root-&gt;left] = left;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(!map[root-&gt;left-&gt;left]) &#123;<br>        map[root-&gt;left-&gt;left] = <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;left);<br>      &#125;<br>      grandson += map[root-&gt;left-&gt;left];<br>      <span class="hljs-keyword">if</span>(!map[root-&gt;left-&gt;right]) map[root-&gt;left-&gt;left] = <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;right);<br>      grandson += map[root-&gt;left-&gt;right];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(root-&gt;val + grandson, left + right);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="树形dp">树形dp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result = <span class="hljs-built_in">robTree</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result[<span class="hljs-number">0</span>], result[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 长度为2的数组，0：不偷，1：偷</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">robTree</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left);<br>        vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right);<br>        <span class="hljs-comment">// 偷cur，那么就不能偷左右节点。</span><br>        <span class="hljs-type">int</span> val1 = cur-&gt;val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况</span><br>        <span class="hljs-type">int</span> val2 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> &#123;val2, val1&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day41</title>
    <link href="/2024/07/06/leetcode-day41/"/>
    <url>/2024/07/06/leetcode-day41/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/coin-change/">322.零钱兑换</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/perfect-squares/description/">279.完全平方数</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/word-break/description/">139.单词拆分</a> <span class="label label-warning">medium</span></li></ul><h1 id="零钱兑换">322. 零钱兑换</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>coins</code>，表示不同面额的硬币；以及一个整数 <code>amount</code>，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong>。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>思路：</strong></p><p>完全背包，dp[j]含义为凑成j需要的最少硬币个数，状态转移方程为：</p><p><span class="math display">\[dp[j]\ =\begin{cases}0, &amp; \text{$j\ =\ 0$} \\min(dp[j\ -\ coin[i]] + 1, dp[j]), &amp; \text{else}\end{cases}\]</span></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; coins.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = coins[i];j &lt;= amount;j++) &#123;<br>        <span class="hljs-keyword">if</span>(dp[j - coins[i]] != INT_MAX) dp[j] = <span class="hljs-built_in">min</span>(dp[j - coins[i]] + <span class="hljs-number">1</span>, dp[j]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount] == INT_MAX ? <span class="hljs-number">-1</span> : dp[amount];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="完全平方数">279. 完全平方数</h1><p><strong>题目：</strong></p><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p><p>完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9和 16 都是完全平方数，而 3 和 11 不是。</p><p><strong>思路：</strong></p><p>其实一开始考虑了数学，但只是记得有相关的数论结论，忘了具体内容，于是果断采用程序员做法————直接dp，很明显的完全背包，只是要求最少数量，把dp含义改一下就好，同时也要根据新的状态转移方程决定新的初始化方式。</p><p>dp[j]表示整数j需要的完全平方数的最少数量</p><p>状态转移方程为：</p><p><span class="math display">\[dp[j]\ =\begin{cases}0, &amp; \text{$j\ =\ 0$} \\min(dp[j], dp[j - i*i] + 1), &amp; \text{$j\ ≥\ i^2, i\ =\ 1,2,3,……$} \\\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-built_in">sqrt</span>(n);i &gt; <span class="hljs-number">0</span>;i--) &#123;<span class="hljs-comment">//稍微剪了剪枝，无伤大雅</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i*i; j &lt;= n;j++) &#123;<br>        <span class="hljs-keyword">if</span>(dp[j - i*i] != INT_MAX) dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - i*i] + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="单词拆分">139. 单词拆分</h1><p><strong>题目：</strong></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code>作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code>则返回 <code>true</code>。</p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>思路：</strong></p><p>把s看成要填满的背包，从dict里一个一个试着装，这时候就不能太死板，要灵活迁移dp的含义：</p><p>dp[j]表示区间[0, j)的s能不能被表示</p><p>那么状态转移方程为：</p><p><span class="math display">\[dp[j] =\begin{cases}true, &amp; \text{$j = 0$} \\dp[j]\ OR\ (dp[j - wordDict[i].size()]\ AND\ s(j\ -\wordDict[i].size())\ ==\ wordDict[i]), &amp; \text{else}\end{cases}\]</span></p><ul><li>还要想到：这里必须先遍历背包容量再遍历字典，不然无法实现拼接，而是一直在判断s的开头。</li><li>还可以对字典去去重</li></ul><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= s.<span class="hljs-built_in">size</span>();j++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; wordDict.<span class="hljs-built_in">size</span>();i++) &#123;<br>          <span class="hljs-keyword">if</span>(j &gt;= wordDict[i].<span class="hljs-built_in">size</span>()) dp[j] = dp[j] || (dp[j - wordDict[i].<span class="hljs-built_in">size</span>()] &amp;&amp; <span class="hljs-built_in">strcmp</span>(s, j - wordDict[i].<span class="hljs-built_in">size</span>(), j, wordDict[i]));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()];<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end, string word)</span> </span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; end;i++) &#123;<br>      <span class="hljs-keyword">if</span>(s[i] != word[j++]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day40</title>
    <link href="/2024/07/05/leetcode-day40/"/>
    <url>/2024/07/05/leetcode-day40/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.acwing.com/problem/content/3/">完全背包</a></li><li><a href="https://leetcode.cn/problems/coin-change-ii/">518.零钱兑换Ⅱ</a> <span class="label label-warning">medium</span></li><li><a href="">377. 组合总和Ⅳ</a> <span class="label label-warning">medium</span></li></ul><h1 id="完全背包">完全背包</h1><p><strong>题目：</strong></p><p>有<span class="math inline">\(N\)</span>种物品和一个容量是<spanclass="math inline">\(V\)</span>的背包，每种物品都有无限件可用。</p><p>第<span class="math inline">\(i\)</span>种物品的体积是<spanclass="math inline">\(v_i\)</span>，价值是<spanclass="math inline">\(w_i\)</span>。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><p><strong>输入格式：</strong></p><p>第一行两个整数，<span class="math inline">\(N\)</span>，<spanclass="math inline">\(V\)</span>，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有<span class="math inline">\(N\)</span>行，每行两个整数<spanclass="math inline">\(v_i\)</span>,<spanclass="math inline">\(w_i\)</span>，用空格隔开，分别表示第<spanclass="math inline">\(i\)</span>种物品的体积和价值。</p><p><strong>输出格式:</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p><span class="math inline">\(0&lt;N,V≤1000\)</span></p><p><span class="math inline">\(0&lt;v_i,w_i≤1000\)</span></p><p><strong>思路：</strong></p><p>相对于01背包，物品数量不受限制，可以多次放入，那么就要改动容量倒序遍历，容量倒序遍历原本目的是为了防止多次放入，但现在可以多次放入，不能防止，所以改为顺序遍历，其他不变。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(N)</span>, <span class="hljs-title">w</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i] ;<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i];j &lt;= V;j++) &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[V] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="零钱兑换ⅱ">518. 零钱兑换Ⅱ</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数<code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回<code>0</code> 。</p><p>假设每一种面额的硬币有无限个。</p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>思路：</strong></p><p>硬币无限+凑总金额，很容易看出使用完全背包。题目所求硬币组合数，和昨天的<ahref="https://leetcode.cn/problems/target-sum/">目标和</a>很像，核心代码都是<code>dp[j] += dp[j - nums[i]]</code>，照着样子套就行。</p><p>carl强调：要注意遍历的顺序，首先完全背包遍历背包容量时要顺序遍历以实现多次拿取，其次要先遍历物品再遍历背包容量，不然就会求成排列数而非组合数：</p><ul><li>先物品后容量 ==&gt; 组合数</li><li>先容量后物品 ==&gt; 排列数</li></ul><p>可自推dp数组画图</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-type">int</span> N = coins.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = coins[i];j &lt;= amount;j++) &#123;<br>                dp[j] += dp[j - coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="组合总和ⅳ">377. 组合总和Ⅳ</h1><p><strong>题目：</strong></p><p>给你一个由<strong>不同</strong> 整数组成的数组 <code>nums</code>，和一个目标整数 <code>target</code> 。请你从 <code>nums</code>中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。 <div class="note note-light">            <p><strong>示例 1：</strong></p><p><strong>输入：</strong>nums = [1,2,3], target = 4</p><p><strong>输出：</strong>7</p><p><strong>解释：</strong></p><p>所有可能的组合为：</p><p>(1, 1, 1, 1)</p><p>(1, 1, 2)</p><p>(1, 2, 1)</p><p>(1, 3)</p><p>(2, 1, 1)</p><p>(2, 2)</p><p>(3, 1)</p><p>请注意，顺序不同的序列被视作不同的组合。</p>          </div></p><p><strong>思路：</strong></p><p>有上一道题的经验，安排这题作为下一题非常合适，直接当场体会遍历顺序对结果的影响。</p><p>这道题所求组合个数，但却又在示例中说明顺序不同的序列视作不同组合，与通用概念存在矛盾。不过总之是求通用概念的排列数，先遍历容量再遍历物品即可。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= target;j++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; j) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> dp[j] += dp[j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day38</title>
    <link href="/2024/07/05/leetcode-day38/"/>
    <url>/2024/07/05/leetcode-day38/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/last-stone-weight-ii/description/">1049.最后一块石头的重量Ⅱ</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/ones-and-zeroes/description/">474.一和零</a> <span class="label label-warning">medium</span></li></ul><h1 id="最后一块石头的重量">1049. 最后一块石头的重量</h1><p><strong>题目：</strong></p><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中<code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为<code>x</code> 和 <code>y</code>，且<code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code>的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为<code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头<strong>最小的可能重量</strong> 。如果没有石头剩下，就返回<code>0</code>。</p><p><strong>思路：</strong></p><p><del>一次周赛的Q4，很有档次啊</del></p><p>今天的三道题都是这种类型的题目，01背包的情景应用，我把这种类型概括为“分堆儿”。</p><p>这道题有点难走到“分堆儿”的思路上，卡住我的是这个思想：</p><div class="note note-light">            <p>石块两两粉碎，把所有石头分成两堆，每次分别拿出一块来对碰粉碎，实际上<strong>一次粉碎过程，两堆都损失了相同的重量</strong>。</p>          </div><p>理解到这一点，就能想到将石块分成<strong>尽可能相近的两堆</strong>，其差值就是<strong>最小可能重量</strong>。那问题就变成了昨天的分割等和了，一下就能套上01背包问题</p><ul><li>包容量就是总和sum的一半(两堆尽量相近)</li><li>物品数量就是石头数量，物品价值和体积都是石头重量</li><li>把包装满就是最大重量为sum/2限制下能得到的最重子堆<code>dp[sum/2]</code></li><li>另一堆就是<code>sum - dp[sum/2]</code>，两堆相减即可，可以相减的原因就是上面所说，也可以详见<ahref="https://leetcode.cn/problems/last-stone-weight-ii/solutions/817930/zui-hou-yi-kuai-shi-tou-de-zhong-liang-i-95p9/">力扣官解的前言证明</a></li></ul><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : stones) sum += i;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; stones.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = dp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;j &gt;= stones[i];j--) &#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);<span class="hljs-comment">//套路</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - dp[sum/<span class="hljs-number">2</span>] - dp[sum/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="目标和">494. 目标和</h1><p><strong>题目：</strong></p><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code>。</p><p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code>，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加<code>'+'</code> ，在 <code>1</code> 之前添加<code>'-'</code>，然后串联起来得到表达式 <code>"+2-1"</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同<strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [1,1,1,1,1], target = 3</p><p>输出：5</p><p>解释：一共有 5 种方法让最终目标和为 3 。</p><ul><li>-1 + 1 + 1 + 1 + 1 = 3</li><li>+1 - 1 + 1 + 1 + 1 = 3</li><li>+1 + 1 - 1 + 1 + 1 = 3</li><li>+1 + 1 + 1 - 1 + 1 = 3</li><li>+1 + 1 + 1 + 1 - 1 = 3</li></ul></blockquote><p><strong>思路：</strong></p><p>这题就已经明示要“分堆儿”了，将nums分为正数部分和负数部分，使正数加负数等于target。</p><p>由于01背包求的是<strong>最大价值</strong>，和这里的<strong>最多种类数</strong>不一样，所以不能直接套，得改dp的含义。</p><p>dp[j] 代表总和为j的包有dp[j]种装法</p><p>那么状态转移方程为：</p><p><span class="math display">\[dp[j] =\begin{cases}1, &amp; \text{$j = 0$} \\dp[j], &amp; \text{$j &lt; nums[i]$} \\dp[j] + dp[j - nums[i]], &amp; \text{$else$}\end{cases}\]</span></p><p>dp[0] = 1的原因： 由于会涉及到<code>dp[j - nums[i]]</code>，如果j正好等于nums[i]，那么只能直接装入，只有一种方法。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) sum += i;<br>        <span class="hljs-type">int</span> V = sum + target;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(V % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        V /= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(V &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> N = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">// </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = dp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;j &gt;= nums[i];j--) &#123;<br>                dp[j] += dp[j - nums[i]];<br>            &#125;   <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[V];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="一和零">474. 一和零</h1><p><strong>题目：</strong></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p><strong>思路：</strong></p><p>让选个子集出来，情景已经很贴近01背包模板了，只是背包体积同时有两个维度的限制：0的个数和 1的个数</p><p>那判断两次能不能装下不就好了，多加一个循环。</p><p>这里的物品价值就是串的个数，因为最后看的是长度，所以在状态转移那里是加一。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> N = strs.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">//dp[i][j]表示容量为m个0和n个1的包最多装多少个</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>      <span class="hljs-type">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : strs[i]) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;0&#x27;</span>) zeroNum++;<br>        <span class="hljs-keyword">else</span> oneNum++;<br>      &#125;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j &gt;= zeroNum;j--) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = n;k &gt;= oneNum;k--) &#123;<br>          dp[j][k] = <span class="hljs-built_in">max</span>(dp[j][k], dp[j - zeroNum][k - oneNum] + <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day37</title>
    <link href="/2024/07/04/leetcode-day37/"/>
    <url>/2024/07/04/leetcode-day37/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">01背包问题二维</a></li><li><ahref="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">01背包问题一维</a></li><li><ahref="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416.分割等和子集</a> <span class="label label-warning">medium</span></li></ul><h1 id="背包问题">01背包问题</h1><p><strong>题目：</strong></p><p>有<span class="math inline">\(N\)</span>件物品和一个容量是<spanclass="math inline">\(V\)</span>的背包。每件物品只能使用一次。</p><p>第<span class="math inline">\(i\)</span>件物品的体积是<spanclass="math inline">\(v_i\)</span>，价值是<spanclass="math inline">\(w_i\)</span>。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，<span class="math inline">\(N\)</span>，<spanclass="math inline">\(V\)</span>，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有<span class="math inline">\(N\)</span>行，每行两个整数 <spanclass="math inline">\(v_i\)</span>,<spanclass="math inline">\(w_i\)</span>，用空格隔开，分别表示第<spanclass="math inline">\(i\)</span>件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p><span class="math inline">\(0&lt;N,V≤1000\)</span></p><p><span class="math inline">\(0&lt;vi,wi≤1000\)</span></p><p><strong>思路：</strong></p><p><strong>二维基础版：</strong></p><p>dp[i][j]表示从0-i号物品选，背包容量为j，能装的最大价值。</p><p>对于第i件物品</p><ul><li>若容量不够（<spanclass="math inline">\(j&lt;w[i]\)</span>），则dp[i][j] = dp[i -1][j]，继承价值</li><li>若容量足够：<ul><li>放入后价值为dp[i - 1][j - v[i]] + w[i]</li><li>不放入价值为dp[i - 1][j]，取其中最大值。</li></ul></li></ul><p>可得状态转移方程为：</p><p><span class="math display">\[dp[i][j] =\begin{cases}0, &amp; \text {$j=0$} \\w[i], &amp; \text{$i=0$} \\max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]), &amp; \text{$else$}\end{cases}\]</span></p><p><strong>一维优化版：</strong></p><p>由于只需要最终状态，利用滚动数组优化空间</p><p>dp[j]表示背包容量为j时能装的最大价值</p><div class="note note-warning">            <p>对于j的遍历，即枚举背包容量时需要逆序。</p><p>当进入下一层容量枚举时，新增了物品i，而此时的dp还是对于物品i-1的状态，如果顺序枚举，则枚举到中间就会用到之前的状态，但此时之前的状态已经包含了物品i，会造成重复装入，相当于把dp[i- 1][j - v[i]]用成了dp[i][j - v[i]]。</p>          </div><h2 id="代码">代码</h2><h3 id="二维版">二维版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(V + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[<span class="hljs-number">0</span>];j &lt; V;j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = w[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= V;j++) &#123;<br>            <span class="hljs-keyword">if</span>(j &lt; v[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[N<span class="hljs-number">-1</span>][V] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一维版">一维版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V + <span class="hljs-number">1</span>)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = V;j &gt;= v[i];j--) &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[V] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化输入版">优化输入版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> f[MAXN];  <span class="hljs-comment">// </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;   <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> v, w;<br>        cin &gt;&gt; v &gt;&gt; w;      <span class="hljs-comment">// 边输入边处理</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v; j--)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);<br>    &#125;<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>来源：<a href="https://www.acwing.com/solution/content/1374/">AcWing2. 01背包问题（状态转移方程讲解）</a></p><h1 id="分割等和子集">416. 分割等和子集</h1><p><strong>题目：</strong></p><p>给你一个<strong>只包含正整数</strong>的<strong>非空</strong>数组<code>nums</code>。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>思路：</strong></p><p>提前告诉了要用01背包，不然还看不出来是01背包。</p><p>套用的关键在于搞清楚在当前场景下，物品价值w[i]、物品体积v[i]、背包容量V、物品数量N分别代表什么。</p><p>容易想到要从nums中找到一组数使其和为总和的一半，所以考虑总和的一半作为背包容量，nums中的数的值作为物品的体积</p><p>关于为什么物品的价值也是nums中数的值没想明白，下面是目前的解释，对于价值的解释好像偷换概念了：</p><blockquote><p>由于最后要知道背包到底装满没，所以至少得算到dp[sum/2]，也就是容量为sum/2的包里最多能装多少“价值”，，此时并不知道这个“价值”是不是sum/2,也可能比sum/2小，比如1、5、5、11当容量为6时dp[6]=dp[5]=5，所以得判断dp[j]是不是sum/2，所以dp里的值得是数值。</p></blockquote><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) sum += i;<br><br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        sum /= <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">40001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = sum;j &gt;= nums[i];j--) &#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[sum] == sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day36</title>
    <link href="/2024/07/03/leetcode-day36/"/>
    <url>/2024/07/03/leetcode-day36/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/unique-paths/description/">62.不同路径</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/unique-paths-ii/">63.不同路径Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/integer-break/description/">343.整数拆分</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/unique-binary-search-trees/description/">96.不同的二叉搜索树</a> <span class="label label-warning">medium</span></li></ul><h1 id="不同路径">62. 不同路径</h1><p><strong>题目：</strong></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start”）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>思路：</strong></p><p>由于方向定死只能朝着目标走，不允许走回头路，所以走到一个格子只可能从其左边或上面来到，那么这就不难直接想出递推公式：</p><p><span class="math display">\[dp[i][j] =\begin{cases}1, &amp; \text {$i = 1 or j = 1$} \\dp[i - 1][j] + dp[i][j - 1], &amp; \text {else}\end{cases}\]</span> dp[i][j]表示从起点走到第[i, j]格的所有路径数</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="不同路径ⅱ">63. 不同路径Ⅱ</h1><p><strong>题目：</strong></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start”）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>其实思路差不多，由于笔者追求尽可能少的改动，只加了一行代码就想过关，结果被特殊用例坑了两发WA😭，怎么障碍物会出现在起点和终点啊，落地成盒+通天河老鼋是吧🤡</p>          </div><p>仍然动态规划，只是状态转移方程要改一下，应该遍历整个地图，如果发现障碍物，就把这一格的dp置零表示此路不通，由于笔者代码有点问题，所以还另有改动，在地图边缘的格子不能无脑置1，得继承上一格数值，防止跳过了障碍物。</p><p>carl的代码也有类似思想</p><h2 id="代码-1">代码</h2><h3 id="个人代码">个人代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>(), n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> || obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">1</span>) dp[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) dp[i][j] = i == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="官解代码">官解代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = obstacleGrid.<span class="hljs-built_in">size</span>(), m = obstacleGrid.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>).<span class="hljs-built_in">size</span>();<br>        vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">f</span>(m);<span class="hljs-comment">//压缩了dp数组</span><br><br>        f[<span class="hljs-number">0</span>] = (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>);<span class="hljs-comment">//起点能不能走</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//遇障置零</span><br>                    f[j] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//非首列</span><br>                    f[j] += f[j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>利用滚动数组压缩空间，滚动数组就是上一篇只用3个变量来压缩整个dp数组的思想，抛弃掉之前不用的状态，只获取最终状态，这里也一样，从上到下的路径是继承的，而从左到右的路径是累加的。而外层大循环就是改变行，每行都会继承上一行的结果。</p><h1 id="整数拆分">343. 整数拆分</h1><p><strong>题目：</strong></p><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2），并使这些整数的乘积最大化。</p><p>返回 你可以获得的最大乘积 。</p><p><strong>思路：</strong></p><p>本来该用dp的，但是数学直觉给我指了另一条路，高中学过基本不等式，有口诀为“和定积最大，积定和最小”，而此处就是“和定”，由基本不等式最值条件可知，每个数应该尽量相等（尽量是因为得是整数，不然必须相等），而拆分的数量简单一推就知道先增后减：</p><p>比如12：</p><ul><li>分为2个数：<span class="math inline">\(6*6=36\)</span></li><li>分为3个数：<span class="math inline">\(4 * 4 * 4 = 64\)</span></li><li>分为4个数：<span class="math inline">\(3^4=81\)</span></li><li>分为5个数：<span class="math inline">\(2 * 2 * 2 * 3 * 3 =72\)</span></li><li>分为6个数：<span class="math inline">\(2^6=64\)</span></li></ul><p>先增后减，所以从2开始一直增加拆分数，一旦积开始减少，就说明到达最值点了。</p><p><del>官解的数学证明好复杂，看起来很抽象啊，导数大题只得了6分的我看不懂，还是不等式选修秒杀更舒服</del></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//和定积最大，基本不等式定调均分</span><br>    <span class="hljs-comment">//随便举几个例子可大致知道k先增后减，存在峰值</span><br>    <span class="hljs-comment">//但均分不好实现，如10分为2233或2224，均分应该使方差最小</span><br>    <span class="hljs-comment">//逐步除法也许可以实现最均分，尝试一下</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>;k &lt;= n;k++) &#123;<span class="hljs-comment">//等分数量</span><br>            <span class="hljs-type">int</span> m = n, temp = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k;i &gt; <span class="hljs-number">0</span>;i--) &#123;<span class="hljs-comment">//已经获得的加子数量</span><br>                temp *= m / i;<br>                m -= m / i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(temp &gt; ans) ans = temp;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>均分方法蒙对了，没严格证明，至少能AC</p><h1 id="不同的二叉搜索树">96. 不同的二叉搜索树</h1><p><strong>题目：</strong></p><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>思路：</strong></p><p>有点多项式定理的感觉，<del>沉睡的高中数学之魂复燃？</del>，画图可能比较好理解，但是图书馆要闭馆了，没时间画图了。</p><p>根据其示例可以得到提示：以不同的数做根来分类讨论，以4为例</p><ul><li>若1作根，则剩余3个数形成的BST个数就是当前BST的个数总数，由示例得到为5</li><li>若2作根，则剩余2个数3、4只能在右子树，当前BST总数就是2节点BST的总数2</li><li>若3作根，则4只能在右子树，左子树是2节点BST总数2</li><li>若4作根，则1、2、3都在左子树，就是3节点BST总数，5</li></ul><p>所以4节点BST总数为5+2+2+5。</p><p>由此发散，联想多项式定理，可得状态转移方程：</p><p><span class="math display">\[dp[i] =\begin{cases}1, &amp; \text {$i = 0 or i = 1$} \\\sum_{root=1}^i (dp[root-1]*dp[i-root]), &amp; \text {$i &gt; 1$}\end{cases}\]</span></p><p>dp[i] 代表有i个节点的BST种数;</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++) &#123;<span class="hljs-comment">//节点数</span><br>            <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;root &lt;= i;root++) &#123;<span class="hljs-comment">//谁做根</span><br>                temp += dp[root - <span class="hljs-number">1</span>] * dp[i - root];<br>            &#125;<br>            dp[i] = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day35</title>
    <link href="/2024/07/03/leetcode-day35/"/>
    <url>/2024/07/03/leetcode-day35/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/fibonacci-number/">509.斐波那契数</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/climbing-stairs/description/">70.爬楼梯</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">746.使用最小花费爬楼梯</a> <span class="label label-success">easy</span></li></ul><h1 id="斐波那契数">509. 斐波那契数</h1><p><strong>题目：</strong></p><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code>表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由<code>0</code> 和 <code>1</code>开始，后面的每一项数字都是前面两项数字的和。也就是：</p><blockquote><p>F(0) = 0，F(1) = 1</p><p>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p></blockquote><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>思路：</strong></p><p>由于是dp训练，所以不能直接递归或套公式。</p><p>递推公式题目有，直接dp，没有优化空间复杂度。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="爬楼梯">70. 爬楼梯</h1><p><strong>题目：</strong></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>思路：</strong></p><ol type="1"><li>只有45个数，打表🤓</li><li>直接dp！</li><li>套斐波那契公式🤓</li></ol><p>dp递归公式如下：</p><p><span class="math display">\[dp[n]=\begin{cases}1, &amp; \text {$n=1$} \\2, &amp; \text {$n=2$} \\dp[n-1]+dp[n-2], &amp; \text {$n&gt;3$}\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="使用最小花费爬楼梯">746. 使用最小花费爬楼梯</h1><p><strong>题目：</strong></p><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>思路：</strong></p><p>直接dp！递推公式如下：</p><p><span class="math display">\[dp[n]=\begin{cases}0, &amp; \text {$n = 1 or 0$} \\min(dp[n-1]+cost[n-1], dp[n-2]+cost[n-2]), &amp; \text {$n&gt;1$}\end{cases}\]</span></p><p>没有优化空间复杂度，感觉可有可无，优化也不复杂，具体优化方法见<ahref="https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html">代码随想录| 使用最小花费爬楼梯</a></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(cost.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(cost[<span class="hljs-number">0</span>], cost[<span class="hljs-number">1</span>]);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size() + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= cost.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[cost.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day34</title>
    <link href="/2024/07/01/leetcode-day34/"/>
    <url>/2024/07/01/leetcode-day34/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/merge-intervals/description/">56.合并区间</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/monotone-increasing-digits/">738.单调递增的数字</a> <span class="label label-warning">medium</span></li><li><a href=""></a> <span class="label label-danger">hard</span></li></ul><h1 id="合并区间">56. 合并区间</h1><p><strong>题目：</strong></p><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] =[starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p><strong>思路：</strong></p><p>与昨天的重叠区间类型问题一样，按开始点排序，有重合就合并，没重合就新维护</p><div class="note note-light">            <p>忽然诧异怎么这道题显示已解决，查看提交记录发现这道题在几个月前做过，当初WA4发才做出来结果击败5%，真是感慨</p><p>回首向来萧瑟处，也无风雨也无晴，虽然一直感觉在蹉跎人生，但实际上我还是有一点小小的进步，加油共勉！</p>          </div><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; b )</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> left = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], right = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; intervals.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt; right) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;left, right&#125;);<br>                left = intervals[i][<span class="hljs-number">0</span>];<br>                right = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>            right = <span class="hljs-built_in">max</span>(right, intervals[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;left, right&#125;);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="单调递增的数字">738. 单调递增的数字</h1><p><strong>题目：</strong></p><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y时，我们称这个整数是单调递增的。</p><p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>没做出来，做的时候脑子有点不舒服，所以歇逼了</p>          </div><p>此题局部最优策略为，如果数字本身就满足“单调递增”要求，则直接返回该数字即可，若出现反例，即高位大于低位，则将高位减1低位置9</p><p>将此局部最优策略应用至全局即可得到最优解，具体代码实现方式见注释。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>&#123;<br>        string strNum = <span class="hljs-built_in">to_string</span>(N);<br>        <span class="hljs-type">int</span> flag = strNum.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// flag用来标记赋值9从哪里开始</span><br>        <span class="hljs-comment">// 设置为超限默认值，为了防止第二个for循环在flag没有被赋值的情况下执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = strNum.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-comment">//倒序遍历数位，若连续出现高位大于低位，则连续减一高位并记录计划变为9的位数</span><br>            <span class="hljs-keyword">if</span> (strNum[i - <span class="hljs-number">1</span>] &gt; strNum[i] ) &#123;<span class="hljs-comment">//如果出现高位大于低位，则将高位减1，同时记录低位位数为flag</span><br>                flag = i;<br>                strNum[i - <span class="hljs-number">1</span>]--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = flag; i &lt; strNum.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-comment">//由于从后往前，所以最后得到的计划变9位将是最高的，把后面所有数变9只会增大数字从而得到最优解</span><br>            strNum[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span>(strNum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="监控二叉树">968. 监控二叉树</h1><p><strong>题目：</strong></p><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象</strong>。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>思路：</strong></p><p><del>不会做😭，抄了</del></p><p>由于涉及二叉树，可以套路化地想到尝试递归遍历，题目所求最少摄像头数量，最少一般是贪心或者dp，那就得分析状态，考虑局部最优全局最优或者状态之间的转移。</p><p>在这道题中，一个节点的状态有三种：放了摄像头+被覆盖+没覆盖，关于二叉树的状态容易联想到从两个子树的状态得到当前root树的状态，那么又可以想到：如果子树的根left或者right有摄像头+仅仅被覆盖+没被覆盖这三种状态，这三种状态转移到整个树的状态的方式就为：1. 如果left或right有一个没被覆盖，则root需要放置摄像头； 2.如果left或者right有一个有摄像头，则root不需要放置； 3.如果left和right都只是被覆盖，那么root需要补一个摄像头。</p><p>但这并没有取最优化，仅仅只是状态转移，所以不是dp。</p><p>dp做法官方题解和灵神的不太一样，树形dp没看懂，dp做法以后再看吧。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//0:无覆盖，1：有摄像头，2：有覆盖</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) &#123;<br>            result++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) result++;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day33</title>
    <link href="/2024/07/01/leetcode-day33/"/>
    <url>/2024/07/01/leetcode-day33/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452.用最少数量的箭引爆气球</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/non-overlapping-intervals/description/">435.无重叠区间</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/partition-labels/description/">763.划分字母区间</a> <span class="label label-warning">medium</span></li></ul><h1 id="用最少数量的箭引爆气球">452. 用最少数量的箭引爆气球</h1><p><strong>题目：</strong></p><p>有一些球形气球贴在一堵用 XY平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] =[x_start, x_end] 表示水平直径在 x_start 和x_end之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x处射出一支箭，若有一个气球的直径的开始和结束坐标为 x_start，x_end，且满足 x_start ≤ x ≤ x_end，则该气球会被 引爆 。可以射出的弓箭的数量没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p><p><strong>思路：</strong></p><p>按照直观思维，肯定要找重叠部分，再按贪心分析，局部最优是射重叠部分，全局最优是尽可能多射重叠部分来减少箭数</p><p>此时不妨画个图来分析，脑子好也可以直接想象，用线段表示气球直径范围，以下图为例，很容易看出答案是两根箭，但是我们是如何得出答案的呢，背后的依赖逻辑是什么</p><figure><img src="https://s3.bmp.ovh/imgs/2024/07/01/7513d5db99cbc545.png"alt="帮助分析线段图" /><figcaption aria-hidden="true">帮助分析线段图</figcaption></figure><p>此时发散思维，不难想到跟开始和结束点有关，此前做过类似题则更容易想到，以结束点为标准，从左往右开始射，必须照顾到最早结束的气球，否则就会漏掉，那么我们就能得到如下贪心策略：（大白话版）</p><p>按起点排序，记录气球结束点按最近的来，若结束点超过了这个最近结束点，则一支箭就不够了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//按起点排序，记录气球结束点按最近的来，若结束点超过了这个最近结束点，则一支箭就不够了</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> end = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> nextBallon = <span class="hljs-number">0</span>;<span class="hljs-comment">//新的起点</span><br>        <span class="hljs-type">int</span> arrow = <span class="hljs-number">1</span>;<span class="hljs-comment">//箭数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; points.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(end &lt; points[i][<span class="hljs-number">0</span>]) &#123;<br>                nextBallon = i;<br>                arrow++;<br>                end = points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>            end = <span class="hljs-built_in">min</span>(end, points[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arrow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="无重叠区间">435. 无重叠区间</h1><p><strong>题目：</strong></p><p>给定一个区间的集合 intervals ，其中 intervals[i] = [start_i, end_i]。返回需要移除区间的最小数量，使剩余区间互不重叠 。</p><p><strong>思路：</strong></p><p>由于之前做过一道安排活动的题目，大概意思就是有很多活动(区间)，请在不重叠的前提下安排尽可能多的活动。与此题很像</p><p>安排活动题就是按结束时间从早到晚排序，先安排早的，这样就有局部最优：留出更多的时间给之后的活动，如果结束时间相同，则为了多，选择更短的活动，以留出更多时间给更早的活动</p><p>那么这道题也可以迁移这个策略，移除最少就是保留最多嘛。</p><p>这道题比较经典，carl给了很多思路，建议阅读：<ahref="https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 无重叠区间</a></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] == b[<span class="hljs-number">1</span>] ? a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>] : a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">//移除最少那就保留最多，移除长的，保留短的</span><br>    <span class="hljs-comment">//保留最多就要流出足够多的时间给后面的区间，所以结束时间要早</span><br>    <span class="hljs-comment">//那么应该按结束时间排序，如果结束相同，那么选择开始时间最晚的</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> save = <span class="hljs-number">1</span>;<span class="hljs-comment">//保留的活动数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; intervals.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &lt; end) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                save++;<br>                end = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - save;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="划分字母区间">763. 划分字母区间</h1><p><strong>题目：</strong></p><p>给你一个字符串 s。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是s 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><p><strong>思路：</strong></p><p>一开始有点懵，然后迁移之前的思路想到可以将字母出现的范围视作区间，那就又成了区间不重叠问题。</p><p>但这个思路编码有点复杂，速度也不快</p><p>carl的直截了当思路简直优雅👍:</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20201222191924417.png"alt="太巧妙辣！" /><figcaption aria-hidden="true">太巧妙辣！</figcaption></figure><h2 id="代码-2">代码</h2><h3 id="个人14代码">个人14%代码😭</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//尽可能多的片段，且是分割，是连续的，只在前面出现的字母，统计各字母首次和默次出现构成区间</span><br>    <span class="hljs-comment">//按区间开始排序，目的是分出尽可能多的组，原理相同</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; points;<span class="hljs-comment">//存各字母的区间</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-comment">//获取s中各字母的区间</span><br>        points = <span class="hljs-built_in">getSection</span>(s);<br>        <span class="hljs-comment">//写代码能力太弱，有点费时间啊……</span><br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> right = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; points.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; right) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>                left = points[i][<span class="hljs-number">0</span>];<br>            &#125;<br>            right = <span class="hljs-built_in">max</span>(right, points[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">getSection</span>(string s) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">alpha</span>(<span class="hljs-number">26</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>));<span class="hljs-comment">//全部字母都留出空</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(alpha[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">-1</span>) alpha[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>] = i;<span class="hljs-comment">//起点只记一次</span><br>            alpha[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>] = i;<span class="hljs-comment">//终点不断更新</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; alpha.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(alpha[i][<span class="hljs-number">0</span>] != <span class="hljs-number">-1</span>) res.<span class="hljs-built_in">push_back</span>(alpha[i]);<span class="hljs-comment">//结果只记录出现过的</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl优雅代码">carl优雅代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        <span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// i为字符，hash[i]为字符出现的最后位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 统计每一个字符最后出现的位置</span><br>            hash[S[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            right = <span class="hljs-built_in">max</span>(right, hash[S[i] - <span class="hljs-string">&#x27;a&#x27;</span>]); <span class="hljs-comment">// 找到字符出现的最远边界</span><br>            <span class="hljs-keyword">if</span> (i == right) &#123;<br>                result.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day31</title>
    <link href="/2024/06/30/leetcode-day31/"/>
    <url>/2024/06/30/leetcode-day31/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/gas-station/description/">134.加油站</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/candy/description/">135.分发糖果</a> <span class="label label-danger">hard</span></li><li><ahref="https://leetcode.cn/problems/lemonade-change/description/">860.柠檬水找零</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406.根据身高重建队列</a> <span class="label label-warning">medium</span></li></ul><h1 id="加油站">134. 加油站</h1><p><strong>题目：</strong></p><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1个加油站需要消耗汽油 cost[i]升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 gas 和 cost，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。如果存在解，则 保证 它是 唯一 的。</p><p><strong>思路：</strong></p><p>贪心算法是从局部最优一直推到整体最优，那么对于解从起点开始的每一小段，肯定油都是有剩的，即∑gas[i]- ∑cost[i] &gt; 0，如果有一段内的油少于需要，则肯定不是解从开头的段</p><p>开一个数组loss表示loss[i] = gas[i] -cost[i]，肯定从正数开始，如果加到中间变负了，证明从开始到这里都不行，换下一站做起点，不断搜索即可。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">loss</span><span class="hljs-params">((<span class="hljs-type">int</span>)gas.size())</span></span>;<br>        <span class="hljs-type">int</span> sumg = <span class="hljs-number">0</span>, sumc = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; gas.<span class="hljs-built_in">size</span>();i++) &#123;<br>            loss[i] = gas[i] - cost[i];<br>            sumg += gas[i];<br>            sumc += cost[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sumg &lt; sumc) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//油不够，直接-1</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; loss.<span class="hljs-built_in">size</span>()) &#123;<br>            sum += loss[i++];<br>            <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>) &#123;<br>                sum = <span class="hljs-number">0</span>;<br>                ans = i;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i == ans) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//回到起点</span><br>            <span class="hljs-keyword">if</span>(ans &gt; <span class="hljs-number">0</span> &amp;&amp; i == loss.<span class="hljs-built_in">size</span>()) i = <span class="hljs-number">0</span>;<span class="hljs-comment">//循环，注意起点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="分发糖果">135. 分发糖果</h1><p><strong>题目：</strong></p><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><p><strong>思路：</strong></p><p>个人击败5%思路：</p><ul><li>如果相比上一个更大，则糖果比上一个人多一个，这没得说</li><li>如果相比上一个相同，则先置为1，后续再操作</li><li>如果更小，此时需要往前维护糖果大小关系，细节见代码</li></ul><p>carl思路：</p><p>两次遍历，分别维护两种相邻情况的糖果大小关系，顺序维护递增的加一关系，倒序维护递减的关系，巧妙啊</p><h2 id="代码-1">代码</h2><h3 id="个人5代码">个人5%代码😭</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//需要注意的就是1234321这种例子，不能想当然按照两格滑动窗口解题，也不能左右同时走</span><br>    <span class="hljs-comment">//往前，如果比前一个小，则置位1，同时维护之前的大小关系，直到遇到下降</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candys</span><span class="hljs-params">(ratings.size())</span></span>;<br>        candys[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; ratings.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candys[i] = candys[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ratings[i] == ratings[i - <span class="hljs-number">1</span>]) candys[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ratings[i] &lt; ratings[i - <span class="hljs-number">1</span>]) &#123;<br>                candys[i] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(candys[i - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)  &#123;<span class="hljs-comment">//维护先前的大小关系，必须倒着加回去</span><br>                <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>) &#123;<br>                    candys[j]++;<br>                    <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; candys[j] &lt; candys[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; ratings[j] &gt;= ratings[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span>;<br>                    j--;<br>                &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; candys.<span class="hljs-built_in">size</span>();i++) sum += candys[i];<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl代码">carl代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candyVec</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 从前向后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candyVec[i] = candyVec[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从后向前</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] ) &#123;<br>                candyVec[i] = <span class="hljs-built_in">max</span>(candyVec[i], candyVec[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 统计结果</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candyVec.<span class="hljs-built_in">size</span>(); i++) result += candyVec[i];<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="柠檬水找零">860. 柠檬水找零</h1><p><strong>题目：</strong></p><p>在柠檬水摊上，每一杯柠檬水的售价为 5美元。顾客排队购买你的产品，（按账单 bills支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 bills ，其中 bills[i] 是第 i位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false。</p><p><strong>思路：</strong></p><p>很简单，记住5块有多少，10块有多少，遇到10块补5块，遇到20优先给出10块，没有10块就全给5块，中间给不出就false，能找完就true</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>&#123;<br>        <span class="hljs-type">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : bills) &#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">5</span>) five++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">10</span>) ten++, five--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ten == <span class="hljs-number">0</span>) five -= <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">else</span> ten--, five--;<br>            <span class="hljs-keyword">if</span>(ten &lt; <span class="hljs-number">0</span> || five &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="根据身高重建队列">406. 根据身高重建队列</h1><p><strong>题目：</strong></p><p>假设有打乱顺序的一群人站成一个队列，数组 people表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第i 个人的身高为 hi ，前面 <strong>正好</strong> 有 ki 个身高大于或等于 hi的人。</p><p>请你重新构造并返回输入数组 people所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj,kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p><strong>思路：</strong></p><p>有两个标准，不难想到应该先用身高排序，由高到低，其中相同身高的k由低到高，因为这样才能更便捷地调换位置，满足k的需要。</p><p>然后按照k来插入即可。注意使用list，底层由链表实现，插入效率较高，这题对于语法要求还有点高，得多熟悉这些不那么常用的API。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; p1, vector&lt;<span class="hljs-type">int</span>&gt; &amp; p2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> p1[<span class="hljs-number">0</span>] == p2[<span class="hljs-number">0</span>] ? p1[<span class="hljs-number">1</span>] &lt; p2[<span class="hljs-number">1</span>] : p1[<span class="hljs-number">0</span>] &gt; p2[<span class="hljs-number">0</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que; <span class="hljs-comment">// list底层是链表实现，插入效率比vector高的多</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 插入到下标为position的位置</span><br>            std::list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = que.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">while</span> (position--) &#123;<br>                it++;<br>            &#125;<br>            que.<span class="hljs-built_in">insert</span>(it, people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(que.<span class="hljs-built_in">begin</span>(), que.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day30</title>
    <link href="/2024/06/22/leetcode-day30/"/>
    <url>/2024/06/22/leetcode-day30/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/jump-game/description/">55.跳跃游戏</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/jump-game-ii/description/">45.跳跃游戏II</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/">1005.K次取反后最大化的数组和</a> <span class="label label-success">easy</span></li></ul><h1 id="买卖股票的最佳时机ii">122. 买卖股票的最佳时机II</h1><p><strong>题目：</strong></p><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><p><strong>思路：</strong></p><p>披着medium皮的easy题，统计所有上升就好了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) res += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="跳跃游戏">55. 跳跃游戏</h1><p><strong>题目：</strong></p><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回false 。</p><p><strong>思路：</strong></p><p>从终点倒着走，不断找能跳到当前的点，并将其更新为新的终点，如果最后终点来到了0，就找到了，反之则没有</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> end = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//4</span><br>        <span class="hljs-type">int</span> newend = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;<span class="hljs-comment">//3</span><br>        <span class="hljs-keyword">while</span>(newend &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(end - newend &gt; nums[newend]) newend--;<br>            <span class="hljs-keyword">else</span> &#123;<br>                end = newend;<br>                newend--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(end == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="跳跃游戏ii">45.跳跃游戏II</h1><p><strong>题目：</strong></p><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p><p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><ul><li>0 &lt;= j &lt;= nums[i]</li><li>i + j &lt; n</li></ul><p>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n -1]。</p><p><strong>思路：</strong></p><p>贪心就是贪个最远能到达的距离，当前在一个地方，这个地方前面有一个范围，范围呢每个点又有范围，找的就是有最远范围的下一个点。</p><p>写得感觉有点冗余，过用例的时候错一个改一条，突然就AC了，没细察。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> current = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(current &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> currentMaxRange = current + nums[current];<br>            <span class="hljs-keyword">if</span>(currentMaxRange &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> nextStepMaxRange = currentMaxRange;<br>            <span class="hljs-type">int</span> nextStep = current;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = current + <span class="hljs-number">1</span>;i &lt;= currentMaxRange;i++) &#123;<br>                <span class="hljs-keyword">if</span>(nextStepMaxRange &lt; i + nums[i]) &#123;<br>                    nextStepMaxRange = i + nums[i];<br>                    nextStep = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nextStepMaxRange &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans + <span class="hljs-number">2</span>;<br>            current = nextStep;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="k次取反后最大化的数组和">1005.K次取反后最大化的数组和</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p><ul><li>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。</li></ul><p>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p><p>以这种方式修改数组后，返回数组 可能的最大和 。</p><p><strong>思路：</strong></p><p>见<ahref="https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html">代码随想录</a></p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp);       <span class="hljs-comment">// 第一步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 第二步</span><br>            <span class="hljs-keyword">if</span> (A[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>) &#123;<br>                A[i] *= <span class="hljs-number">-1</span>;<br>                K--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) A[A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>; <span class="hljs-comment">// 第三步</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) result += a;        <span class="hljs-comment">// 第四步</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day29</title>
    <link href="/2024/06/21/leetcode-day29/"/>
    <url>/2024/06/21/leetcode-day29/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/assign-cookies/description/">455.分发饼干</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/wiggle-subsequence/description/">376.摆动序列</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/maximum-subarray/description/">53.最大子数组和</a> <span class="label label-warning">medium</span></li></ul><h1 id="分发饼干">455. 分发饼干</h1><p><strong>题目：</strong></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j分配给孩子 i，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>思路：</strong></p><p>见<ahref="https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 分发饼干</a></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123;<br>                result++;<br>                index--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="摆动序列">376. 摆动序列</h1><p><strong>题目：</strong></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7,3) 是正负交替出现的。</p><p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5]不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度。</p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 1000</li><li>0 &lt;= nums[i] &lt;= 1000</li></ul><p><strong>思路：</strong></p><p>符号转换一次就记一次数。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sign = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(nums[i] - nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                sign = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                sign = <span class="hljs-number">0</span>;<br>            &#125;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最大子数组和">53. 最大子数组和</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><p><strong>思路：</strong></p><p>见<ahref="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 最大子数组和</a></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = INT_MIN;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            sum += nums[i];<br>            res = <span class="hljs-built_in">max</span>(res, sum);<br>            <span class="hljs-keyword">if</span>(sum &lt;= <span class="hljs-number">0</span>) sum = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day28</title>
    <link href="/2024/06/19/leetcode-day28/"/>
    <url>/2024/06/19/leetcode-day28/</url>
    
    <content type="html"><![CDATA[<p>期末复习压力大，简单写写，暑假再补</p><p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/non-decreasing-subsequences/description/">491.非递减子序列</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/permutations/description/">46.全排列</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/permutations-ii/description/">47.全排列Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/reconstruct-itinerary/description/">332.重新安排行程</a> <span class="label label-danger">hard</span></li><li><a href=""></a></li><li><a href=""></a></li></ul><h1 id="非递减子序列">491. 非递减子序列</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素。你可以按 任意顺序 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>思路：</strong></p><p>难点在于去重，例如[1,2,3,1,1]这样的用例，就要注意不要在解空间树第一层重复取1，最后得到重复的[1,1]和[1,1,1]，解空间树单层去重方法为在单层递归中创建一个作用域仅限于单层递归函数内的记录变量数组，用过就记录，之后再用就跳过，具体代码实现方法见下</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">-101</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; nums, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(<span class="hljs-number">210</span>, <span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">//这就是作用域仅在单层的记录变量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; pre) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[nums[i] + <span class="hljs-number">100</span>]) <span class="hljs-keyword">continue</span>;<br>            used[nums[i] + <span class="hljs-number">100</span>] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            pre = nums[i];<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            pre = !temp.<span class="hljs-built_in">empty</span>() ? temp.<span class="hljs-built_in">back</span>() : <span class="hljs-number">-101</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="全排列">46. 全排列</h1><p><strong>题目：</strong></p><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以按任意顺序 返回答案。</p><p><strong>思路：</strong></p><p>在程序设计课上写那么久，之前一直踩坑全局used，这下终于能尽情全局used了，手速题，10min秒了</p><p>carl哥的方法明明和我一样，只是把used下传了，但就是快，也许是语法因素？</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(used[i]) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        used.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">backtrack</span>(nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="全排列ⅱ">47. 全排列Ⅱ</h1><p><strong>题目：</strong></p><p>给定一个可包含重复数字的序列 nums ，按任意顺序返回所有不重复的全排列。</p><p><strong>思路：</strong></p><p>又是去重，由于任意顺序，所以可以排序，对于[1,1,2]这样的用例，需要注意的就是不要来两个[1,1,2]，光把前两个1交换了。</p><p>去重标准可设为：相同元素仅允许最先一个作为开头，之后的相同元素不可做开头，但可做后缀。</p><p>翻译成代码就是<code>if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue;</code></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[i]) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        used.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">backtrack</span>(nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="重新安排行程">332. 重新安排行程</h1><p><strong>题目：</strong></p><p>给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi]表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><p>所有这些机票都属于一个从JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p><p>例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。假定所有机票至少存在一种合理的行程。且<strong>所有的机票 必须都用一次 且只能用一次</strong>。</p><p><strong>思路：</strong></p><p>首先看懂题目，类似哥尼斯堡七桥问题，也就是欧拉回路，就是要找到一条路，能把所有路走一遍且不重复，而此题还额外要求字典序最小。</p><p>那么可以直观得到如下思路：</p><ol type="1"><li>找到当前节点能够去到的 所有 下一个节点，按字典序由小到大排好序</li><li>从最小字典序节点开始dfs，如果最后没能用光机票而走入死路，则换次小字典序节点继续寻找，直到找到。</li></ol><p>思路其实不难，主要在于代码实现，carl合理选择了适当的容器来做，代码时间打败98%，但我这次独立完成，主要记录个人解题思路，目前最优解仍为carl的题解，详见：<ahref="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E6%80%9D%E8%B7%AF">代码随想录| 重新安排行程</a>。</p><p>对于我的思路，具体代码实现遇到的问题见代码注释，直接叙述效果不佳</p><h2 id="代码-3">代码</h2><h3 id="个人代码可怜的5">个人代码（可怜的5%😭）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<span class="hljs-comment">//存欧拉道路</span><br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<span class="hljs-comment">//记录哪些tickets的下标已经被用过，即用过的机票</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt; &amp;tickets, string start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == tickets.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//根据start得到接下来的目标，选取可用的机票，按字典序从小到大排列</span><br>        <span class="hljs-comment">//按下标存方便used记录，按名称存不好记录哪些机票用过了，后续会出问题，于是两个合在一起存，排序自定义</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, string&gt;&gt; nextPort;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; tickets.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(!used[i] &amp;&amp; tickets[i][<span class="hljs-number">0</span>] == start) &#123;<br>                nextPort.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, string&gt;(i, tickets[i][<span class="hljs-number">1</span>]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nextPort.<span class="hljs-built_in">begin</span>(), nextPort.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-comment">//遍历接下来的机场，如果找到答案，则直接返回，如果没有，则换次小字典序机场再找</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nextPort.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(used[nextPort[i].first]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//超时尝试剪枝，对于相同机票，可失败后跳过后续所有相同机票</span><br>            <span class="hljs-comment">//剪枝后成功AC，但用时仅超过5%，丢人</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nextPort[i].second == nextPort[i - <span class="hljs-number">1</span>].second) <span class="hljs-keyword">continue</span>;<br>            used[nextPort[i].first] = <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nextPort[i].second);<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtrack</span>(tickets, nextPort[i].second)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            used[nextPort[i].first] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果走到这一步，证明走错，返回false</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, string&gt; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, string&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.second.<span class="hljs-built_in">compare</span>(b.second) &lt; <span class="hljs-number">0</span>;<span class="hljs-comment">//按照字典序排序</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        used.<span class="hljs-built_in">resize</span>(tickets.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<span class="hljs-comment">//记录哪些机票已经被用过</span><br>        path.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<span class="hljs-comment">//起点不会被加入，所以提前加入</span><br>        <span class="hljs-built_in">backtrack</span>(tickets, <span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl的优质代码个人注释版">carl的优质代码个人注释版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//才注意到carl哥把自己实现的方法都private了，细节！</span><br><span class="hljs-comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span><br>unordered_map&lt;string, map&lt;string, <span class="hljs-type">int</span>&gt;&gt; targets;<span class="hljs-comment">// 起点 -&gt; (目的地，剩余可飞次数)</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == ticketNum + <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//找齐了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//回传成功信号，也算剪枝了吧，不用再遍历后续的target了</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (pair&lt;<span class="hljs-type">const</span> string, <span class="hljs-type">int</span>&gt;&amp; target : targets[result[result.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]]) &#123;<span class="hljs-comment">//细节引用，result[result.size() - 1]就是前一个机场，targets[result[result.size() - 1]]就是要遍历的目的地集合</span><br>        <span class="hljs-keyword">if</span> (target.second &gt; <span class="hljs-number">0</span> ) &#123; <span class="hljs-comment">// 该路线还有余票</span><br>            result.<span class="hljs-built_in">push_back</span>(target.first);<span class="hljs-comment">//回溯模板，看不懂只能去复习了</span><br>            target.second--;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(ticketNum, result)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            result.<span class="hljs-built_in">pop_back</span>();<br>            target.second++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        targets.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//细节clear，防止内存里有脏东西</span><br>        vector&lt;string&gt; result;<span class="hljs-comment">//没开成员变量，提高速度，见 全排列的疑惑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;string&gt;&amp; vec : tickets) &#123;<span class="hljs-comment">//vec就是每张票了，俩元素，起点[0]跟终点[1]</span><br>            targets[vec[<span class="hljs-number">0</span>]][vec[<span class="hljs-number">1</span>]]++; <span class="hljs-comment">// 这里就提前给每个目的地集合按字典序排好序了，之后从头遍历就行</span><br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>); <span class="hljs-comment">// 手动加入起始机场</span><br>        <span class="hljs-built_in">backtracking</span>(tickets.<span class="hljs-built_in">size</span>(), result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="n皇后">51. N皇后</h1><p><strong>题目：</strong></p><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code>个皇后放置在 <code>n×n</code>的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong>的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code>分别代表了皇后和空位。</p><p>提示：</p><p><code>1 &lt;= n &lt;= 9</code></p><p><strong>思路：</strong></p><p>按图的深度优先搜索回溯查找所有放置可能，结束条件就是放到了最后一行仍然合法，放一个就在当前基础上往下搜索，写好判断合法函数，注意有两条斜线，经典问题所以不太难，披着hard的中等题吧。</p><h2 id="代码-4">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<span class="hljs-comment">//存放所有解</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, vector&lt;string&gt; &amp;board)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(row == n) &#123;<span class="hljs-comment">//最后一行放下去了，来到了界外</span><br>            ans.<span class="hljs-built_in">push_back</span>(board);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isVaild</span>(n, row, i, board)) <span class="hljs-keyword">continue</span>;<br>            board[row][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            <span class="hljs-built_in">backtrack</span>(n, row + <span class="hljs-number">1</span>, board);<br>            board[row][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">//尝试下一个放置位</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isVaild</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, vector&lt;string&gt; &amp;board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r &lt; n;r++) &#123;<span class="hljs-comment">//检测[row, col]有无同列Queen</span><br>            <span class="hljs-keyword">if</span>(board[r][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> r = row, c = col;<br>        <span class="hljs-keyword">while</span>(r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//检测左上斜线有无Queen</span><br>            <span class="hljs-keyword">if</span>(board[r--][c--] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        r = row, c = col;<br>        <span class="hljs-keyword">while</span>(r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; n) &#123;<span class="hljs-comment">//检测右上斜线有无Queen</span><br>            <span class="hljs-keyword">if</span>(board[r--][c++] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">board</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        <span class="hljs-built_in">backtrack</span>(n, <span class="hljs-number">0</span>, board);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="解数独">37. 解数独</h1><p><strong>题目：</strong></p><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 遵循如下规则：</p><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3宫内只能出现一次。（请参考示例图）</li></ul><p>数独部分空格内已填入了数字，空白格用 '.' 表示。</p><p>示例一：</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/202011171912586.png"alt="示例一" /><figcaption aria-hidden="true">示例一</figcaption></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],<br><br>[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],<br><br>[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br><br>输出：[[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>],<br><br>[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>],<br><br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>],<br><br>[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],<br><br>[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],<br><br>[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],<br><br>[<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>],<br><br>[<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],<br><br>[<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br><br>解释：输入的数独如上图所示，唯一有效的解决方案如下所示：<br><br>![answer](https://code-thinking<span class="hljs-number">-1253855093.</span>file.myqcloud.com/pics/<span class="hljs-number">20201117191340669.</span>png)<br><br>图源：[代码随想录](https://programmercarl.com/<span class="hljs-number">0037.</span><span class="hljs-comment">%E8%A7%A3%E6%95%B0%E7%8B%AC.html#%E6%80%9D%E8%B7%AF)</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><div class="note note-light">            <p>没写出来，想着用n皇后的思路一个一个回溯暴力填的，结果一堆bug😭</p><p>记录一下错误思路：在回溯函数里我传入了上一个被填位置的row和col，想着每次向下递归就能知道上次在哪里，结果会出现：一行填到最后一个没法填了，退回去清空倒数第二格后再跳过把最后一格填了，留着空格子不管直接下一行……</p><p>问题出在返回false的时机上，其实到没法填的时候就已经可以返回false了，然后会到上一格接着试下一个数字。</p>          </div><p>这道题回溯没有单独设置终止条件，如果有传参的话也许可以加一条到了8行9列就返回，不过也可以不加，循环跑完自然就会结束。</p><h2 id="代码-5">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//先行再列，逐个试错</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r &lt; <span class="hljs-number">9</span>;r++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">9</span>;i++) &#123;<span class="hljs-comment">//先填满row行</span><br>                <span class="hljs-keyword">if</span>(board[r][i] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">9</span>;j++) &#123;<span class="hljs-comment">//为(r, i)尝试所有可能数字</span><br>                    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isValid</span>(board, r, i, j)) <span class="hljs-keyword">continue</span>;<br>                    board[r][i] = <span class="hljs-string">&#x27;0&#x27;</span> + j;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtrack</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    board[r][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//没得填了，返回false</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp; board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;c &lt; <span class="hljs-number">9</span>;c++) <span class="hljs-keyword">if</span>(board[row][c] == <span class="hljs-string">&#x27;0&#x27;</span> + num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r &lt; <span class="hljs-number">9</span>;r++) <span class="hljs-keyword">if</span>(board[r][col] == <span class="hljs-string">&#x27;0&#x27;</span> + num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = row / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;r &lt; (row / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)*<span class="hljs-number">3</span>;r++) &#123;<span class="hljs-comment">//宫格</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c = col / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;c &lt; (col / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)*<span class="hljs-number">3</span>;c++) &#123;<br>                <span class="hljs-keyword">if</span>(board[r][c] == <span class="hljs-string">&#x27;0&#x27;</span> + num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">backtrack</span>(board);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day27</title>
    <link href="/2024/06/18/leetcode-day27/"/>
    <url>/2024/06/18/leetcode-day27/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/restore-ip-addresses/description/">93.复原IP地址</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/subsets/description/">78.子集</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集Ⅱ</a><span class="label label-warning">medium</span></li></ul><h1 id="复原ip地址">93. 复原IP地址</h1><p><strong>题目：</strong></p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255之间组成，且不能含有前导 0），整数之间用 '.' 分隔。</p><p>例如："0.1.2.201" 和 "192.168.1.1" 是 <strong>有效</strong> IP地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是<strong>无效</strong> IP 地址。 给定一个只包含数字的字符串 s，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP地址</strong>，这些地址可以通过在 s 中插入 '.' 来形成。你<strong>不能</strong> 重新排序或删除 s 中的任何数字。你可以按<strong>任何</strong> 顺序返回答案。</p><p><strong>思路：</strong></p><p>回溯做了几天，对于简单的解空间树怎么分支比较熟悉了，这题就先按长度从1到3分割，然后下传起点，如果第四段仍然合法，则找到一个答案，不断递归回溯寻找所有答案即可。</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933.png"alt="解空间树.图源：代码随想录" /><figcaption aria-hidden="true">解空间树.图源：<ahref="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E6%80%9D%E8%B7%AF">代码随想录</a></figcaption></figure><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    string temp;<br>    <span class="hljs-type">int</span> seg = <span class="hljs-number">4</span>;<span class="hljs-comment">//剩余段数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(seg &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(seg == <span class="hljs-number">0</span> &amp;&amp; begin &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() - i &gt; seg * <span class="hljs-number">3</span> &amp;&amp; i - begin &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//后续太多，直接剪枝\提前判断位数剪枝</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, begin, i)) &#123;<br>                <span class="hljs-keyword">if</span>(begin &gt; <span class="hljs-number">0</span>) temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                temp += <span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + begin, s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>                seg--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">backtrack</span>(s, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span>(!temp.<span class="hljs-built_in">empty</span>() &amp;&amp; temp.<span class="hljs-built_in">back</span>() != <span class="hljs-string">&#x27;.&#x27;</span>) temp.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">if</span>(!temp.<span class="hljs-built_in">empty</span>()) temp.<span class="hljs-built_in">pop_back</span>();<br>            seg++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &lt; end &amp;&amp; s[begin] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(begin &lt;= end) &#123;<br>            num *= <span class="hljs-number">10</span>;<br>            num += s[begin++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= num &amp;&amp; num &lt;= <span class="hljs-number">255</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">backtrack</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="子集">78. 子集</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> ，数组中的元素<strong>互不相同</strong>。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 <strong>任意顺序</strong>返回解集。</p><p><strong>思路：</strong></p><p>也是很容易套上模板的回溯，不过<strong>不能不求甚解依赖模板</strong>，还是要想清楚代码逻辑。这题是求子集，高中就学过n个元素的集合有2^n个子集，虽然跟这没啥关系，不过可以认识到求子集就是求元素个数从0~n的关于全集nums的组合，所以可以分别求长度为i，i从0到n，的组合，那就是从nums里抓i个的组合，就变成了该题的上一题：<ahref="https://leetcode.cn/problems/combinations/">77. 组合</a>了。</p><div class="note note-light">            <p>对于错误思路的反思：</p><p>注意到该题的tag里有<strong>位运算</strong>字样，昨天做错的题目里我也尝试使用位运算模拟<code>bool used[]</code>来记录哪些数字已经被使用过，但实际上是多余的。今天又看见位运算，由于其出现在tag里，所以深信不疑，再次尝试，WA，去掉后，AC。下面逐条分析错误核心，搞清楚什么时候用used记录用过，什么时候不用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<span class="hljs-comment">//此处i从begin开始，已经与之前的结果隔开</span><br>    <span class="hljs-keyword">if</span>(used &gt;&gt; nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//这句等同于：如果nums[i]在之前用过就跳过，但此题nums中无重复元素，所以之前出现的元素之后肯定没出现过，多余</span><br>    used |= <span class="hljs-number">1</span> &lt;&lt; nums[i];<span class="hljs-comment">//在used的第nums[i]位置一</span><br>    temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>, len);<br>    temp.<span class="hljs-built_in">pop_back</span>();<br>    used &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; nums[i]);<span class="hljs-comment">//第nums[i]位复位</span><br>&#125;<br></code></pre></td></tr></table></figure><p>看完发现，used的确多余，但好像没有影响啊，其实WA原因在于<code>used &gt;&gt; nums[i] % 2</code>，%运算符优先级高于&gt;&gt;，所以错了。</p><p>当然，改了还是会错，nums里有负数，这样就越来越复杂了。</p>          </div><h2 id="代码-1">代码</h2><p><strong>第一版</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == len) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>, len);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= nums.<span class="hljs-built_in">size</span>();i++) &#123;<br><br>            <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>, i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p><strong>carl的解</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(temp);<span class="hljs-comment">//提前</span><br>        <span class="hljs-keyword">if</span>(begin &gt;= nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="子集ⅱ">90. 子集Ⅱ</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums，其中可能包含<strong>重复元素</strong>，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按<strong>任意顺序</strong> 排列。</p><p><strong>思路：</strong></p><p>与上一题相比多了重复元素，相当于[1,2,2]的子集注意别回溯出两个[1,2]，可以采用昨天<ahref="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">40.组合总和</a>的相同去重思路。在昨天的blog中已经提到不能简单用used来尝试去重。所以还是乖乖用carl的写法，附图carl的解空间树：</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000918.png"alt="子集Ⅱ解空间树,图源：代码随想录 | 子集Ⅱ" /><figcaption aria-hidden="true">子集Ⅱ解空间树,图源：<ahref="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF">代码随想录| 子集Ⅱ</a></figcaption></figure><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(temp);<br>        <span class="hljs-keyword">if</span>(begin &gt;= nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-comment">//使用这条的前提是要排序哦，不然相同的不挨在一起就麻烦了</span><br>            <span class="hljs-keyword">if</span>(i &gt; begin &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day26</title>
    <link href="/2024/06/17/leetcode-day26/"/>
    <url>/2024/06/17/leetcode-day26/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/combination-sum/description/">39.组合总和</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/combination-sum-ii/description/">40.组合总和Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/palindrome-partitioning/description/">131.分割回文串</a> <span class="label label-warning">medium</span></li></ul><h1 id="组合总和">39. 组合总和</h1><p><strong>题目：</strong></p><p>给你一个<strong>无重复元素</strong>的整数数组 <code>candidates</code>和一个目标整数 <code>target</code> ，找出 <code>candidates</code>中可以使数字和为目标数 <code>target</code> 的 所有<strong>不同组合</strong> ，并以列表形式返回。你可以按<strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以<strong>无限制重复被选取</strong>。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于<code>150</code> 个。</p><p><strong>思路：</strong></p><p>递归挨个选取就行，选了一个之后递归下一个，起点不变，如果和到了target就加入答案，可以在下一步递归前判断当前值是否已经过大了，过大则跳过实现剪枝。比较简单</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidate, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; candidate.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(candidate[i] &gt; target) <span class="hljs-keyword">continue</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(candidate[i]);<br>            <span class="hljs-built_in">backtrack</span>(candidate, target - candidate[i], i);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-keyword">if</span>(candidates.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">backtrack</span>(candidates, target, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="组合总和ⅱ">40. 组合总和Ⅱ</h1><p><strong>题目：</strong></p><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数<code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为<code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用<strong>一次</strong> 。</p><p><strong>注意</strong>：解集不能包含重复的组合。</p><p><strong>提示:</strong></p><p><code>1 &lt;= candidates.length &lt;= 100</code></p><p><code>1 &lt;= candidates[i] &lt;= 50</code></p><p><code>1 &lt;= target &lt;= 30</code></p><p><strong>思路：</strong></p><p>难点主要在于去重，下面举个例子来快速直观体会这道题要去什么重</p><p>对于示例：<code>[10,1,1,7,6,1,5]</code>、<code>target = 8</code>，正确结果应该是<code>[[1,1,1,5],[1,1,6],[1,7]]</code>。题目中<strong>candidate中的每个数字只能用一次</strong>是关键，勿错误理解为每种数字只能用一次，示例<code>[10,1,1,7,6,1,5]</code>中有3个<code>1</code>，当<strong>选中第一个<code>1</code>作为解成员之一</strong>递归下去的时候，由于之前无1，所以已有的解中肯定无1，后面的两个<code>1</code>仍然可用，由答案可见，选中第一个<code>1</code>递归下去已经可以得到全部解了。</p><p>那么<strong>选中第二个<code>1</code>作为解成员之一</strong>递归下去后，后面还有一个<code>1</code>，此时<strong>含有两个<code>1</code>的解</strong>已经出现过了，此时需要去重。</p><p>由上可看出不能简单使用used来阻止使用使用过的下标，因为第一个1把所有解得到后，回溯取消操作会开放used，后面的1又会变得可用，去重失败</p><p>carl哥的代码思路按我理解可以叙述为：<span class="label label-danger">重复元素只能由排前面的重复元素使用</span>，对于上面的示例，就是含有多个1的解只能由第一个1的递归分支得到，后面的如果还是1就不能在解里出现1。</p><p><strong>排前面的重复</strong>即对应carl哥说法的<strong>前一个树枝</strong>，即前一个重复元素的解空间树分支。</p><div class="note note-light">            <p>又瞟了题解才做出来，WA了4发😭😭😭</p><p>脑子抽了没看见<code>1 &lt;= candidates.length &lt;= 100</code>，还乐呵呵地用位运算当used[]用来记录哪些下标被用了，左移右移老半天跟二傻子似的，结果不仅位运算爆longlong，而且用used记录本身就是脱裤子放屁，因为我回溯传了起点begin……</p>          </div><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidate, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; candidate.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(candidate[i] &gt; target) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(i &gt; begin &amp;&amp; candidate[i] == candidate[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//去重关键</span><br>            temp.<span class="hljs-built_in">push_back</span>(candidate[i]);<br>            <span class="hljs-built_in">backtrack</span>(candidate, target - candidate[i], i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-keyword">if</span>(candidates.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtrack</span>(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="分割回文串">131. 分割回文串</h1><p><strong>题目：</strong></p><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回s 所有可能的分割方案。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>没做出来，贴出失败思路：</p><p>分割子串，想到之前做的有关题目了，至少分割操作还是比较熟悉，用迭代器构造新串就好，从首开始分割，分割长度逐渐递增，也就是回溯中的那个for循环，每个分割长度在分割前判断是否是回文串，如果是回文串就分割，不是就接着增大分割长度。</p><p>然后就卡了……没记住或者说想另辟蹊径结果弄巧成拙，没有像模板那样接着回溯下一种可能并取消当前轮次操作继续for循环。</p>          </div><p>接下来是正确思路：</p><p>仍然按照回溯模板，理清递归思路： 1. 递归参数与返回值： 返回值void，参数应该是分割起点，确保能够递归下去接着分割之后的子串 2.递归终止条件，如果真的分割到结尾，那么该条递归调用路线就是正确的，此时temp中即为一个答案，标准就是起点超过了终点，begin大于了string的长度3. 递归操作：逐个尝试分割长度，合法就接着分割，不合法就跳过</p><p>carl哥这次画的解空间树很形象，如下图，失败思路想到了怎么分支，但是没想到怎么判断叶节点，具体的代码写法也写昏了头</p><figure><img src="https://s3.bmp.ovh/imgs/2024/06/17/788a44e4b04795dd.png"alt="解空间树" /><figcaption aria-hidden="true">解空间树</figcaption></figure><h2 id="代码-2">代码</h2><h3 id="一般代码">一般代码</h3><p>之所以叫一般，是因为判断回文串的函数<code>isValid</code>每次调用都要俩指针相向而行，有很多重复操作，提高了时间复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;string&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = begin, right = end;<br>        <span class="hljs-keyword">if</span>(right &gt; s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span>(s[left++] != s[right--]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, begin, i)) &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + begin, s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>));<br>                <span class="hljs-built_in">backtrack</span>(s, i + <span class="hljs-number">1</span>);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-built_in">backtrack</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="动态规划代码">动态规划代码</h3><p>使用动态规划（dynamic programming，DP）直接把所有子串是否是回文串都提前算好，这样后续判断时就只需要O(1)复杂度就可以了</p><p>动态规划状态转移方程为： <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">           ⌜<span class="hljs-number">1</span>, <span class="hljs-selector-tag">i</span> = j <br><br>dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> = +s<span class="hljs-selector-attr">[i]</span>==s<span class="hljs-selector-attr">[j]</span>, <span class="hljs-selector-tag">i</span> = j - <span class="hljs-number">1</span><br><br>           ㇗s<span class="hljs-selector-attr">[i]</span>==s<span class="hljs-selector-attr">[j]</span>ANDdp<span class="hljs-selector-attr">[i+1]</span><span class="hljs-selector-attr">[j-1]</span>,<span class="hljs-keyword">else</span><br></code></pre></td></tr></table></figure><del>不会打latex，好拉的公式，快去配置渲染器！！</del> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;string&gt; temp;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; dp;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(dp[begin][i]) &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + begin, s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>));<br>                <span class="hljs-built_in">backtrack</span>(s, i + <span class="hljs-number">1</span>);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string &amp;s)</span> </span>&#123;<br>        dp.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<span class="hljs-comment">//vector还得resize了才能用</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; s.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> == j) dp[i][j] = s[i] == s[j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == j) dp[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-built_in">isValid</span>(s);<br>        <span class="hljs-built_in">backtrack</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day24</title>
    <link href="/2024/06/15/leetcode-day24/"/>
    <url>/2024/06/15/leetcode-day24/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><a href="https://leetcode.cn/problems/combinations/">77.组合</a></li><li><ahref="https://leetcode.cn/problems/combination-sum-iii/description/">216.组合总和Ⅲ</a></li><li><ahref="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/">17.电话号码的字母组合</a></li></ul><h1 id="前言">前言</h1><p>进入回溯算法篇章，对递归掌握仍然不熟练，尤其是回溯算法，在左的课上写全排列等题目简直惨不忍睹，趁此机会，再次尝试学会回溯算法，每题务必隔天复习重写熟悉</p><p>卡哥的题解也要仔细看，综合多篇题解学习。</p><blockquote><p><strong>文章讲解：</strong>https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html<strong>视频讲解：</strong> https://www.bilibili.com/video/BV1cy4y167mM<strong>代码随想录：</strong>https://programmercarl.com/</p></blockquote><h1 id="组合">77. 组合</h1><p><strong>题目：</strong></p><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>思路：</strong></p><p>多重for循环就行，但是由于层数不定，所以不能直接for，需要靠递归来实现任意层数循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;    <span class="hljs-comment">//回溯模板1：总答案</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;           <span class="hljs-comment">//回溯模板2：单个答案暂存</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == k) &#123;  <span class="hljs-comment">//回溯模板3：递归结束条件：遍历到叶子节点</span><br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start;i &lt;= n - k + temp.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(i);  <span class="hljs-comment">//回溯模板4：选择当前，进入下一步</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-comment">//回溯模板5：取消之前操作，回溯</span><br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="组合总和ⅲ">216. 组合总和Ⅲ</h1><p><strong>题目：</strong></p><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em>。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>思路：</strong></p><p>和上一道题很像，卡哥选题还是很有深意的。熟悉模板写法，给出的代码没有剪枝，剪枝写法参见：</p><p><ahref="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">代码随想录| 组合总和iii</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == k) &#123;<br>            <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start;i &lt;= <span class="hljs-number">9</span>;i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(k, n - i, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">backtracking</span>(k, n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="电话号码的字母组合">17. 电话号码的字母组合</h1><p><strong>题目：</strong></p><p>给定一个仅包含数字 2-9的字符串，返回所有它能表示的字母组合。答案可以按<strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1不对应任何字母。</p><p><strong>思路：</strong></p><p>仍然是不定次数for循环，使用递归来解，同样，剪枝写法参见<ahref="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">代码随想录| 电话号码的字母组合</a></p><p>注意打表方式，值得学习，自己打表还用的unordered_map，结果打出来一堆bug，还是string数组聪明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    string temp;<br>    <span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = &#123;<br>    <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 0</span><br>    <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 1</span><br>    <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-comment">// 2</span><br>    <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-comment">// 3</span><br>    <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-comment">// 4</span><br>    <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-comment">// 5</span><br>    <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-comment">// 6</span><br>    <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-comment">// 7</span><br>    <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-comment">// 8</span><br>    <span class="hljs-string">&quot;wxyz&quot;</span>, <span class="hljs-comment">// 9</span><br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string digits, <span class="hljs-type">int</span> begin_for_string)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> digit = digits[begin_for_string] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        string letter = letterMap[digit];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; letter.<span class="hljs-built_in">size</span>();i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(letter[i]);<br>            <span class="hljs-built_in">backtracking</span>(digits, begin_for_string + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">backtracking</span>(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day23</title>
    <link href="/2024/06/14/leetcode-day23/"/>
    <url>/2024/06/14/leetcode-day23/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669.修剪二叉搜索树</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108.将有序数组转换为二叉搜索树</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">538.把二叉搜索树转换为累加树</a> <span class="label label-warning">medium</span></li></ul><h1 id="修剪二叉搜索树">669. 修剪二叉搜索树</h1><p><strong>题目：</strong></p><p>给你二叉搜索树的根节点 <code>root</code>，同时给定最小边界<code>low</code> 和最大边界<code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树<strong>不应该</strong> 改变保留在树中的元素的相对结构(即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在<strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>思路：</strong></p><p>根据day22的“删除二叉搜索树的节点”，这题就变成了：删除小于low的节点和大于high的节点，那么同样的做法，制定好分类讨论的规则，然后按规则遍历就好</p><h2 id="可以中序遍历吗">可以中序遍历吗？</h2><p>笔者第一版代码惨遭RE和WA，由于是区间，所以笔者“理所应当”地想要中序遍历先把小的全删了，然后再把大的全删了，看似没有问题，就像操作有序数组一样，但笔者实际写出的代码却是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root) &#123;<span class="hljs-comment">//不为空才操作</span><br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);    <span class="hljs-comment">//先左，中序嘛</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; low) &#123;                           <span class="hljs-comment">//然后中，处理当前节点</span><br>            TreeNode * temp = root;                     <span class="hljs-comment">//如果当前的小了</span><br>            root = root-&gt;right;                         <span class="hljs-comment">//让更大一点的右孩子来补位（雷点所在）</span><br>            <span class="hljs-keyword">delete</span> temp;                                <span class="hljs-comment">//删掉当前的</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; high) &#123;                     <span class="hljs-comment">//同理</span><br>            TreeNode * temp = root;<br>            root = root-&gt;left;                          <span class="hljs-comment">//大了就让更小一点的左孩子来补位</span><br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root) root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<span class="hljs-comment">//最后右</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>RE原因：</strong>这题力扣上似乎有点问题，对于<code>[1, null, 2]</code>这个用例，如果delete掉root，就会报错，但本地写好代码run出来是不会报错的，carl对此的解释是：</p><div class="note note-light">            <p>○ 代码加了内存释放，在运行时出错，<code>[1,null,2]</code>这个输入，本地调试时，没有出错。卡哥的代码没有处理内存问题，难道这题不用自己释放内存？把delete的逻辑移除后，就通过了。手动delete反而会出错</p><p>○解答：因为最终答案是删除了原本的根节点，然后返回节点2作为新的根节点也就是答案，为此做了两个实验：1.把right子树的指赋给原本的root，然后最终返回root，可以通过case；2.把root指向right，然后之前用个tmp指向原本root的内存再删除，这次会报错。而报错的原因是释放的内存再次被使用，所以我猜测是LeetCode的判题机在判题的时候应该再次使用了原本子树根节点的那块内存导致的错误，你可以只删除那个会释放根节点的delete语句，其他的释放语句不去掉，结果还是可以通过的，所以你本地输出答案没有错误那说明就是lc自己的问题了，不用太过于纠结。</p>          </div><p>忽略力扣本身原因，关注上述中序代码的逻辑错误，即</p><p><strong>WA原因：</strong></p><p>对于用例[4, 2, 5, null,3]，如下图所示，若范围为[4,5]，那么应该删除2、3，最后得到一棵4、5的链，但是依照上述代码，当递归到节点<code>2</code>时，会发生：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode * temp = root;           <span class="hljs-comment">//记录节点2</span><br>root = root-&gt;right;               <span class="hljs-comment">//将root-&gt;right赋值给root指针变量，意图让右孩子补位</span><br><span class="hljs-keyword">delete</span> temp;                      <span class="hljs-comment">//删掉节点2</span><br></code></pre></td></tr></table></figure><p>问题就出在第二条，原本计划让right来补位，但是实际操作却仅仅是给一个函数里的形式参数赋了值，相当于<strong>用形参root保留了当前的右儿子</strong>，之后递归处理右儿子right实际却处理了右<strong>孙子</strong>，可能会返回右孙子本身或者null，但是最后却返回了右儿子right，相当于跳过了<code>if(root) root-&gt;right = trimBST(root-&gt;right, low, high);</code>语句，会导致修剪不到位，对于上述用例，就会返回[3,4,5]，本应被删除的节点3被保留了。</p><p>看起来被否定的只是代码编写，而中序遍历这个思路似乎仍具有可行性，实际上，硬要保持左中右的教条中序遍历，也是可以的。</p><p>需要改的地方就是：如果根节点被删除，那么就应该返回 <strong>儿子节点的处理结果</strong>，而不仅仅是儿子节点，修改后的中序遍历如下，由于力扣本身原因，省去delete操作避免RE：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-comment">//规则：</span><br>        <span class="hljs-comment">//1. 当前小，删了让右孩子补位</span><br>        <span class="hljs-comment">//2. 当前大，删了让左孩子补位</span><br>        <span class="hljs-comment">//3. 当前合法，处理左右孩子后返回</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//左</span><br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        <span class="hljs-comment">//中</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; low) <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; high) <br>            <span class="hljs-keyword">return</span> root-&gt;left;<br>        <span class="hljs-keyword">else</span><br>            root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>按照官解做完再看这段修改后的“中序”，其实会发现对比下来就是把<code>root-&gt;left = trimBST(root-&gt;left, low, high);</code>这句给摘出来提前了。</p><p><strong>综上</strong></p><p>对于“可以中序吗？”的问题，我的回答是可以，事实上这道题并不需要关注前中后序怎么遍历，这也引出了笔者的一个思维定势：<strong>二叉树的递归都基于前中后序遍历，迭代都基于层序遍历</strong>。不要局限于前中后序遍历，这只是参考，实际就按递归三部曲来就行</p><p><del>这也许是一直看卡哥的代码却没有仔细思考，光看了个大概长相的缘故。😣</del></p><h2 id="正经解答">正经解答</h2><p>对一个小问题想多了，下面给出优雅的正确答案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>            root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="将有序数组转化为二叉搜索树">108. 将有序数组转化为二叉搜索树</h1><blockquote><p>乍一看，想要走捷径，直接拉个有序链表不也是二叉搜索树？</p></blockquote><blockquote><p>实际上题目要求平衡。。切</p></blockquote><p><strong>题目：</strong></p><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵平衡 二叉搜索树。</p><p><strong>思路：</strong></p><p>由于要平衡，所以对半分就行，这样深度差就得到控制，不会退化成链，有点像快排？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>官解整花活，划线方式给整了三种，实际就是一种方法</p>          </div><h1 id="把二叉搜索树转换为累加树">538. 把二叉搜索树转换为累加树</h1><p><strong>题目：</strong></p><p>给出二叉 <strong>搜索</strong>树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater SumTree），使每个节点 <code>node</code> 的新值等于原树中大于或等于<code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>思路：</strong></p><p>把累加树定义看懂就成，就是把一个节点右边的值（比它大的）全加起来变成这个节点的新值。那不就是从右至左累加么，一个右中左顺序遍历，开个int记录前一个节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        root-&gt;right = <span class="hljs-built_in">convertBST</span>(root-&gt;right);<br>        root-&gt;val += pre;<br>        pre = root-&gt;val;<br>        root-&gt;left = <span class="hljs-built_in">convertBST</span>(root-&gt;left);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><del>少有的直接秒杀还和标准答案一模一样，嘿嘿嘿😆</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day22</title>
    <link href="/2024/06/13/leetcode-day22/"/>
    <url>/2024/06/13/leetcode-day22/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">235.二叉搜索树的最近公共祖先</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701.二叉搜索树的插入操作</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450.删除二叉搜索树中的节点</a><span class="label label-warning">medium</span></li></ul><h1 id="二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先</h1><p>与day21的第三题相比，这题多了二叉搜索树这一条件，变得更简单</p><p><strong>题目：</strong></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>思路</strong></p><p>主体思路就是<strong>当root的值在p和q之间时，root就是最近公共祖先了</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == p || root == q || !root) <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//沿用236题的返回条件</span><br>        <span class="hljs-keyword">if</span>(p-&gt;val &gt; q-&gt;val) &#123;<span class="hljs-comment">//先设定p &lt; q</span><br>            TreeNode * temp = p;<br>            p = q;<br>            q = temp;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//如果root在之间，返回</span><br>        <span class="hljs-keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<span class="hljs-comment">//不然就在左子树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<span class="hljs-comment">//不然就在右子树</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树的插入操作">701. 二叉搜索树的插入操作</h1><p><strong>题目：</strong></p><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。你可以返回 任意有效的结果 。</p><p><strong>思路</strong></p><p>不要拘泥于AVL的标准，这只是普通的二叉搜索树，哪怕退化成链都没关系，所以<strong>直接在最底部插入就行</strong></p><p>然后问题转化为:<strong>在二叉搜索树BST中查找val</strong>。当然肯定找不到，但最后会在某个叶子节点处下行碰到null，那么只需要判断走没走到叶子，以及val该插在叶子的左边还是右边</p><p><del>别想着在中途插入了，本菜比卡了一个小时没写出来，看评论区全是“伪装成medium的easy”😭</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) &#123;<br>            TreeNode * node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除二叉搜索树中的节点">450. 删除二叉搜索树中的节点</h1><p><strong>题目：</strong></p><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ul><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ul><p><strong>思路：</strong></p><p>依然别想着AVL的左右旋什么的，别自己给自己上难度，简单暴力地分类讨论就行：</p><ol type="1"><li>没找到<code>val</code>(<code>root</code>是空的)，返回<code>nullptr</code></li><li>要删的是个叶子，直接删了返回<code>nullptr</code></li><li>要删的节点只有一个孩子，删完孩子上来补位，返回这个独生子</li><li>要删的节点有两个孩子，把左子树接到右子树最左边的节点下面当左孩子（这样可以最简单地使树依然合法）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        <span class="hljs-keyword">if</span>(root-&gt;val == key) &#123;<br>            <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>                TreeNode * temp = root-&gt;left;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right &amp;&amp; !root-&gt;left) &#123;<br>                TreeNode * temp = root-&gt;right;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                TreeNode * keeper = root-&gt;right;<br>                <span class="hljs-keyword">while</span>(keeper-&gt;left != <span class="hljs-literal">nullptr</span>) keeper = keeper-&gt;left;<br>                keeper-&gt;left = root-&gt;left;<br>                TreeNode * temp = root-&gt;right;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day21</title>
    <link href="/2024/06/13/leetcode-day21/"/>
    <url>/2024/06/13/leetcode-day21/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530.二叉搜索树的最小绝对差</a><span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/">501.二叉搜索树中的众数</a><span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236.二叉搜索树的最近公共祖先</a><span class="label label-warning">medium</span></li></ul><h1 id="二叉搜索树的最小绝对差">530. 二叉搜索树的最小绝对差</h1><p><strong>题目：</strong>（仅题干，示例请移步力扣）</p><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回<code>树中任意两不同节点值之间的最小差值</code> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>思路：</strong></p><p>由于是二叉搜索树，时刻牢记<span class="label label-info">中序遍历二叉搜索树相当于遍历有序数组</span>，所以大思路就是中序遍历树，并维护一个最小绝对差</p><p>中序遍历这里采用递归法，递归途中需要记录上一个节点的值以求出两数之差</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> &amp;ans, <span class="hljs-type">int</span> &amp; pre)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root) &#123;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;left, ans, pre);<br>            <span class="hljs-keyword">if</span>(pre == <span class="hljs-number">-1</span>) pre = root-&gt;val;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans = <span class="hljs-built_in">min</span>(ans, root-&gt;val - pre);<br>                pre = root-&gt;val;<br>            &#125;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;right, ans, pre);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = INT_MAX, pre = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">traversal</span>(root, ans, pre);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树中的众数">501. 二叉搜索树中的众数</h1><p><strong>题目：</strong></p><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code>，找出并返回 BST 中的所有<code>众数</code>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <code>小于等于</code> 当前节点的值</li><li>结点右子树中所含节点的值 <code>大于等于</code> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p><strong>思路：</strong></p><p>大思路仍然依靠<span class="label label-info">中序遍历二叉搜索树相当于遍历有序数组</span>，问题转换为求出一个有序数组中的众数，那么在遍历时记录每个数的频率，维护一个最大频率</p><p>若该数最后的频率小于最大频率，则不做操作；等于最大频率，则加入答案中；大于最大频率，则更新最大频率，清空当前答案，并将当前数加入答案</p><p>依然是递归中序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-comment">//答案answer</span><br>    <span class="hljs-type">int</span> max_freq = <span class="hljs-number">0</span>;<span class="hljs-comment">//最大频率</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> &amp;cur, <span class="hljs-type">int</span> &amp;freq)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, cur, freq);<span class="hljs-comment">//中序左</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val == cur) &#123;<span class="hljs-comment">//当前数cur还未遍历完，继续加频率freq</span><br>            freq++;<br>            <span class="hljs-keyword">if</span>(max_freq == freq) &#123;<span class="hljs-comment">//如果已经赶上最大频率，加入答案</span><br>                ans.<span class="hljs-built_in">push_back</span>(cur);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(max_freq &lt; freq) &#123;<span class="hljs-comment">//如果已经超过，更新max，清空答案，重新加入cur作为答案</span><br>                max_freq = freq;<br>                ans.<span class="hljs-built_in">clear</span>();<br>                ans.<span class="hljs-built_in">push_back</span>(cur);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cur = root-&gt;val;<span class="hljs-comment">//当前数cur遍历结束，将cur更新为新的数，频率重置</span><br>            freq = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, cur, freq);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cur = root-&gt;val, freq = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(root, cur, freq);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树的最近公共祖先">236. 二叉搜索树的最近公共祖先</h1><p><strong>题目：</strong></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>思路</strong></p><p>初次尝试越想越复杂，以失败告终，原因是单次递归逻辑和终止条件没想明白，</p><p>按照carl的递归三部曲：</p><ol type="1"><li>确定递归返回值和参数。这一步没问题，就按照力扣给的核心方法的定义就可以，返回公共祖先的指针，参数就是两个节点p、q和根节点</li><li>确定递归终止条件。第一个终止条件想到了：“root等于p或者q时，或者root为空”就返回root。之后就开始混乱了，尝试讨论p、q是root的孩子还是孙子还是更远的孩子，遂失败</li><li>确定单次递归逻辑。失败</li></ol><p>我没有分析出：当递归到<code>最近公共祖先的祖先</code>时，返回值也应该是<code>最近公共祖先</code>，也就是说<code>最近公共祖先</code>是会不断向上传递的，这样就就能保证<code>最近</code>而不会得到深度更浅的公共祖先。</p><p>对于<strong>遍历一条路</strong>还是<strong>遍历整棵树</strong>，carl老师的解释令我耳目一新：</p><div class="note note-light">            <p><strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）。</strong></p><p>搜索一条边的写法： <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">if</span> (递归函数(root-&gt;<span class="hljs-built_in">left</span>)) <span class="hljs-keyword">return</span> ;<br><span class="hljs-keyword">if</span> (递归函数(root-&gt;<span class="hljs-built_in">right</span>)) <span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></table></figure> 搜索整个树写法： <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">left</span> = 递归函数(root-&gt;<span class="hljs-built_in">left</span>);  // 左<br><span class="hljs-built_in">right</span> = 递归函数(root-&gt;<span class="hljs-built_in">right</span>); // 右<br><span class="hljs-built_in">left</span>与<span class="hljs-built_in">right</span>的逻辑处理;         // 中 <br></code></pre></td></tr></table></figure></p>          </div><p>由于返回值确定，所以递归时肯定会有东西接住返回值，又由于，递归的参数是root，返回值也是root，所以当递归root左右孩子时，返回值也应该是左右孩子，即必然会有</p><p><code>left = lowestCommonAncestor(root-&gt;left, p, q);</code></p><p>由于这道题不需要对树进行操作，只需要查找遍历，所以<code>left</code>并不是<code>root-&gt;left</code>，即不需要更新。根据carl的区分，我们可以根据这条语句推断我们之后应该进行left和right的逻辑处理，那么就可以合理推测应该判断left和right是否为空，因为如果没有找到必定返回空，而找到p、q才会返回p或者q，那么如果left和right都返回了，就遇到答案（root）了，向上不断返回即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == p || root == q || root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br><br>        TreeNode * left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode * right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> &amp;&amp; right != <span class="hljs-literal">nullptr</span>) <br>            <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><del>对于想了半小时还WA的我来说，这真是段优雅的代码</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day20</title>
    <link href="/2024/06/11/leetcode-day20/"/>
    <url>/2024/06/11/leetcode-day20/</url>
    
    <content type="html"><![CDATA[<p>今日内容</p><p><ahref="https://leetcode.cn/problems/maximum-binary-tree/description/">●654.最大二叉树</a> <ahref="https://leetcode.cn/problems/merge-two-binary-trees/description/">●617.合并二叉树</a> <ahref="https://leetcode.cn/problems/search-in-a-binary-search-tree/">●700.二叉搜索树中的搜索</a> <ahref="https://leetcode.cn/problems/validate-binary-search-tree/description/">●98.验证二叉搜索树</a></p><h1 id="最大二叉树">最大二叉树</h1><h2 id="一般写法">一般写法</h2><p>题目实际上已经给出了递归逻辑，翻译成代码即可</p><p>给定一个不重复的整数数组<code>nums</code>。<code>最大二叉树</code>可以用下面的算法从<code>nums</code>递归地构建:</p><ol type="1"><li>创建一个根节点，其值为<code>nums</code>中的最大值。</li><li>递归地在最大值<code>左边</code>的<code>子数组前缀上</code>构建左子树。</li><li>递归地在最大值<code>右边</code>的<code>子数组后缀上</code>构建右子树。</li></ol><p>返回<code>nums</code>构建的<code>最大二叉树</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) <br>            <span class="hljs-keyword">if</span>(nums[max] &lt; nums[i]) max = i;<br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[max]);<span class="hljs-comment">// 1创建一个根节点，其值为`nums`中的最大值。</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(nums.begin(), nums.begin() + max)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(nums.begin() + max + <span class="hljs-number">1</span>, nums.end())</span></span>;<br>        root-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(left);<span class="hljs-comment">// 2递归地在最大值`左边`的`子数组前缀上`构建左子树。</span><br>        root-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(right);<span class="hljs-comment">// 3递归地在最大值`右边`的`子数组后缀上`构建右子树。</span><br>        <span class="hljs-keyword">return</span> root;<span class="hljs-comment">// 返回最大二叉树</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="单调栈写法">单调栈写法</h2><p>笔者仅根据题目写出递归写法，未想到单调栈写法，此为<ahref="https://leetcode.cn/problems/maximum-binary-tree/solutions/1759348/zui-da-er-cha-shu-by-leetcode-solution-lbeo/">力扣官方题解</a>启发</p><figure><img src="https://s3.bmp.ovh/imgs/2024/06/11/b6ce26fcf0d47d93.png"alt="总体思想图示" /><figcaption aria-hidden="true">总体思想图示</figcaption></figure><div class="note note-light">            <p>因此，我们的任务变为：找出每一个元素左侧和右侧第一个比它大的元素所在的位置。这就是一个经典的单调栈问题了，可以参考<ahref="https://leetcode.cn/problems/next-greater-element-ii/description/">503.下一个更大元素II</a>。如果左侧的元素较小，那么该元素就是左侧元素的右子节点；如果右侧的元素较小，那么该元素就是右侧元素的左子节点。</p>          </div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;  <span class="hljs-comment">//单调栈</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(len, <span class="hljs-number">-1</span>)</span></span>;  <span class="hljs-comment">//每个节点左侧第一个更大的节点</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(len, <span class="hljs-number">-1</span>)</span></span>;  <span class="hljs-comment">//每个节点右侧第一个更大的节点</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">tree</span><span class="hljs-params">(len)</span></span>;  <span class="hljs-comment">//存储树节点</span><br>        <span class="hljs-comment">//使用单减栈 获取left和right  (题目限制元素是不同的)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            tree[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[i]); <span class="hljs-comment">//构造当前节点</span><br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[stk.<span class="hljs-built_in">top</span>()])&#123;  <span class="hljs-comment">//当前节点比栈中元素大 弹栈并给栈中的小元素赋right</span><br>                right[stk.<span class="hljs-built_in">top</span>()] = i;<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!stk.<span class="hljs-built_in">empty</span>())&#123;  <span class="hljs-comment">//当前节点的左侧更大节点就是单减栈的顶部元素</span><br>                left[i] = stk.<span class="hljs-built_in">top</span>();<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        TreeNode* root = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//将每个节点接到自己的父节点上以构造树形结构</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(left[i] == <span class="hljs-number">-1</span> &amp;&amp; right[i] == <span class="hljs-number">-1</span>)&#123;  <span class="hljs-comment">//当前节点为最大值，其为根</span><br>                root = tree[i];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left[i] == <span class="hljs-number">-1</span> || (right[i] != <span class="hljs-number">-1</span> &amp;&amp; nums[left[i]] &gt; nums[right[i]]))&#123; <br>                tree[right[i]]-&gt;left = tree[i];   <span class="hljs-comment">//左侧没有更大的节点或左侧更大值大于右侧更大值，说明当前节点是右侧更大值的左子树的根节点</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tree[left[i]]-&gt;right = tree[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>该代码中的注释来源于题解评论区<ahref="https://leetcode.cn/u/6ifted-ishi2aka1rd/"><span class="citation"data-cites="健">@健</span></a>，本菜比瞪眼看了十分钟没看懂，抄了，挖坑后面来看</p>          </div><h1 id="合并二叉树">合并二叉树</h1><p>简单递归即可</p><ol type="1"><li>确定返回值和参数：就按力扣给的核心函数递归就行，无需另写函数，返回值就是合并后的节点指针，参数就是要合并的两个节点</li><li>确定递归结束条件：如果一方为空则返回另一方，都不空则相加后返回和节点</li><li>确定递归中途操作：合并当前节点对应的左右孩子</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root1) <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span>(!root2) <span class="hljs-keyword">return</span> root1;<br>        root1-&gt;val += root2-&gt;val;<br>        root1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);<br>        root1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树中的搜索">二叉搜索树中的搜索</h1><p>过于简单，知道什么是二叉搜索树就能做，略</p><h1 id="验证二叉搜索树">验证二叉搜索树</h1><p>示例2就已经给出一个容易犯的陷阱：错误地以为只需要左右节点各比根节点小和大就可以了，实际上二叉搜索树需要整个左右子树都比根节点小和大，所以需要注意在想当然递归的时候不要只比较左右节点，还需注意更上层的节点。</p><p>由于是二叉搜索树，条件比较硬，所以可以充分利用二叉搜索树的特性————利用中序遍历获取序列，然后判断该序列是否单调递增就好，若不单调递增，证明不是二叉搜索树</p><p>二叉排序树左子树-根-右子树严格单调递增，标准地画出一棵二叉排序树，并从上到下作其投影可得到严格序列，该序列即是中序遍历序列，并且该序列单调递增</p><p>附图直观一览</p><figure><img src="https://s3.bmp.ovh/imgs/2024/06/11/8bf9279d365104cd.png"alt="二叉排序树的投影与中序遍历" /><figcaption aria-hidden="true">二叉排序树的投影与中序遍历</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; ans;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root) &#123;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; ans2 = ans;<br>        <span class="hljs-built_in">sort</span>(ans2.<span class="hljs-built_in">begin</span>(), ans2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; ans.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(ans[i] != ans2[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; ans2[i] &lt;= ans2[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day18</title>
    <link href="/2024/06/09/leetcode-day18/"/>
    <url>/2024/06/09/leetcode-day18/</url>
    
    <content type="html"><![CDATA[<p>今日内容</p><p>● <ahref="https://leetcode.cn/problems/find-bottom-left-tree-value/">513.找树左下角的值</a>● <a href="https://leetcode.cn/problems/path-sum/description/">112.路径总和</a> <ahref="https://leetcode.cn/problems/path-sum-ii/">113.路径总和ii</a> ● <ahref="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106.从中序与后序遍历序列构造二叉树</a><ahref="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105.从前序与中序遍历序列构造二叉树</a></p><h1 id="找树左下角的值">找树左下角的值</h1><h2 id="递归写法">递归写法</h2><p>递归代表深度优先搜索，所以对于这道题要求的bottom比较好把握，只要维护一个最深深度就行了，对于left，就要在递归逻辑上把握</p><ul><li>当遇到叶子节点，根据深度判断是否维护，注意一定是深度比当前大才维护，不能相等</li><li>当遇到分支节点，先走左再走右</li></ul><p>为什么先走左就能保证最底最左？</p><p>最底可以保证，最左就是第一个遇到，而维护时只维护更深的，就意味着当前答案就是当前深度中第一个遇到的、最左的节点，所以最左也可以保证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; ans = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">findBottomLeftValueHelp</span>(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans.first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findBottomLeftValueHelp</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            <span class="hljs-keyword">if</span>(depth &gt; ans.second) ans = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&#123;root-&gt;val, depth&#125;;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;left) <span class="hljs-built_in">findBottomLeftValueHelp</span>(root-&gt;left, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">findBottomLeftValueHelp</span>(root-&gt;right, depth + <span class="hljs-number">1</span>);<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代写法">迭代写法</h2><p>代表广度优先搜索，或者层序遍历，由于每层从左向右，所以left好把握，对于bottom就要多写点逻辑来把握</p><p>遍历每行时，若遇到叶子节点，则跳过对该层后面节点的判断，仅仅只入队后面节点的子节点，这样就保证了最左。如果队中还有元素，则说明还有更深，继续寻找，最后就会得到答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> ans = root-&gt;val;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>                TreeNode * cur = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                <span class="hljs-keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;<br>                    ans = cur-&gt;val;<br>                    <span class="hljs-keyword">while</span>(++i &lt; size) &#123;<br>                        cur = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                        <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="路径总和">路径总和</h1><p>这题太适合深度优先搜索了，一条路走到头才能判断，那就一条一条走，正符合dfs。</p><p>代码比较简单，注意参数怎么传的，传参步骤减去当前节点值，最后判断是否刚好相等。而非从0加到叶子再判断是否等于target，虽然空间复杂度没变，但是少一个变量更简洁一点</p><p>具体代码不贴，与下一题类似，可同理理解</p><h1 id="路径综合ii">路径综合II</h1><p>仍然是深度优先搜索，只是多了保存答案的步骤，也不难</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">path</span>(root, targetSum, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(), ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">path</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> targetSum, vector&lt;<span class="hljs-type">int</span>&gt; temp, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == targetSum) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        temp.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(root-&gt;left) <span class="hljs-built_in">path</span>(root-&gt;left, targetSum - root-&gt;val, temp, ans);<br>        <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">path</span>(root-&gt;right, targetSum - root-&gt;val, temp, ans);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="从中序和后序构造二叉树">从中序和后序构造二叉树</h1><h2 id="递归写法-1">递归写法</h2><p>经典考题，递归写法核心思想为分割序列为子树的中序和后序，不断分割直到只剩一个，即是叶子节点</p><p>根据后序可以直接确定当前树的根节点，然后在中序中定位左右子树的中序，最后将左右子树的中序和后需继续下传，返回当前根节点</p><p>分割序列采用vector的构造函数，使用迭代器分割</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> size = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> rootval = postorder[size - <span class="hljs-number">1</span>];<br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootval);<br>        <span class="hljs-type">int</span> split;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>            <span class="hljs-keyword">if</span>(inorder[i] == rootval) &#123;<br>                split = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; inleft = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(inorder.<span class="hljs-built_in">begin</span>(), inorder.<span class="hljs-built_in">begin</span>() + split);<br>        vector&lt;<span class="hljs-type">int</span>&gt; inright = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(inorder.<span class="hljs-built_in">begin</span>() + split + <span class="hljs-number">1</span>, inorder.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; postleft = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(postorder.<span class="hljs-built_in">begin</span>(), postorder.<span class="hljs-built_in">begin</span>() + split);<br>        vector&lt;<span class="hljs-type">int</span>&gt; postright = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(postorder.<span class="hljs-built_in">begin</span>() + split, postorder.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>);<br>        root-&gt;left = <span class="hljs-built_in">buildTree</span>(inleft, postleft);<br>        root-&gt;right = <span class="hljs-built_in">buildTree</span>(inright, postright);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="从前序和中序构造二叉树">从前序和中序构造二叉树</h1><h2 id="递归写法-2">递归写法</h2><p>与上一题同理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> rootval = preorder[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> split = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(split;split &lt; preorder.<span class="hljs-built_in">size</span>();split++) &#123;<br>            <span class="hljs-keyword">if</span>(inorder[split] == rootval) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootval);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftpre</span><span class="hljs-params">(preorder.begin() + <span class="hljs-number">1</span>, preorder.begin() + <span class="hljs-number">1</span> + split)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightpre</span><span class="hljs-params">(preorder.begin() + <span class="hljs-number">1</span> + split, preorder.end())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftin</span><span class="hljs-params">(inorder.begin(), inorder.begin() + split)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightin</span><span class="hljs-params">(inorder.begin() + split + <span class="hljs-number">1</span>, inorder.end())</span></span>;<br>        root-&gt;left = <span class="hljs-built_in">buildTree</span>(leftpre, leftin);<br>        root-&gt;right = <span class="hljs-built_in">buildTree</span>(rightpre, rightin);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代写法-1">迭代写法</h2><p>迭代写法思维很巧妙，官方题解写得很严谨，我直接摘抄并加入自己的注解 ：<span class="label label-success">注解格式</span></p><p>原文链接：https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/</p><p>对于前序遍历中的任意两个连续节点 <code>u</code> 和<code>v</code>，根据前序遍历的流程，我们可以知道 <code>u</code> 和<code>v</code> 只有两种可能的关系：</p><p><code>v</code> 是 <code>u</code> 的左儿子。这是因为在遍历到<code>u</code> 之后，下一个遍历的节点就是 <code>u</code> 的左儿子，即<code>v</code>；</p><p><code>u</code> 没有左儿子，并且 <code>v</code> 是 <code>u</code>的某个祖先节点（或者 <code>u</code> 本身）的右儿子。 <span class="label label-success">可以自己画几个树来验证</span> ​</p><p>举一个例子来说明第二种关系的正确性，并在例子中给出我们的迭代算法。</p><p>例子</p><p>我们以树 <figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">        3<br>       / \<br>     <span class="hljs-number"> 9 </span> 20<br>     /  /  \<br>   <span class="hljs-number"> 8 </span><span class="hljs-number"> 15 </span>  7<br>   / \<br> <span class="hljs-number"> 5 </span> 10<br> /<br>4<br></code></pre></td></tr></table></figure> 为例，它的前序遍历和中序遍历分别为</p><p>preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]</p><p>inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]</p><p>我们用一个栈 <code>stack</code>来维护「<strong>当前节点的所有还没有考虑过右儿子的祖先节点</strong>」<span class="label label-success">栈内的元素无论何时都是这一含义，视作未判断过是不是有右孩子的节点</span>，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针<code>index</code> 指向中序遍历的某个位置，初始值为<code>0</code>。<code>index</code>对应的节点是「<strong>当前节点不断往左走达到的最终节点</strong>」，这也是符合中序遍历的，它的作用在下面的过程中会有所体现。</p><p>首先我们将根节点 <code>3</code> 入栈，再初始化 <code>index</code>所指向的节点为<code>4</code>，随后对于前序遍历中的每个节点，我们依次判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p><p>我们遍历 <code>9</code>。<code>9</code> 一定是栈顶节点 <code>3</code>的左儿子。我们使用反证法，假设 <code>9</code> 是 <code>3</code>的右儿子，那么 <code>3</code> 没有左儿子，<code>index</code>应该恰好指向 <code>3</code>，但实际上为<code>4</code>，因此产生了矛盾。所以我们将 <code>9</code> 作为<code>3</code> 的左儿子，并将 <code>9</code> 入栈。</p><p><code>stack = [3, 9]</code></p><p><code>index -&gt; inorder[0] = 4</code></p><p>我们遍历 <code>8</code>，<code>5</code> 和<code>4</code>。同理可得它们都是上一个节点（栈顶节点）的左儿子，所以它们会依次入栈。</p><p><code>stack = [3, 9, 8, 5, 4]</code></p><p><code>index -&gt; inorder[0] = 4</code></p><p>我们遍历 <code>10</code>，这时情况就不一样了。我们发现<code>index</code> 恰好指向当前的栈顶节点 <code>4</code>，也就是说<code>4</code> 没有左儿子，那么 <code>10</code>必须为栈中某个节点的右儿子。那么如何找到这个节点呢？栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的。<span class="label label-success">z左中右与中左右，其中“中”和“左”是相反的</span></p><blockquote><p>这是因为栈中的任意两个相邻的节点，前者都是后者的某个祖先。并且我们知道，栈中的任意一个节点的右儿子还没有被遍历过，说明后者一定是前者左儿子的子树中的节点，那么后者就先于前者出现在中序遍历中。</p></blockquote><p>因此我们可以把 <code>index</code>不断向右移动，并与栈顶节点进行比较。如果 <code>index</code>对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了栈顶节点，所以将<code>index</code> 增加 <code>1</code> 并弹出栈顶节点，直到<code>index</code>对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后一个节点<code>x</code> 就是 <code>10</code> 的双亲节点，这是因为 <code>10</code>出现在了 <code>x</code> 与 <code>x</code>在栈中的下一个节点的中序遍历之间，因此 <code>10</code> 就是<code>x</code> 的右儿子。</p><p>回到我们的例子，我们会依次从栈顶弹出 <code>4</code>，<code>5</code>和 <code>8</code>，并且将 <code>index</code> 向右移动了三次。我们将<code>10</code> 作为最后弹出的节点 <code>8</code>的右儿子<span class="label label-success">栈中没有考虑右孩子</span>，并将 <code>10</code> 入栈。</p><p><code>stack = [3, 9, 10]</code></p><p><code>index -&gt; inorder[3] = 10</code></p><p>我们遍历 <code>20</code>。同理，<code>index</code>恰好指向当前栈顶节点 <code>10</code>，那么我们会依次从栈顶弹出<code>10</code>，<code>9</code> 和 <code>3</code>，并且将<code>index</code> 向右移动了三次。我们将 <code>20</code>作为最后弹出的节点 <code>3</code> 的右儿子，并将 <code>20</code>入栈。</p><p><code>stack = [20]</code></p><p><code>index -&gt; inorder[6] = 15</code></p><p>我们遍历 <code>15</code>，将 <code>15</code> 作为栈顶节点<code>20</code> 的左儿子，并将 <code>15</code> 入栈。</p><p><code>stack = [20, 15]</code></p><p><code>index -&gt; inorder[6] = 15</code></p><p>我们遍历 <code>7</code>。<code>index</code> 恰好指向当前栈顶节点<code>15</code>，那么我们会依次从栈顶弹出 <code>15</code> 和<code>20</code>，并且将 <code>index</code> 向右移动了两次。我们将<code>7</code> 作为最后弹出的节点 <code>20</code> 的右儿子，并将<code>7</code> 入栈。</p><p><code>stack = [7]</code></p><p><code>index -&gt; inorder[8] = 7</code></p><p>此时遍历结束，我们就构造出了正确的二叉树。</p><p><strong>算法</strong></p><p>我们归纳出上述例子中的算法流程：</p><ul><li><p>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p></li><li><p>我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果<code>index</code>恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动<code>index</code>，并将当前节点作为最后一个弹出的节点的右儿子；如果<code>index</code>和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</p></li></ul><p>无论是哪一种情况，我们最后都将当前的节点入栈。</p><p><strong>代码</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!preorder.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        stack&lt;TreeNode*&gt; stk;<br>        stk.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> inorderIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; preorder.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> preorderVal = preorder[i];<br>            TreeNode* node = stk.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;val != inorder[inorderIndex]) &#123;<br>                node-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorderVal);<br>                stk.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>()-&gt;val == inorder[inorderIndex]) &#123;<br>                    node = stk.<span class="hljs-built_in">top</span>();<br>                    stk.<span class="hljs-built_in">pop</span>();<br>                    ++inorderIndex;<br>                &#125;<br>                node-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorderVal);<br>                stk.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day17</title>
    <link href="/2024/06/07/leetcode-day17/"/>
    <url>/2024/06/07/leetcode-day17/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><p><ahref="https://leetcode.cn/problems/balanced-binary-tree/description/">●110.平衡二叉树</a> <ahref="https://leetcode.cn/problems/binary-tree-paths/">● 257.二叉树的所有路径</a> <ahref="https://leetcode.cn/problems/sum-of-left-leaves/description/">●404.左叶子之和</a></p><h1 id="平衡二叉树">平衡二叉树</h1><p>只是判断平衡二叉树，比较简单，按规范化思路来吧，避免一会有感觉秒了，一会没感觉卡了</p><p>递归结束条件：如果左子树不是平衡二叉树 或者 右子树不是平衡二叉树 或者左右子树深度差距大于1</p><p>递归操作：判断左子树是不是平衡二叉树，判断右子树是不是平衡二叉树，获取左右子树深度</p><p>参数及返回值：根节点 + 是否合法的bool值</p><p>原创AC代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//空视作平衡</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;right)) &#123;<span class="hljs-comment">//左右都是</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">getDepth</span>(root-&gt;left) - <span class="hljs-built_in">getDepth</span>(root-&gt;right)) &lt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//左右深度是否匹配</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//空树深度0</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getDepth</span>(root-&gt;left), <span class="hljs-built_in">getDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<span class="hljs-comment">//左右子树最大深度加自己</span><br>&#125;<br></code></pre></td></tr></table></figure>这个时间复杂度较大，O(n^2)，对每一个节点都要单独求深度然后判断，自顶向下</p><p>自底向上做法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getDepth</span>(root) != <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">getDepth</span>(root-&gt;left);<br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//只要一个子树不平衡，整个树就不平衡</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">getDepth</span>(root-&gt;right);<br>    <span class="hljs-keyword">if</span>(right == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(left - right) &lt;= <span class="hljs-number">1</span> ? <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="二叉树的所有路径">二叉树的所有路径</h1><p>递归三步：</p><ol type="1"><li>参数&amp;返回值</li></ol><p>无需返回值，参数有根节点和存路径和答案的数组</p><ol start="2" type="1"><li>递归终止条件</li></ol><p>遇到叶节点</p><ol start="3" type="1"><li>递归逻辑</li></ol><p>没遇到就接着往里插</p><p>比较简单，贴代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        string line;<br>        <span class="hljs-built_in">traversal</span>(root, line);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode * root, string s)</span> </span>&#123;<br>        s += <span class="hljs-built_in">to_string</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) ans.<span class="hljs-built_in">push_back</span>(s);<br>        <span class="hljs-keyword">else</span> &#123;<br>            s += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>            <span class="hljs-keyword">if</span>(root-&gt;left) <span class="hljs-built_in">traversal</span>(root-&gt;left, s);<br>            <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">traversal</span>(root-&gt;right, s);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h2 id="迭代写法">迭代写法</h2><p>用一个栈存节点，一个栈存目前已经走过的路径注意push根节点和其他节点的差异</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        stack&lt;string&gt; path;<br>        stack&lt;TreeNode *&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        path.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">to_string</span>(root-&gt;val));<span class="hljs-comment">//only value</span><br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode * cur = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>            string tem = path.<span class="hljs-built_in">top</span>(); path.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span>(cur-&gt;left) &#123;<br>                st.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                path.<span class="hljs-built_in">push</span>(tem + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">to_string</span>(cur-&gt;left-&gt;val));<span class="hljs-comment">//insert the next value</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur-&gt;right) &#123;<br>                st.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                path.<span class="hljs-built_in">push</span>(tem + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">to_string</span>(cur-&gt;right-&gt;val));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;<span class="hljs-comment">//no next value</span><br>                ans.<span class="hljs-built_in">push_back</span>(tem);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="左叶子之和">左叶子之和</h1><p>需要注意，单独一个根节点不能称作左叶子，只是叶子，但不左</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;<br>            ans = root-&gt;left-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个递归看得有点懵，后面再来仔细理解一下吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day16</title>
    <link href="/2024/06/06/leetcode-day16/"/>
    <url>/2024/06/06/leetcode-day16/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><p><ahref="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">-104.二叉树的最大深度</a> <ahref="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/">-559.n叉树的最大深度</a> <ahref="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">-111.二叉树的最小深度</a> <ahref="https://leetcode.cn/problems/count-complete-tree-nodes/description/">-222.完全二叉树的节点个数</a></p><h1 id="树的最大深度">树的最大深度</h1><p>最大深度指从根到所有节点的长度中最长的那一个，换言之就是要找离根最远的节点然后返回到它的长度。</p><p>用dfs和bfs都行，分别代表递归前后序遍历和层序遍历，对于n叉树而言，仅仅是多比较几次而已，改写难度不大</p><p>下附对于n叉树的bfs遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>    queue&lt;Node *&gt; q;<br>    <span class="hljs-keyword">if</span>(root) q.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>            Node * cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; cur-&gt;children.<span class="hljs-built_in">size</span>();j++) &#123;<br>                q.<span class="hljs-built_in">push</span>(cur-&gt;children[j]);<br>            &#125;<br>        &#125;<br>        ans++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的最小深度">二叉树的最小深度</h1><p>最小深度需要注意，是从根到最近的<strong>叶子节点</strong>的距离，<strong>叶子节点</strong>指没有左右孩子的节点</p><p>所以在遍历时需要注意结束条件，对于层序遍历则判断当前节点是否是叶子，如果是就维护最小深度</p><p>对于递归遍历则根据子节点个数来分类处理，如果左右双全或双无，则直接递归；如果只有一个，就单独递归</p><p>下附递归遍历代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">minDepth</span>(root-&gt;left);<br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">minDepth</span>(root-&gt;right);<br><br>    <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + right;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;right == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;left) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(left, right);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>留坑，lc的最快执行代码中在最后<code>return</code>前把<code>root</code>的左右都指<code>null</code>，意义不明，但是就是快，没想出来为什么</em></p><h1 id="完全二叉树的节点个数">完全二叉树的节点个数</h1><p>用普通二叉树的遍历当然能做，只是不太好，还是用好完全二叉树的特性：<strong>非底层全满，底层从左往右堆</strong></p><p>所以完全二叉树的左右子树深度肯定是一样的，如果不一样，那么再递归，直到递归到完全二叉树或者细粒度足够小时的空节点</p><p>代码贴的carl的，原文链接：<ahref="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录| 完全二叉树的节点个数</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    TreeNode* left = root-&gt;left;<br>    TreeNode* right = root-&gt;right;<br>    <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里初始为0是有目的的，为了下面求指数方便</span><br>    <span class="hljs-keyword">while</span> (left) &#123;  <span class="hljs-comment">// 求左子树深度</span><br>        left = left-&gt;left;<br>        leftDepth++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (right) &#123; <span class="hljs-comment">// 求右子树深度</span><br>        right = right-&gt;right;<br>        rightDepth++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (leftDepth == rightDepth) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day15</title>
    <link href="/2024/06/05/leetcode-day15/"/>
    <url>/2024/06/05/leetcode-day15/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><p><ahref="https://leetcode.cn/problems/binary-tree-level-order-traversal/">-102.层序遍历</a> <ahref="https://leetcode.cn/problems/invert-binary-tree/">-226.翻转二叉树</a> <ahref="https://leetcode.cn/problems/symmetric-tree/">-101.对称二叉树</a></p><h1 id="层序遍历">层序遍历</h1><p>思路就是用队列记录逐层，这样顺序不会变。进入一层时最好记录队列初长度，然后根据长度遍历该层，避免根据队列是否空而判断该层是否遍历结束，便于即时将子节点入队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    TreeNode * cur = root;<br>    queue&lt;TreeNode*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(cur);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            temp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span> (cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(temp);<br>        temp.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="翻转二叉树">翻转二叉树</h1><p>递归版比较简单，太过简单，所以skip</p><p>迭代版就看作在遍历，而且是前序遍历那种单循环，出栈后把左右节点交换，然后压栈左右节点继续就行，给出循环部分的核心代码<del>本来就是核心代码模式，又再核心……</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>    TreeNode* node = st.<span class="hljs-built_in">top</span>();              <span class="hljs-comment">// 中</span><br>    st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>    <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);   <span class="hljs-comment">// 右</span><br>    <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);     <span class="hljs-comment">// 左</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对称二叉树">对称二叉树</h1><p>递归版很简单，写一个辅助函数判断左右节点是不是相等，是树就接着递归，然后从根开始对每一个分支节点的左右孩子判断就行代码没写，偷了个懒😜</p><p>迭代版要难一点，仅限于手写层面，思路不难</p><p>迭代需要用队列或者栈等来存，但是不是按左右顺序挨个入队，而是左右<strong>对应交替</strong>入队，这样方便判断是否相等</p><p>下附carl的漂亮含注释代码，<ahref="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">carl原文链接</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root-&gt;left);   <span class="hljs-comment">// 将左子树头结点加入队列</span><br>        que.<span class="hljs-built_in">push</span>(root-&gt;right);  <span class="hljs-comment">// 将右子树头结点加入队列</span><br>        <br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">// 接下来就要判断这两个树是否相互翻转</span><br>            TreeNode* leftNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            TreeNode* rightNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;  <span class="hljs-comment">// 左节点为空、右节点为空，此时说明是对称的</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span><br>            <span class="hljs-keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;left);   <span class="hljs-comment">// 加入左节点左孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;right); <span class="hljs-comment">// 加入右节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;right);  <span class="hljs-comment">// 加入左节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;left);  <span class="hljs-comment">// 加入右节点左孩子</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day14</title>
    <link href="/2024/06/04/leetcode-day14/"/>
    <url>/2024/06/04/leetcode-day14/</url>
    
    <content type="html"><![CDATA[<p>今日内容： - 递归遍历<br />- 迭代遍历 - 统一迭代</p><p>三道例题：</p><p><ahref="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">前序遍历二叉树</a><ahref="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">中序遍历二叉树</a><ahref="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">后续遍历二叉树</a></p><h1 id="递归遍历">递归遍历</h1><p>太过简单，skip # 迭代遍历（非统一版） 使用栈模拟递归过程：</p><p>前序就是先访问当前节点值，然后压栈右左孩子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    stack&lt;TreeNode*&gt; st;<br>    TreeNode * cur = root;<br>    st.<span class="hljs-built_in">push</span>(cur);<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        cur = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        <span class="hljs-keyword">if</span>(cur-&gt;right) st.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left) st.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>中序就是先存所有左节点，直到遇<code>null</code>再出栈栈顶，访问值后压栈右节点（压栈的所有节点均不为空）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    stack&lt;TreeNode*&gt; st;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    TreeNode * cur = root;<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(cur);<br>            cur = cur-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cur = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>后序比较讨巧，左右中倒序就是中右左，把前序的压栈顺序调换，最后翻转结果就行，就不贴代码了</p><h1 id="统一迭代遍历">统一迭代遍历</h1><p>形式统一的迭代遍历，主要思想是压栈<code>null</code>来<strong>标记</strong>下一个节点需要访问，这样写出来的代码在压栈部分就可以只调换顺序实现三种遍历</p><p>个人感觉比较好理解，最好记住写法，下面以后序为例给出代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; st;<br>    TreeNode * cur = root;<br>    <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)st.<span class="hljs-built_in">push</span>(cur);<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        cur = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br><br>            st.<span class="hljs-built_in">push</span>(cur);<br>            st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-comment">//中</span><br><br>            <span class="hljs-keyword">if</span>(cur-&gt;right) st.<span class="hljs-built_in">push</span>(cur-&gt;right);<span class="hljs-comment">//右</span><br><br>            <span class="hljs-keyword">if</span>(cur-&gt;left) st.<span class="hljs-built_in">push</span>(cur-&gt;left);<span class="hljs-comment">//左</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>            cur = st.<span class="hljs-built_in">top</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day13</title>
    <link href="/2024/06/03/leetcode-day13/"/>
    <url>/2024/06/03/leetcode-day13/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/sliding-window-maximum/description/">239.滑动窗口最大值</a></li><li><a href="">347.前 K 个高频元素</a></li></ul><h1 id="滑动窗口最大值">239.滑动窗口最大值</h1><p>考验对于<code>priority_queue</code>数据结构的了解和掌握程度，不过不能当API选手，得知道怎么手写堆，不求随手手撕出大小顶堆，但是得知道大概写法。</p><h2id="关于priority_queue的感性理解">关于<code>priority_queue</code>的感性理解</h2><p>在lc上看见了评论区大佬，关于<code>priority_queue</code>的比喻描述很形象，特引用至此：</p><blockquote><p>单调队列真是一种让人感到五味杂陈的数据结构，它的维护过程更是如此.....就拿此题来说，队头最大，往队尾方向单调......有机会站在队头的老大永远心狠手辣，当它从队尾杀进去的时候，如果它发现这里面没一个够自己打的，它会毫无人性地屠城，把原先队里的人头全部丢出去，转身建立起自己的政权，野心勃勃地准备开创一个新的王朝.....这时候，它的人格竟发生了一百八十度大反转，它变成了一位胸怀宽广的慈父！它热情地请那些新来的“小个子”们入住自己的王国......然而，这些小个子似乎天性都是一样的——嫉妒心强，倘若见到比自己还小的居然更早入住王国，它们会心狠手辣地找一个夜晚把它们通通干掉，好让自己享受更大的“蛋糕”；当然，遇到比自己强大的，它们也没辙，乖乖夹起尾巴做人。像这样的暗杀事件每天都在上演，虽然王国里日益笼罩上白色恐怖，但是好在没有后来者强大到足以干翻国王，江山还算能稳住。直到有一天，闯进来了一位真正厉害的角色，就像当年打江山的国王一样，手段狠辣，野心膨胀，于是又是大屠城......历史总是轮回的。</p></blockquote><p>似乎没办法贴评论的链接，去description下找吧，应该挺靠前的。</p><p>叛军屠城 = 遇到新最值，<strong>全弹出</strong>; 慈悲为怀 =后续小值有序堆在队头之后;</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; pq;<span class="hljs-comment">//存pair，得带上值得下标方便确定是不是该出队</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">empty</span>()) pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<span class="hljs-comment">//空的直接存</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] &gt;= pq.<span class="hljs-built_in">top</span>().first) &#123;<span class="hljs-comment">//新最值，全出队</span><br>                <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>()) pq.<span class="hljs-built_in">pop</span>();<br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &gt;= k) &#123;<span class="hljs-comment">//已满</span><br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<br>                <span class="hljs-keyword">while</span>(pq.<span class="hljs-built_in">top</span>().second + k &lt;= i)<span class="hljs-comment">//出队已经晚了的,注意得是while</span><br>                    pq.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<br>            <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &gt;= k) ans.<span class="hljs-built_in">push_back</span>(pq.<span class="hljs-built_in">top</span>().first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="前k个高频元素">347.前k个高频元素</h1><p>感觉思路比较简单暴力，用map来记“值-频率”，然后根据“频率数组”建堆排序来降低时间复杂度到O(nlogn)以下。总之是先记再排序。</p><p>不过carl的反其道而行很巧妙，采用小根堆，这样就可以简单地根据队列盈满来出队队头，官解也是小根堆，不过没有简单出队，而是判断当前的和队头的哪个更小，如果队头更小才出队。</p><p>对于pq自定义排序标准的语法不了解，是看过之后才写的，对于这道题</p><p><code>priority_queue</code>的模板类型参数有三，1.要存的类型；2.要存的类型的vector；3.自定义比较方法所在类，自定义比较需重载<code>()</code>运算符</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">cmp</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//用map记录值-频率，通过优先队列或者堆来对前k个频率排序，最后输出前k个元素</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) map[i]++;<br><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, cmp&gt; pq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : map) &#123;<br>            pq.<span class="hljs-built_in">push</span>(it);<br>            <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &gt; k) pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span> (k--)&#123;<br>            <span class="hljs-type">int</span> t = pq.<span class="hljs-built_in">top</span>().first;<br>            ans.<span class="hljs-built_in">push_back</span>(t);<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day11</title>
    <link href="/2024/06/01/leetcode-day11/"/>
    <url>/2024/06/01/leetcode-day11/</url>
    
    <content type="html"><![CDATA[<p>今日内容： - <ahref="https://leetcode.cn/problems/valid-parentheses/description/">20.有效的括号</a>- <ahref="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">1047.删除字符串中所有相邻重复项</a>- <ahref="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150.逆波兰表达式求值</a></p><h1 id="有效的括号">20.有效的括号</h1><p>其实这题跟最后一个逆波兰表达式有关，最后一题是逆波兰表达式求值，但是根据中缀表达式生成逆波兰表达式的算法里就会用到栈来处理中缀中的括号问题。</p><p>所以一个栈直接秒了，思路打开，碰到左括号别傻傻push左括号，而得push右括号，这样就可以直接判断<code>top()</code>了，而不用碰到右括号的时候再来个转换。</p><p><del>没错，我这次就push的左括号，碰到右括号的时候还用ASCII码去算对应的左括号值</del></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stack&lt;<span class="hljs-type">char</span>&gt; b;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) b.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) b.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span>) b.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b.<span class="hljs-built_in">empty</span>() || s[i] != b.<span class="hljs-built_in">top</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> b.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> b.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除字符串中所有相邻重复项">1047.删除字符串中所有相邻重复项</h1><p>如果不告诉用栈做的话，貌似还挺复杂的，不过用栈就很简单了</p><p>压栈前判断栈顶是不是重复，重复就pop，不重复就push，建议从尾到头遍历s，这样全pop出来时顺序还是对的。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() != s[i]) st.<span class="hljs-built_in">push</span>(s[i]);<br>            <span class="hljs-keyword">else</span> st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        string ans;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;!st.<span class="hljs-built_in">empty</span>();i++) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(st.<span class="hljs-built_in">top</span>());<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="逆波兰表达式求值">105.逆波兰表达式求值</h1><p>笔者大一下的Qt课设就是写一个大数计算器，对这逆波兰表达式还是比较熟悉，有了式子，求值就比较简单了，这个题还确保了int不炸。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; tokens.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;+&quot;</span> || tokens[i] == <span class="hljs-string">&quot;-&quot;</span> || tokens[i] == <span class="hljs-string">&quot;*&quot;</span> || tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>                <span class="hljs-type">int</span> num1 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> num2 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;+&quot;</span>) st.<span class="hljs-built_in">push</span>(num1 + num2);<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;-&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 - num1);<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;*&quot;</span>) st.<span class="hljs-built_in">push</span>(num1 * num2);<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 / num1);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(tokens[i]));<br>        &#125;<br>        <span class="hljs-type">int</span> res = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day10</title>
    <link href="/2024/05/31/leetcode-day10/"/>
    <url>/2024/05/31/leetcode-day10/</url>
    
    <content type="html"><![CDATA[<p>此帖仅作打卡用，过于简单，建议跳过 # <ahref="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232.用栈实现队列</a></p><p>根据题意，用俩栈来回倒就行</p><h2 id="code">code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; q1;<br>    stack&lt;<span class="hljs-type">int</span>&gt; q2;<br>    <span class="hljs-built_in">MyQueue</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q2.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> pipe = q2.<span class="hljs-built_in">top</span>();<br>            q2.<span class="hljs-built_in">pop</span>();<br>            q1.<span class="hljs-built_in">push</span>(pipe);<br>        &#125;<br>        q1.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> pipe = q1.<span class="hljs-built_in">top</span>();<br>            q1.<span class="hljs-built_in">pop</span>();<br>            q2.<span class="hljs-built_in">push</span>(pipe);<br>        &#125;<br>        <span class="hljs-type">int</span> ans = q2.<span class="hljs-built_in">top</span>();<br>        q2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> pipe = q1.<span class="hljs-built_in">top</span>();<br>            q1.<span class="hljs-built_in">pop</span>();<br>            q2.<span class="hljs-built_in">push</span>(pipe);<br>        &#125;<br>        <span class="hljs-keyword">return</span> q2.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">empty</span>() &amp;&amp; q2.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="用队列实现栈"><ahref="https://leetcode.cn/problems/implement-stack-using-queues/">225.用队列实现栈</a></h1><p>一个双端队列完事</p><h2 id="code-1">code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    deque&lt;<span class="hljs-type">int</span>&gt; d1;<br>    <span class="hljs-built_in">MyStack</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        d1.<span class="hljs-built_in">push_front</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> p = d1.<span class="hljs-built_in">front</span>();<br>        d1.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> d1.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> d1.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day6</title>
    <link href="/2024/05/30/leetcode-day6/"/>
    <url>/2024/05/30/leetcode-day6/</url>
    
    <content type="html"><![CDATA[<h1 id="有效的字母异位词"><ahref="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">有效的字母异位词</a></h1><p>哈希表新手题，不过可以直接排序再判断，剑走偏锋不用哈希</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() != t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> s == t;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="两个数组的交集"><ahref="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">两个数组的交集</a></h1><p>这个也可以排序然后双指针，不用哈希，时间复杂度<code>O(mlogm+nlogn)</code>，主要是排序的复杂度，空间复杂度<code>O(mlogm+nlogn)</code>也是排序造成的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> len1 = nums1.<span class="hljs-built_in">size</span>(), len2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> index1 = <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span>(index1 &lt; len1 &amp;&amp; index2 &lt; len2) &#123;<br>            <span class="hljs-keyword">if</span>(nums1[index1] == nums2[index2]) &#123;<br>                <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || nums1[index1] != ans.<span class="hljs-built_in">back</span>()) ans.<span class="hljs-built_in">push_back</span>(nums1[index1]);<br>                index1++;<br>                index2++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[index1] &lt; nums2[index2]) index1++;<br>            <span class="hljs-keyword">else</span> index2++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="快乐数"><ahref="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">快乐数</a></h1><p>这题和<ahref="https://leetcode.cn/problems/linked-list-cycle-ii/description/">环形链表II</a>有点异曲同工之妙，笔者的做法是用一个set来记录每次计算的结果，重复就false，等于1就true。</p><p>但看过评论区后发现，这样只是走了int限制的捷径，有可能会爆栈，所以不能记录，而应该采取环形链表中检查环的方法——追及问题。</p><p>用快慢指针，不过指的是计算结果，如果fast最终等于slow，则有环，false，这样空间复杂度就成了O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitSquareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> bit = n % <span class="hljs-number">10</span>;<br>            sum += bit * bit;<br>            n = n / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slow = n, fast = n;<br>        <span class="hljs-keyword">do</span>&#123;<br>            slow = <span class="hljs-built_in">bitSquareSum</span>(slow);<br>            fast = <span class="hljs-built_in">bitSquareSum</span>(fast);<br>            fast = <span class="hljs-built_in">bitSquareSum</span>(fast);<br>        &#125;<span class="hljs-keyword">while</span>(slow != fast);<br>        <br>        <span class="hljs-keyword">return</span> slow == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><ahref="https://leetcode.cn/problems/happy-number/solutions/21454/shi-yong-kuai-man-zhi-zhen-si-xiang-zhao-chu-xun-h/">该题解来源</a></p><h1 id="两数之和"><ahref="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">两数之和</a></h1><p>思路还记得，用哈希来记录target -x，利用set查找的O(1)复杂度来优化查找过程。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">find</span>(target - nums[i]);<br>            <span class="hljs-keyword">if</span>(it != map.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> &#123;it-&gt;second, i&#125;;<br>            map[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="unordered_set">unordered_set</h1><ul><li>无序存储</li><li>元素独一无二，即键值key唯一 ## 常用方法</li><li><code>unorder_set&lt;string&gt; first</code>容器定义</li><li><code>first.empty()</code>判断容器是否是空，是空返回<code>true</code>，反之为<code>false</code></li><li><code>first.size()</code>返回容器大小</li><li><code>first.maxsize()</code>返回容器最大尺寸</li><li><code>first.begin()</code>返回迭代器开始</li><li><code>first.end()</code>返回迭代器结束</li><li><code>first.find(value)</code>返回<code>value</code>在迭代器的位置，没找到会返回<code>end()</code></li><li><code>first.count(key)</code>返回key在容器的个数</li><li><code>first.insert(value)</code>将value插入到容器中</li><li><code>first.erase(key)</code>通过key删除</li><li><code>first.clear()</code>清空容器 <ahref="https://cplusplus.com/reference/unordered_map/unordered_map/">详细文档</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day4</title>
    <link href="/2024/05/30/leetcode-day4/"/>
    <url>/2024/05/30/leetcode-day4/</url>
    
    <content type="html"><![CDATA[<h1 id="两两交换链表中的节点"><ahref="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24.两两交换链表中的节点</a></h1><p>​链表貌似就是虚头+双指针+遍历，回到老家的感觉，注意对空节点的检查就好，题不难</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode * virhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        virhead-&gt;next = head;<br>        ListNode * left = virhead;<br>        ListNode * right = head;<br>        <span class="hljs-keyword">while</span>(right &amp;&amp; right-&gt;next) &#123;<br>            left-&gt;next = right-&gt;next;<br>            right-&gt;next = right-&gt;next-&gt;next;<br>            left-&gt;next-&gt;next = right;<br>            left = right;<br>            right = right-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> virhead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除链表的倒数第n个节点"><ahref="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19.删除链表的倒数第n个节点</a></h1><p>算脑筋急转弯吧，不过之前做过，已经没有难度了，思路就是让fast先走n步，再和slow一起走，这样fast走到最后slow就是倒数第n个了。</p><blockquote><p>​评论区在diss官解的“一次遍历”说法，去搜了一下，看见了宫水三叶前辈的帖，下为结论：</p><p>我们应该用「对数组的访问次数」来定义遍历多少次，而不是「利用 for循环的个数」来定义。 上述无论那种方法，对数组访问次数都是一样的。</p><p>出处：<ahref="https://developer.aliyun.com/article/905822">为什么「一次遍历」要比「两次遍历」慢（含小实验代码） | Java 刷题打卡-阿里云开发者社区 (aliyun.com)</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode * vir = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        vir-&gt;next = head;<br>        ListNode * fast = vir;<br>        ListNode * slow = vir;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        ListNode * t = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> t;<br>        <span class="hljs-keyword">return</span> vir-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="链表相交"><ahref="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">链表相交</a></h1><p>思路比较原始，都走一遍，把屁股对齐，长的先走几步把优势消耗，然后一起走找交点。</p><p>官解的追及思路更优雅，不过复杂度相同。<ahref="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solutions/1395092/lian-biao-xiang-jiao-by-leetcode-solutio-2kne/">官解</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode * vir = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        vir-&gt;next = head;<br>        ListNode * fast = vir;<br>        ListNode * slow = vir;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        ListNode * t = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> t;<br>        <span class="hljs-keyword">return</span> vir-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="环形链表ii"><ahref="https://leetcode.cn/problems/linked-list-cycle-ii/description/">环形链表II</a></h1><p>数学题，刚开始没推出来，注意把环分成走过的b段和没走过的c段，这样就很直观了，贴个图帮助理解</p><figure><img src="https://s3.bmp.ovh/imgs/2024/05/31/868052041ecc7ee9.jpg"alt="环形链表示意图" /><figcaption aria-hidden="true">环形链表示意图</figcaption></figure><p><em>公式中a对应图中x，y对应b，z对应c</em></p><p>求的是a，slow被碰到时离入口还差c，所以此时再来个指针从头开始一起走，碰到的时候刚好就是等式两边，即入口。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode * fast = head;<br>        ListNode * slow = head;<br>        <span class="hljs-keyword">while</span>(fast) &#123;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(!fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast == slow) &#123;<br>                ListNode * ans = head;<br>                <span class="hljs-keyword">while</span>(ans != slow) &#123;<br>                    ans = ans-&gt;next;<br>                    slow = slow-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>不太难，链表问题不大，注意空指针检查就行。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day3</title>
    <link href="/2024/05/30/leetcode-day3/"/>
    <url>/2024/05/30/leetcode-day3/</url>
    
    <content type="html"><![CDATA[<p>​ # <ahref="https://leetcode.cn/problems/remove-linked-list-elements/description/">203.移除链表元素</a></p><p>看见链表跟回家一样，大一走来就研究链表，被-&gt;和 .的用法confuse了好久，然后链表操作信手拈来，现在实现个线性表、栈、队列都是拿链表来实现，数组都不会写了……</p><p>题很简单，拿java练练语法好了，就连java都是一把过： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        h.next = head;<br>        ListNode cur = h;<br>        <span class="hljs-keyword">while</span>(cur.next != null) &#123;<br>            <span class="hljs-keyword">if</span>(cur.next.val == val) &#123;<br>                cur.next = cur.next.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>                cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="设计链表"><ahref="https://leetcode.cn/problems/design-linked-list/description/">707.设计链表</a></h1><p>群友遇到问题，跟着debug了一会，本来不想做的，给出修改后的群友代码吧，收获也有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(index--)<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; index;i++)<br></code></pre></td></tr></table></figure><p>就是这上面俩是等效的，不够之前知道，算加深印象吧，毕竟while(index--)这样的写法不常见，但是字少。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;<br>        <span class="hljs-type">int</span> val;<br>        LNode* next;<br>        <span class="hljs-built_in">LNode</span>(<span class="hljs-type">int</span> v):<span class="hljs-built_in">val</span>(v),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125; <span class="hljs-comment">//构造函数</span><br>       <span class="hljs-comment">// LNode(int v)&#123; val=v,next=nullptr;&#125;</span><br>    &#125;;<br>    <span class="hljs-built_in">MyLinkedList</span>() &#123;<br>        <span class="hljs-comment">//建立空链表</span><br>        lsize=<span class="hljs-number">0</span>;<br>        lhead=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;=lsize) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        LNode* p=lhead;<br>        <span class="hljs-comment">//从第一个实际数据开始遍历，当循环结束，一定是p指向了Index位置</span><br>        <span class="hljs-keyword">while</span>(index--)<br>            p=p-&gt;next;<br>        p=p-&gt;next;<br>        <span class="hljs-keyword">return</span> p-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//将val插入作为第一个节点，即头结点的下一个</span><br>        LNode* np=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(val);<br>        np-&gt;next=lhead-&gt;next;<br>        lhead-&gt;next=np;<br>        lsize++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//在最后增加节点</span><br>        LNode* np=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(val);<br>        LNode* p=lhead;<br>        <span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            p=p-&gt;next;<br>        &#125;<br>        np-&gt;next=p-&gt;next;<br>        p-&gt;next=np;<br>        lsize++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&gt;lsize) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(index == lsize) &#123;<br>            <span class="hljs-built_in">addAtTail</span>(val);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        LNode* np=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(val);<br>        LNode* p=lhead;<br>        <span class="hljs-keyword">while</span>(index--)<br>            p=p-&gt;next;<br>        np-&gt;next=p-&gt;next;<br>        p-&gt;next=np;<br>        lsize++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;=lsize) <span class="hljs-keyword">return</span>;<br>        LNode* p=lhead;<br>        <span class="hljs-keyword">while</span>(index--)<br>            p=p-&gt;next;<br>        LNode* tmp=p-&gt;next;<br>           p-&gt;next=p-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        lsize--;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> lsize;<br>    LNode* lhead;<br>&#125;;<br></code></pre></td></tr></table></figure> # <ahref="https://leetcode.cn/problems/reverse-linked-list/description/">206.反转链表</a>主要看了下递归做法，对于递归还是很迷，这次也没有一次写出来。</p><p>将后续部分看作已经反转完成，所以当前节点的下一个节点的下一个应该变成当前，即：</p><p><code>cur-&gt;next-&gt;next = cur;</code></p><p>对于头节点，再加一个next指null，就完成了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode * virHead = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> virHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure> ​</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day8</title>
    <link href="/2024/05/29/leetcode_day8/"/>
    <url>/2024/05/29/leetcode_day8/</url>
    
    <content type="html"><![CDATA[<h1 id="反转字符串ii"><ahref="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">反转字符串II</a></h1><p>按题意模拟即可，重写reverse方法，方便直接根据下标反转<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i += k) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span>*k == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">reverse</span>(s, begin, i / <span class="hljs-number">2</span>);<br>                begin = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= end) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">while</span>(begin &lt; end)&#123;<br>            <span class="hljs-type">char</span> c = s[begin];<br>            s[begin] = s[end];<br>            s[end] = c;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="替换数字"><ahref="https://programmercarl.com/kama54.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html">替换数字</a></h1><p>预先扩充好空间，然后<strong>从后向前</strong>扫描 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>        <span class="hljs-type">int</span> sOldIndex = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计数字的个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 扩充字符串s的大小，也就是将每个数字替换成&quot;number&quot;之后的大小</span><br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + count * <span class="hljs-number">5</span>);<br>        <span class="hljs-type">int</span> sNewIndex = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 从后往前将数字替换为&quot;number&quot;</span><br>        <span class="hljs-keyword">while</span> (sOldIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (s[sOldIndex] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[sOldIndex] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;r&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;e&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;m&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;u&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;n&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                s[sNewIndex--] = s[sOldIndex];<br>            &#125;<br>            sOldIndex--;<br>        &#125;<br>        cout &lt;&lt; s &lt;&lt; endl;       <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> # <ahref="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">反转单词</a>思路比较巧，全部反转，然后再反转单词，这样就得到了词序反转，注意删除空格<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">auto</span> it1 = s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">auto</span> it2 = s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(it2 != s.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">while</span>(*it2 != <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; it2 != s.<span class="hljs-built_in">end</span>()) it2++;<br>            <span class="hljs-built_in">reverse</span>(it1, it2);<br>            <span class="hljs-keyword">while</span>(*it2 == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; it2 != s.<span class="hljs-built_in">end</span>()) it2++;<br>            it1 = it2;<br>        &#125;<br>        it1=s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(it1!=s.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(it1==s.<span class="hljs-built_in">begin</span>() &amp;&amp; *it1 == <span class="hljs-string">&#x27; &#x27;</span>) s.<span class="hljs-built_in">erase</span>(it1);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*it1 == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; *<span class="hljs-built_in">next</span>(it1) == <span class="hljs-string">&#x27; &#x27;</span>) s.<span class="hljs-built_in">erase</span>(it1);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">next</span>(it1) == s.<span class="hljs-built_in">end</span>() &amp;&amp; *it1 == <span class="hljs-string">&#x27; &#x27;</span>) s.<span class="hljs-built_in">erase</span>(it1);<br>            <span class="hljs-keyword">else</span> it1++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure> # <ahref="https://programmercarl.com/kama55.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html">右旋字符串</a>思路与反转单词差不多，整体局部反转活用就行 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    string s;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//获取长度</span><br><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 整体反转</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + n); <span class="hljs-comment">// 先反转前一段，长度n</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + n, s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 再反转后一段</span><br><br>    cout &lt;&lt; s &lt;&lt; endl;<br><br>&#125; <br></code></pre></td></tr></table></figure>字符串和数组很像，后面的kmp上难度，前面的比较简单，略过即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day7</title>
    <link href="/2024/05/28/leetcode_day7/"/>
    <url>/2024/05/28/leetcode_day7/</url>
    
    <content type="html"><![CDATA[<h1 id="四数相加"><ahref="https://leetcode.cn/problems/4sum-ii/description/">454.四数相加</a></h1><blockquote><p>视频讲解: <ahref="https://www.bilibili.com/video/BV1Md4y1Q7Yh/">学透哈希表，map使用有技巧！LeetCode：454.四数相加II</a></p><p>文章讲解：<ahref="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html">454.四数相加</a></p></blockquote><p>之前做过，知道用map，但是太久没用过map，一时间不知道怎么用map，干瞪眼十几分钟，最后看了题解，思路有，但是map的用法限制了我……</p><h2id="unordered_map怎么在算法题中使用">unordered_map怎么在算法题中使用</h2><p>unordered_map是std命名空间下的，所以自己写ACM模式的时候记得加<code>std::</code></p><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td><code>map</code></td><td>红黑树</td><td>key有序</td><td>key不重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td><code>multimap</code></td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td><code>unordered_map</code></td><td>哈希表</td><td>key无序</td><td>key不重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>由该表能看出，unordered_map查找的效率最高，但是内部元素无序</p><p>适用于：当作记录型变量用于需要多次查找的场合</p><p><strong>创建unordered_map</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//注意给出两个模板类型变量</span><br>unordered_map&lt;type1, type2&gt; map;<br><span class="hljs-comment">//设定初值方法</span><br>unordered_map&lt;t1, t2&gt; map = &#123;&#123;key1, value1&#125;, &#123;key2, value2&#125;, ……&#125;;<br>vector&lt;pair&lt;t1, t2&gt;&gt; v = &#123;&#123;key1, value1&#125;, &#123;key2, value2&#125;, ……&#125;;  <br><span class="hljs-comment">//使用既有pair数组初始化</span><br><span class="hljs-function">unordered_map&lt;<span class="hljs-type">int</span>, string&gt; <span class="hljs-title">map</span><span class="hljs-params">(v.begin(), v.end())</span></span>;<br></code></pre></td></tr></table></figure><p><strong>插入一个元素进map</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果要记录的是&lt;key, value&gt;</span><br>map[key] = value;<br><span class="hljs-comment">//或者复杂点</span><br>map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;type1, type2&gt;(key, value));<br><span class="hljs-comment">//如果记录key出现几次</span><br>map[key]++;<span class="hljs-comment">//[]被重载过，即使没有key也会创建一个并赋值1</span><br></code></pre></td></tr></table></figure><p><strong>map的迭代器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用迭代器访问key和value</span><br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map;<br><span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">begin</span>();<br>it-&gt;first = key;<span class="hljs-comment">//it视作一个pair&lt;int, string&gt;元素，用-&gt;访问key和value</span><br>it-&gt;second = value;<span class="hljs-comment">//说白了就是用first和second</span><br></code></pre></td></tr></table></figure><p><strong>map的增删改查方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> type1&amp; key)</span>    <span class="hljs-comment">//返回key在map中的位置，没有就指end()</span></span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">const</span> type1&amp; key)</span>    <span class="hljs-comment">//返回哈希桶中关键码为key的键值对的个数</span></span><br><span class="hljs-function">insert    <span class="hljs-comment">//插入键值对</span></span><br><span class="hljs-function">erase     <span class="hljs-comment">//删除键值对</span></span><br></code></pre></td></tr></table></figure><p>注意<code>erase</code>方法是使用迭代器删除元素，传入的参数指向目标的迭代器，而返回下一个元素的迭代器，用<code>for</code>遍历删除时不要 <code>iter++</code>，应该使用<code>iter = map.erase(iter)</code></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : nums1) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b : nums2) &#123;<br>                <span class="hljs-type">int</span> sum = a + b;<br>                map1[sum]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : nums3) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b : nums4) &#123;<br>                <span class="hljs-keyword">if</span>(map1.<span class="hljs-built_in">count</span>(-a-b)) <br>                    ans += map1[-a-b];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="赎金信"><ahref="https://leetcode.cn/problems/ransom-note/description/">383.赎金信</a></h1><blockquote><p>Carl文章&amp;视频链接：<ahref="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html">代码随想录| 383.赎金信</a></p></blockquote><p>看覆不覆盖就完了，用 <code>char alpha[26]</code>或者开一个<code>map</code>都行，一次遍历 <code>++</code>，一次遍历<code>--</code>，缺了就 <code>false</code>，不缺就 <code>true</code></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : magazine) &#123;<br>            map[c]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : ransomNote) &#123;<br>            <span class="hljs-keyword">if</span>(map[c]) map[c]--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="三数之和双指针"><ahref="https://leetcode.cn/problems/3sum/description/">15.三数之和（双指针）</a></h1><blockquote><p>Carl文章&amp;视频链接：<ahref="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录| 三数之和</a></p></blockquote><p>该题看起来是<ahref="https://leetcode.cn/problems/two-sum/description/">两数之和</a>的拓展，所以自然想到用双指针，但是有3个数，得3个指针，所以拆分子问题，一个指针在大循环里移动，小循环内使用两数之和的方法查找。</p><p>还得去重操作，没有关注，WA了几发，哈希做法需要大量剪枝没看。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">2</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> target = -nums[i];<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>                <span class="hljs-type">int</span> sum = nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>(sum == target) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    left++;<br>                    right--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target) &#123;<br>                    left++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <br>                    right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="四数之和双指针"><ahref="https://leetcode.cn/problems/4sum/description/">四数之和（双指针）</a></h1><blockquote><p>Carl文章&amp;视频链接：<ahref="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录| 四数之和</a></p></blockquote><p>跟三数之和差不多，继续拆分子问题套循环，不过又多了剪枝操作</p><p>还得注意范围，此题会爆 <code>int</code>，得用<code>long long</code></p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>      <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">3</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) &#123;<span class="hljs-comment">//已经太大</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<span class="hljs-comment">//已经太小</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;j &lt; n - <span class="hljs-number">2</span>;j++) &#123;<br>                <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) &#123;<span class="hljs-comment">//已经太大</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[j] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<span class="hljs-comment">//已经太小</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> left = j + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[left] + nums[right] + nums[i] + nums[j];<br>                    <span class="hljs-keyword">if</span>(sum == target) &#123;<br>                        ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt; &#123;nums[i], nums[j], nums[left], nums[right]&#125;);<br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                        left++;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) &#123;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <br>                        left++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迷迭香的记事本：怎么写博客</title>
    <link href="/2024/05/27/%E8%BF%B7%E8%BF%AD%E9%A6%99%E7%9A%84%E8%AE%B0%E4%BA%8B%E6%9C%AC%EF%BC%9A%E6%80%8E%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/05/27/%E8%BF%B7%E8%BF%AD%E9%A6%99%E7%9A%84%E8%AE%B0%E4%BA%8B%E6%9C%AC%EF%BC%9A%E6%80%8E%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1><p>目前，如果misery想要写一篇博客，本地步骤为： 1.打开创建在<code>D:</code>的<code>blog</code>文件夹 2.右键，<code>git bash here</code>，输入<code>hexo new blog 'YOUR_BLOG_NAME'</code>3.进入<code>source\_post</code>文件夹中，找到step2创建的YOUR_BLOG_NAME.md文件，用vscode打开，进行编辑4.回到bash，输入<code>hexo g</code>重新生成静态页面，选择性输入<code>hexo s</code>预览效果5. 输入<code>hexo d</code>上传到github</p><h1id="hexo-d后博客未发生变化"><code>hexo d</code>后博客未发生变化?</h1><p>如果step5执行后，repository中看得见变化，能找到博客，但是网页并未发生变化，则回到<code>/blog</code>下的bash中输入<code>hexo clean</code>清除缓存（删除<code>/public</code>文件夹），重新从step4执行即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day2</title>
    <link href="/2024/05/23/leetcode-day2/"/>
    <url>/2024/05/23/leetcode-day2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第二天就有所松懈了，拖到晚上才写，拓展题也没写完，今天的没那么无脑，所以用老本行C++写</p></blockquote><h1 id="有序数组的平方"><ahref="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组的平方</a></h1><p>打眼一瞧，这题就是拿正负数平方之后大小不定来考人，结合卡哥想练的双指针，不难想到左右指针比绝对值大小一个一个插入，虽然这样是从大到小，不过有<code>reverse()</code>可以用，比较方便，也没有增加时间复杂度，还是O(n)，下附代码，不甚完美，可点击链接去看官解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">​<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(nums[left]) &lt; <span class="hljs-built_in">abs</span>(nums[right])) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums[right] * nums[right]);<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(nums[left]) &gt;= <span class="hljs-built_in">abs</span>(nums[right])) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums[left] * nums[left]);<br>                left++;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="长度最小的子数组"><ahref="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a></h1><p>​ 题目：给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其总和大于等于 <code>target </code>的长度最小的 连续子数组<code>[numsl, numsl+1, ..., numsr-1, numsr] </code>，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>这题是滑动窗口，由于做过多次，所以记得比较清楚，直接写了，结果遇到不少问题，WA了一发才解决，对于区间开闭的把握还不纯熟……<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> target &lt;= nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">1</span>, sum = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right &lt;= nums.<span class="hljs-built_in">size</span>() &amp;&amp; left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span>(sum &lt; target &amp;&amp; right &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>                sum += nums[right++];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt;= target &amp;&amp; left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>) ans = right - left;<br>                <span class="hljs-keyword">else</span> ans = <span class="hljs-built_in">min</span>(ans, right - left);<br>                sum -= nums[left++];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="拓展水果成篮">拓展——<ahref="https://leetcode.cn/problems/fruit-into-baskets/">水果成篮</a></h1><p>​这题是卡哥关于滑动窗口的拓展题1，小生不才，WA了五发才过，思路一直不清，将思路转换为代码语言也不准确。</p><blockquote><p>大概描述思路：</p></blockquote><blockquote><p>俩篮子我用俩变量bucket1、2来模拟，含左右顺序，俩指针做滑动窗口代表当前能摘的树。一个ans作为结果一直维护一个最大值，每遇到新树，则将left前进到第二种水果第一次出现的地方，right重新从left处开始走。至于第一次出现的位置我用一个<code>pair</code>来存。</p></blockquote><p>下附代码，官解与我不同，使用了哈希表，我也想用，苦于set和map系列语法掌握不牢，没写出来……<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fruits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(fruits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; bucket1, bucket2;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">1</span>;<br>        bucket1.first = fruits[left];<br>        bucket1.second = left;<br>        bucket2.first = <span class="hljs-number">-1</span>;<br>        bucket2.second = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; right &lt; fruits.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(fruits[right] == bucket1.first) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fruits[right] == bucket2.first) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bucket2.first == <span class="hljs-number">-1</span>)&#123;<br>                bucket2.first = fruits[right];<br>                bucket2.second = right;<br>                ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                left = bucket2.second;<br>                bucket1.first = bucket2.first;<br>                bucket1.second = left;<br>                bucket2.first = <span class="hljs-number">-1</span>;<br>                bucket2.second = <span class="hljs-number">-1</span>;<br>                right = left;<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>leetcode 官方题解：<ahref="https://leetcode.cn/problems/fruit-into-baskets/solutions/1893352/shui-guo-cheng-lan-by-leetcode-solution-1uyu/">水果成篮</a></p><h1 id="拓展最小覆盖子串">拓展——<ahref="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></h1><p>吐了，写的全没了，不记了，直接抛出灵神题解算了，哈希方法的确妙，还有less对于检索的优化。</p><p><ahref="https://leetcode.cn/problems/minimum-window-substring/solutions/2713911/liang-chong-fang-fa-cong-o52mn-dao-omnfu-3ezz/">灵茶山艾府题解</a></p><h1 id="螺旋矩阵ii"><ahref="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵II</a></h1><p>这题经典模拟，之前做过多次，这次一把过，左sir讲过优雅的四循环，评论区也是优雅的四循环，所以我也优雅的四循环，但还是不够优雅。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, bottom = n - <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> map[n][n];<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(k &lt;= n*n) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = left;t &lt;= right;t++) <br>                map[top][t] = k++;<br>            top++;<br>            <span class="hljs-keyword">if</span>(k &gt; n*n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = top;r &lt;= bottom;r++) <br>                map[r][right] = k++;<br>            right--;<br>            <span class="hljs-keyword">if</span>(k &gt; n*n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b = right;b &gt;= left;b--)<br>                map[bottom][b] = k++;<br>            bottom--;<br>            <span class="hljs-keyword">if</span>(k &gt; n*n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = bottom;l &gt;= top;l--)<br>                map[l][left] = k++;<br>            left++;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; t;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>                t.<span class="hljs-built_in">push_back</span>(map[i][j]);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(t);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="总结">​总结</h1><p>数组部分总体不难，主要是双指针和滑动窗口思想，双指针有快慢指针和左右指针，滑动窗口偏贪心一点，大体是right向前去满足条件，满足之后收紧left寻找最优，最后综合所有最优选出整体最优。</p><p>​</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day1</title>
    <link href="/2024/05/22/leetcode-day1/"/>
    <url>/2024/05/22/leetcode-day1/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><ahref="https://leetcode.cn/problems/binary-search/">二分查找</a></h1><p>之前用C++刷过不止一遍，所以这次用java重写，没想到遇到了语法问题，尴尬……</p><ul><li>参数给的<code>int[] nums</code>，跟C的普通数组一样吗？那我怎么得到长度呢？java有<code>sizeof()</code>吗？</li><li>我第一时间想递归，但是怎么传被分割后的数组呢？</li></ul><p>搜索学习一波后了解到，java的<code>int[]</code>类型可以获取长度，具体见下：</p><h2 id="java数组语法小记">java数组语法小记</h2><h3 id="length属性">length属性</h3><ul><li>"length"是数组的一个属性，用于获取数组的长度。</li><li>这是数组对象的一个公共属性，不是类的成员。</li></ul><p>例如： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <br>System.out.println(nums.length); <span class="hljs-comment">// 输出数组的长度：5</span><br></code></pre></td></tr></table></figure> ### 其他可用的操作虽然length是唯一一个直接通过点符号（.）访问的数组属性，但数组对象还可以通过一些标准的类库方法进行操作。例如：</p><ol type="1"><li><p><strong>Arrays 类：</strong></p><p>Arrays 类提供了许多静态方法来操作数组，例如排序、搜索、比较、填充等。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays; <br><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;; <br>Arrays.sort(nums); <span class="hljs-comment">// 对数组进行排序</span><br>System.out.println(Arrays.toString(nums)); <span class="hljs-comment">// 将数组转换为字符串并输出：[1, 1, 3, 4, 5]</span><br></code></pre></td></tr></table></figure></p></li><li><p>​<strong>System 类：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System 类提供了一些方法来进行数组的复制等操作。<br><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <br><span class="hljs-type">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>System.arraycopy(nums, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>, nums.length); <span class="hljs-comment">// 复制数组</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>Collections 类（适用于对象数组）：</strong>对于对象数组，可以使用 Collections类的方法进行排序、搜索等操作，但对于基本类型数组（如 int[]），需要使用Arrays 类的方法。</p></li></ol><h3 id="数组的其他特性">​数组的其他特性</h3><ul><li><strong>数组是对象：</strong>-在Java中，所有的数组类型都是对象，并且继承自 java.lang.Object 类。</li><li><strong>多维数组：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] matrix = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125; &#125;;<br>System.out.println(matrix.length); <span class="hljs-comment">// 输出二维数组的行数：3 </span><br>System.out.println(matrix[<span class="hljs-number">0</span>].length); <span class="hljs-comment">// 输出二维数组的第一行的列数：3</span><br></code></pre></td></tr></table></figure><ul><li>Java支持多维数组，通过嵌套数组的方式实现。</li></ul></li><li><strong>无法改变大小：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <br>list.add(<span class="hljs-number">1</span>); list.add(<span class="hljs-number">2</span>); <br>System.out.println(list.size()); <span class="hljs-comment">// 输出列表的大小：2</span><br></code></pre></td></tr></table></figure></li><li>数组一旦创建，其大小是固定的。如果需要一个可以动态调整大小的数组，可以使用ArrayList 或其他集合类。</li></ul><h2 id="代码实现递归版">​代码实现（递归版）</h2><p>至于具体算法细节，仍然是carl所教的左闭右开和左闭右闭</p><p><strong>左闭右开</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchHelp(<span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, nums, target);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchHelp</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span>(begin == end) &#123;<br>            <span class="hljs-keyword">return</span> target == nums[begin] ? begin : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end - begin) / <span class="hljs-number">2</span> + begin;<br>        <span class="hljs-keyword">if</span>(target &lt;= nums[mid]) <span class="hljs-keyword">return</span> searchHelp(begin, mid, nums, target);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> searchHelp(mid + <span class="hljs-number">1</span>, end, nums, target);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <strong>左闭右闭</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchHelp(<span class="hljs-number">0</span>, nums.length, nums, target);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchHelp</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= end - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(begin &gt; end - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> target == nums[begin] ? begin : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end - begin) / <span class="hljs-number">2</span> + begin;<br>        <span class="hljs-keyword">if</span>(target &lt; nums[mid]) <span class="hljs-keyword">return</span> searchHelp(begin, mid, nums, target);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> searchHelp(mid , end, nums, target);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> # ​二分拓展——在排序数组中查找元素的第一个和最后一个位置 <ahref="https://leetcode.cn/problems/binary-search/">题目链接</a></p><p>还没做此题时，算法群中有人讨论，瞄到了“二分定位然后发散找边界”的思路，窃以为很有道理，然另一群友diss：“全是一样的就成了O(n)了”，有道理哈。</p><p>自己做的时候的确直觉想到"二分定位然后发散"的思路，但是有意避免，于是想到两次二分分别定左右边界。下附代码，与官方题解区别在于，官方使用了一个"lower"标志位来区分左右边界，把两次二分合成一个方法。而我的代码直接写了两次，把等号换地方。记得第一次二分后把right弄回去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt;= target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left &gt;= nums.length || nums[left] != target) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">else</span> ans[<span class="hljs-number">0</span>] = left;<br>        right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt;= target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        ans[<span class="hljs-number">1</span>] = right;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="移除元素"><ahref="https://leetcode.cn/problems/remove-element/">移除元素</a></h1><p>​此题貌似是力扣新手村的一道题，以前错过多次，感叹于自己的菜，于是这次还记得解法，但仍然没有一把AC，在去重的时候没有考虑好只有一个元素和空表的情况。下附鄙人代码，未深入优化，恐有瑕疵，望读者建言：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">while</span>(right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[right] == val) right--;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span>(nums[right] == val &amp;&amp; left &lt; right) right--;<br>            <span class="hljs-keyword">while</span>(nums[left] != val &amp;&amp; left &lt; right) left++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = temp;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>第一天打卡，希望能够坚持下去，同时笔者还在看dolphinscheduler，看不懂啊……想参加开源之夏，但是好像截止前连项目都看不懂，抓紧时间，加油加油！</p><p><strong>ps</strong>算法群里遇到一个问题，在遍历数组的时候，<code>fast &lt; nums.size()</code>就AC，<code>fast &lt;= nums.size() - 1</code>就RE，原来是因为：</p><p>vector的size方法返回的是无符号整数，减一之后不会变-1，而是变大，条件就无效了。</p><p>空vector才会碰见的坑，长见识了。</p><p>​</p><p>​</p><p>​ ​ ​</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
