<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>小小的科研总结</title>
    <link href="/2025/04/04/%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%A7%91%E7%A0%94%E6%80%BB%E7%BB%93/"/>
    <url>/2025/04/04/%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%A7%91%E7%A0%94%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>Warning：个人实践理解 + AI解释 + 二手博客信息汇总，如有错误，请于底部评论区批评指正，全文仅供参考</p>          </div><div class="note note-success">            <p>在此感谢师兄对我的指导和老师提供的实验经费！！</p>          </div><p>git记录从2月25日开始，那天pull下来了 <ahref="https://github.com/facebookresearch/DomainBed">facebookresearch/DomainBed</a>框架，到现在做了一个多月的实验，清明假期犯懒不想做正事，特回顾总结并记录这一个多月的实验问题以及解决方法</p><p>记录顺序以执行的<u>代码顺序</u>以及<u>时间顺序</u>记录</p><h1 id="first-stage">First Stage</h1><p>这一阶段主要任务是：<strong>使用<u>未经训练的CLIP预训练模型</u>提取一个数据集的<u>特征</u>，画出关于域的<u>t-SNE图</u>。</strong></p><p>师兄是在HuggingFace上翻的 <ahref="https://huggingface.co/docs/transformers/main/en/model_doc/clip#transformers.CLIPVisionModel">doc</a>给我看，指出用CLIP Vision Model / ViT等预训练视觉模型来做。</p><p>比较简单，半天完成，暂时没用到DomainBed，毕竟不需要各种算法。在网上下载了<ahref="https://arxiv.org/abs/1710.03077">PACS</a>数据集，上传到<ahref="https://www.autodl.com/">AutoDL</a>上。</p><h2 id="什么是clip">什么是CLIP？</h2><p>论文原文： <a href="https://arxiv.org/pdf/2103.00020">LearningTransferable Visual Models From Natural LanguageSupervision</a>（只看了摘要）</p><p>以看完摘要的理解来说就是：利用了<strong>4亿图文对</strong>训练，对比学习，取消了以前依赖label的监督方式，转而利用图片的文本描述，这样监督更broader。图文结合。</p><p>具有强大的泛化能力和零样本能力</p><blockquote><p><strong>啥是监督（supervise）？</strong></p><p>我也似懂非懂，大概就是<strong>用没用标签</strong>的意思。贴出Grok3的回答，括号内是我的浅显理解：</p><blockquote><p>在深度学习中，“监督”（supervise）是指在模型训练过程中是否使用了标注数据来指导学习。根据是否需要标注数据以及标注数据的多少，可以将学习方式分为以下几类：<strong>监督学习</strong>(明确标签)、<strong>自监督学习</strong>(一开始没标签，自己生成标签)、<strong>半监督学习</strong>(少部分有标签，大部分没标签)和<strong>无监督学习</strong>（完全没标签）。</p></blockquote><table><thead><tr><th style="text-align: center;">学习类型</th><th style="text-align: center;">是否需要标注数据</th><th style="text-align: center;">训练方式</th><th style="text-align: center;">典型应用</th></tr></thead><tbody><tr><td style="text-align: center;">supervised</td><td style="text-align: center;">全部</td><td style="text-align: center;">优化损失函数</td><td style="text-align: center;">分类、回归</td></tr><tr><td style="text-align: center;">self-supervised</td><td style="text-align: center;">否</td><td style="text-align: center;">数据生成伪标签，pretrain+tuning</td><td style="text-align: center;">特征学习、预训练模型</td></tr><tr><td style="text-align: center;">semi-supervised</td><td style="text-align: center;">少量</td><td style="text-align: center;">伪标签迭代</td><td style="text-align: center;">数据稀缺场景分类</td></tr><tr><td style="text-align: center;">unsupervised</td><td style="text-align: center;">否</td><td style="text-align: center;">发现数据结构，无明确输出目标</td><td style="text-align: center;">聚类、降维、生成</td></tr></tbody></table></blockquote><p>然后看了看下面的方法总览图和描述，意思感觉差不多，传统是先训练visionmodel来extract feature，然后投进linearclassifier里面分类。CLIP同时有图像和文本encoder。</p><p><del>看到两个encoder组合，突然想到了之前自己想的的水大创，也是图像结合文本信息，虽然草陋得多（雾）</del></p><h2 id="什么叫提取特征">什么叫提取特征</h2><p><strong>feature、representation</strong>，在论文中指<strong>“特征“、“表示”</strong></p><p>我目前的理解是：深度神经网络可以输入图像，输出图像的“特征”，也就是经过各种层、各种卷积计算之类的，最后输出一个多少维<span class="math inline">\(\times\)</span>多少维的向量，这个向量就是图像的feature或者representation。比如CLIP是768维向量，ResNet是2048维向量。</p><blockquote><p>可以通过查看输出的shape来看是否正确使用了CLIP或者ResNet</p><p>（shape就是输出的样子、格式之类的，调试时变量真正是什么样和应该是什么样）</p></blockquote><p>这两个词<strong>似乎</strong>混用了，DG领域的综述<ahref="https://arxiv.org/pdf/2103.03097">《Generalizing to UnseenDomains: A Survey on DomainGeneralization》</a>用的是<code>representation</code></p><p>这里的提取特征就是，准备好images，然后调整好输入方式，喂给CLIP预训练模型，得到一个特征或表示（768维向量）</p><h2 id="什么是t-sne图">什么是t-SNE图</h2><p>最开始接触到是在组会和各种论文里，有那种scatterplot(散点图)，各种颜色。</p><p>基本都是一个颜色表示一个域，然后看各个域的重合情况，重合越多表示域不变特征(domain-invariantfeature)越强，各个域共有的特征多，如果学到这个特征，就能通吃各个域，泛化能力强。</p><p><ahref="#second-summary">下文</a>有3张t-SNE图，一直以来都只是知道怎么看，以及怎么调库生成，以及知道是可视化相邻情况的。下面较详细地记录下数学原理和调库原理：</p><blockquote><p>来自<ahref="https://blog.csdn.net/sinat_20177327/article/details/80298645">t-SNE算法解析</a>和AI回答</p></blockquote><h3 id="t-sne">t-SNE</h3><p>t-distributed Stochastic NeighborEmbedding，t分布随机邻域嵌入，一种非线性降维技术，用于高维数据可视化。（好像是Hinton提出的😮）</p><p>核心就是降维，要可视化一般降到2或3维，降维之后，<strong>在高维里面相邻的，在低维也相邻</strong></p><h4 id="t-sne数学原理简述">t-SNE数学原理简述</h4><h5 id="高维空间的相似性建模">高维空间的相似性建模</h5><p>SNE使用条件概率来描述两个数据之间的相似性，假设<spanclass="math inline">\(x_i,x_j\)</span>是高维空间中的两个点，那么以点<spanclass="math inline">\(x_i\)</span>为中心构建方差为<spanclass="math inline">\(\sigma_i^2\)</span>的高斯分布，使用<spanclass="math inline">\(p_{j|i}\)</span>表示<spanclass="math inline">\(x_j\)</span>是<spanclass="math inline">\(x_i\)</span>邻域的概率，如果<spanclass="math inline">\(x_j\)</span>离<spanclass="math inline">\(x_i\)</span>很近，那么<spanclass="math inline">\(p_{j|i}\)</span>很大，反之，<spanclass="math inline">\(p_{j|i}\)</span>很小，<spanclass="math inline">\(p_{j|i}\)</span>定义如下： <spanclass="math display">\[p_{j|i}=\frac{\exp(-||x_i-x_j||^2/(2\sigma_i^2))}{\sum_{k\nei}{\exp(-||x_i-x_j||^2/(2\sigma_i^2))}}\]</span> 设定<spanclass="math inline">\(p_{i|i}=0\)</span>，因为只想要不同点的相似度。</p><p>对称化：将条件概率对称化，定义联合概率： <spanclass="math display">\[p_{ij}=\frac{p_{j|i}+p_{i|j}}{2n}\]</span> <span class="math inline">\(n\)</span>是数据点总数。</p><h5 id="低维空间的相似性建模">低维空间的相似性建模</h5><p>假设<span class="math inline">\(x_i,x_j\)</span>映射到低维变成了<spanclass="math inline">\(y_i,y_j\)</span>，每个<spanclass="math inline">\(y\)</span>是<spanclass="math inline">\(d\)</span>维向量(<spanclass="math inline">\(d=2、3\)</span>)</p><p><span class="math inline">\(y_j\)</span>是<spanclass="math inline">\(y_i\)</span>邻域的条件概率为： <spanclass="math display">\[q_{j|i}=\frac{(1+||y_i-y_j)||^2)^{-1}}{\sum_{k\ne l}{(1+||y_k-y_l)||^2)^{-1}}}\]</span></p><h5 id="目标函数">目标函数</h5><p>在高维空间中，如果考虑<spanclass="math inline">\(x_i\)</span>与其他所有点之间的条件概率，那么会构成一个条件概率分布<spanclass="math inline">\(P_i\)</span>，同样在地位空间也会有与之对应的条件概率分布 <spanclass="math inline">\(Q_i\)</span>，如果降维之后的数据分布与原始高维空间中的数据分布是一样的，那么理论上这两个条件概率分布式是一致的。那么如何衡量两个条件概率分布之间的差异呢？经典问题，使用K-L 散度（也叫做相对熵），于是，目标函数为： <spanclass="math display">\[C=\sum_{i}{KL(P_i||Q_i)}=\sum_{i\ne j}\log{\frac{p_{j|i}}{q_{j|i}}}\]</span> 通过梯度下降调整<spanclass="math inline">\(y_i\)</span>的位置，最小化<spanclass="math inline">\(C\)</span>。</p><h5 id="其他">其他</h5><p>更底层的就不写了，可以去问AI，这里写个大概：</p><p>得到梯度公式，初始的低维空间点随机生成，然后迭代更新<spanclass="math inline">\(y_i\)</span>。</p><p>困惑度perplexity控制高斯分布的<spanclass="math inline">\(\sigma_i\)</span>，影响邻域大小；t分布的长尾特性缓解了高维数据在低维空间的过度压缩。</p><p>在Python中一般使用<code>from sklearn.manifold import TSNE</code>导入库使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">tsne = TSNE(n_components=<span class="hljs-number">2</span>, perplexity=<span class="hljs-number">30</span>, n_iter=<span class="hljs-number">1000</span>, random_state=<span class="hljs-number">42</span>)<br>features_2d = tsne.fit_transform(features)<br></code></pre></td></tr></table></figure><h2 id="first-summary">first summary</h2><p>整体的代码流程是：</p><ul><li>load_data<ul><li>使用<code>from torchvision.datasets import ImageFolder</code>，设定好backbone需要的transform（图像大小尺寸等），得到<code>ImageFolder</code>对象</li><li>利用<code>from torch.utils.data import DataLoader</code>把<code>ImageFolder</code>对象变成<code>Dataloader</code>对象</li></ul></li><li>load_model<ul><li>利用<code>from transformers import CLIPProcessor, CLIPModel</code>+<code>from_pretrained</code>方法直接从huggingface下载预训练模型<code>openai/clip-vit-base-patch32</code></li></ul></li><li>extract_feature<ul><li>在torch.no_grad()条件下（任务不需要梯度下降，所以关闭梯度下降，简化计算流程），遍历loader中的images，调各种库函数提取特征，拼接在一起，最后返回。按照HuggingFace的doc上来说，应该得到CLIP的<code>pooler_output</code>这个输出。</li></ul></li><li>plot_tsne<ul><li>调库，特征降维，得到二维特征，用matplotlib画图</li></ul></li></ul><h1 id="second-stage">second stage</h1><p><strong>找个<u>图像域泛化方法</u>，用CLIP当<u>backbone</u>，训练前后都用backbone把数据<u>encode</u>成feature，画出t-SNE。</strong></p><blockquote><p>用意是：</p><p>看相关的图像域泛化方法的t-SNE是否有分开的现象。因为最初的研究动机是，一些文本的域泛化方法使用后反而使域不变特征减少了，也就是t-SNE的各个颜色点变得各自分离团簇而不互相交杂</p></blockquote><p>这一步就开始用到DomainBed了，不过只需要简单使用，训练出一两个模型。</p><h2 id="什么是backbone">什么是backbone？</h2><p>以前用YOLO的时候看到过这个概念，记得YOLO是head、neck、backbone的结构，但不知道是做什么的。</p><p>目前的理解是：<strong>backbone是用来提取特征的</strong>，我们常说的各种网络（CLIP、ResNet、VGG、AlexNet、LeNet……）一般都用来当做backbone。</p><p>输入的是图片(以及其他raw数据)，输出的是特征，也就是用来提取特征的(<ahref="#什么叫提取特征">见上文：什么叫提取特征</a>)。</p><p>由于对各种权威专著毫无了解，所以贴AI的回答：</p><blockquote><p>在深度学习中，backbone通常指模型中<strong>用于提取输入特征的核心网络结构</strong>。比如在图像任务中，ResNet、VGG、MobileNet 等 CNN 架构常用作图像的backbone；</p><p>而在自然语言处理任务中，Transformer、BERT、RoBERTa 等模型常作为文本的backbone。</p><p>Backbone的主要职责是将原始输入转化为高维、抽象的特征表示，便于后续的分类器或其他模块进行处理。</p><p>通常在领域泛化、迁移学习等任务中，也会关注 backbone的特征表达能力以及是否固定其参数。</p></blockquote><p>再简略写一句关于head、neck的解释：</p><ul><li><p>Backbone：主干网络，从原始输入中提取高级通用特征；</p></li><li><p>Neck：连接Backbone和Head，再目标检测任务中很重要，用于融合不同尺度的特征或者 加强/重组backbone提取的特征，常见结构有FPN、BiFPN、PAN；</p></li><li><p>Head：输出头，根据任务需求输出结果，比如分类、检测、分割</p></li></ul><h2 id="backbone还能训练什么意思">backbone还能训练？什么意思？</h2><p>训练，也可以叫迭代优化，一般“训练模型”说人话就是一遍遍试错，然后调整各种可学习的“参数权重”，来让表现更好。</p><p>backbone是可以训练的，也可以选择“<strong>冻结</strong>”，也就是不训练backbone或者训练backbone的一部分。</p><p>那么backbone有什么“参数权重”需要训练来调整呢？</p><p>很多，backbone平时视作黑盒，但内部复杂，以ResNet为例，可学习的有每一层卷积核的权重、每个BatchNorm的缩放系数、残差连接的参数……</p><h2 id="方法和模型的关系">方法和模型的关系</h2><p>这个问题比较长，不好放在标题，在下面写：</p><blockquote><p>假设，有一篇论文，提出了个方法，叫MetHod（吐槽：经典的，以奇怪的大小写方式、强行拼凑出的一个单词当方法名字），有效提高了关于图像的域泛化能力。</p><p>现在我要训练一个以CLIP为backbone的、使用MetHod方法的模型，那CLIP和MetHod的关系是什么？</p></blockquote><table><thead><tr><th style="text-align: center;">概念</th><th style="text-align: center;">类型</th><th style="text-align: center;">作用</th><th style="text-align: center;">层级</th></tr></thead><tbody><tr><td style="text-align: center;">CLIP</td><td style="text-align: center;">模型结构(Backbone)</td><td style="text-align: center;">提取特征</td><td style="text-align: center;">属于内部网络的<strong>模块</strong></td></tr><tr><td style="text-align: center;">MetHod</td><td style="text-align: center;">训练/优化算法</td><tdstyle="text-align: center;">最小化训练集上的平均损失，引导模型学习</td><td style="text-align: center;">属于<strong>训练策略</strong></td></tr></tbody></table><p>流程是：</p><ul><li>输入图像：ImageFolder -&gt; DataLoader -&gt; 喂给 CLIP</li><li>CLIP输出特征：[feature] 喂给分类器classifier</li><li>输出分类概率：[dog：80%, chair：10%,……]，计算loss（例如交叉熵或者MetHod规定的loss计算方式）</li><li>使用MetHod：<strong>最小化训练集上所有样本的平均loss</strong></li><li>反向传播更新CLIP和分类器的参数</li></ul><p>所以，MetHod算作是损失函数+优化策略+训练目标的总称。</p><p>关系是：</p><p>MetHod和backbone相互影响，是<strong>两个不同的但相互影响的模块</strong>。</p><p>训练结束后得到权重，利用这个权重new一个model出来，这就得到模型。</p><h2 id="使用domainbed时遇到的问题">使用DomainBed时遇到的问题</h2><h3id="开头一堆parseradd_argument是什么">开头一堆parser,add_argument是什么？</h3><p>一种实现命令行选项的方式，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> argparse <span class="hljs-comment"># 导库</span><br>parser = argparse.ArgumentParser() <span class="hljs-comment"># 对象</span><br>parser.add_argument(<span class="hljs-string">&#x27;--hparams&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;你的注释&#x27;</span>) <span class="hljs-comment"># 加参数</span><br><span class="hljs-comment"># ...一大堆其他的参数设置</span><br><br>args = parser.parse_args() <span class="hljs-comment"># 等输入，并解析</span><br><span class="hljs-comment"># 命令行使用python -m train.py --hparams &#x27;&#123;&quot;backbone&quot;: &quot;clip&quot;&#125;&#x27;</span><br><span class="hljs-comment"># args里面就会有hparams : &#x27;&#123;&quot;backbone&quot;: &quot;clip&quot;&#125;&#x27;这个哈希表项</span><br></code></pre></td></tr></table></figure><p>然后就更能理解DomainBed的README中的用法：</p><p>python -m domainbed.scripts.train 跟一堆参数，就能一键开始训练。</p><h3 id="怎么换backbone">怎么换backbone</h3><p>domainbed包里主要的文件有：</p><ul><li><code>lib.fast_data_loader.py</code>：定义了<code>FastDataLoader</code>和<code>InfiniteDataLoader</code>，在<code>train.py</code>中用到</li><li><code>lib.misc.py</code>：<strong>Misc</strong>ellaneous，杂项的意思，目前主要关注到<code>accuracy</code>方法，是checkpoint计算预测准确率(correct/ total)的（因为这个方法比较慢，数据集大了就是瓶颈之一）</li><li><code>scripts.train.py</code>：<strong>主要的训练流程代码</strong>，解析参数、设置hp、分割数据集、加载数据、迭代、保存模型</li><li><code>scripts.download.py</code>：<strong>下载数据集用的</strong>。在最后的<code>if __name__ == "__main__"</code>下保留要下载的数据集的方法，执行带上data_dir参数</li><li><code>algorithms.py</code>：记录了DomainBed支持的所有算法的类(继承<code>torch.nn.Module</code>)，也就是<strong>各种算法的实现</strong>。有一个总的抽象父类供所有类实现，有<code>update</code>和<code>predict</code>两个方法</li><li><code>datasets.py</code>：记录了DomainBed支持的<strong>各种数据集</strong>的域、设置了checkpoint的频率，以及子文件夹的拼接路径</li><li><code>hparams_registry.py</code>：记录了对各种算法、数据集的默认<strong>超参数</strong>设置(batchsize、lr等)</li><li><code>networks.py</code>：<strong>实现了各种网络</strong>，ResNet、DinoV2、MNIST_CNN等</li></ul><p>显然，我需要在<code>networks.py</code>中实现CLIP，然后打包成跟ResNet差不多的样子，最后找到分配backbone的“工厂”部分，加上CLIP的选项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 分配backbone的“工厂”:</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Featurizer</span>(<span class="hljs-params">input_shape, hparams</span>):<br>    <span class="hljs-keyword">if</span> hparams.get(<span class="hljs-string">&quot;backbone&quot;</span>, <span class="hljs-string">&quot;resnet50&quot;</span>) == <span class="hljs-string">&quot;clip&quot;</span>: <span class="hljs-comment"># 添加CLIP模型</span><br>        <span class="hljs-keyword">return</span> CLIPBackbone(input_shape, hparams)<br>    <span class="hljs-keyword">elif</span> hparams[<span class="hljs-string">&quot;vit&quot;</span>]:<br>        <span class="hljs-keyword">if</span> hparams[<span class="hljs-string">&quot;dinov2&quot;</span>]:<br>            <span class="hljs-keyword">return</span> DinoV2(input_shape, hparams)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> NotImplementedError<br>    <span class="hljs-keyword">return</span> ResNet(input_shape, hparams)  <span class="hljs-comment"># 默认 ResNet</span><br></code></pre></td></tr></table></figure><h3id="训练完怎么利用得到的model.pkl">训练完怎么利用得到的model.pkl？</h3><p>首先看到train.py是怎么保存的： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 保存模型的方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_checkpoint</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-keyword">if</span> args.skip_model_save:<br>        <span class="hljs-keyword">return</span><br>    save_dict = &#123;<br>        <span class="hljs-string">&quot;args&quot;</span>: <span class="hljs-built_in">vars</span>(args),<br>        <span class="hljs-string">&quot;model_input_shape&quot;</span>: dataset.input_shape,<br>        <span class="hljs-string">&quot;model_num_classes&quot;</span>: dataset.num_classes,<br>        <span class="hljs-string">&quot;model_num_domains&quot;</span>: <span class="hljs-built_in">len</span>(dataset) - <span class="hljs-built_in">len</span>(args.test_envs),<br>        <span class="hljs-string">&quot;model_hparams&quot;</span>: hparams,<br>        <span class="hljs-string">&quot;model_dict&quot;</span>: algorithm.state_dict()<br>    &#125;<br>    torch.save(save_dict, os.path.join(args.output_dir, filename))<br></code></pre></td></tr></table></figure></p><p>save_checkpoint在最后被调用，保存为了model.pkl，主要关注方法中的kv关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># model.pkl中的哈希关系</span><br><span class="hljs-string">&quot;args&quot;</span>: <span class="hljs-built_in">vars</span>(args),<br><span class="hljs-string">&quot;model_input_shape&quot;</span>: dataset.input_shape,<br><span class="hljs-string">&quot;model_num_classes&quot;</span>: dataset.num_classes,<br><span class="hljs-string">&quot;model_num_domains&quot;</span>: <span class="hljs-built_in">len</span>(dataset) - <span class="hljs-built_in">len</span>(args.test_envs),<br><span class="hljs-string">&quot;model_hparams&quot;</span>: hparams,<br><span class="hljs-string">&quot;model_dict&quot;</span>: algorithm.state_dict()<br></code></pre></td></tr></table></figure><p>这说明model.pkl就是个哈希表，而不是exe那种执行一下、喂数据、出结果的黑盒，需要用这些数据重新构建出model。</p><p>所以看看<code>algorithms.py</code>是怎么定义各种模型的类的，以便复原出模型，这里以ERM举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># ERM的部分实现代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ERM</span>(<span class="hljs-title class_ inherited__">Algorithm</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Empirical Risk Minimization (ERM)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_shape, num_classes, num_domains, hparams</span>):<br>        <span class="hljs-built_in">super</span>(ERM, self).__init__(input_shape, num_classes, num_domains, hparams)<br>        self.featurizer = networks.Featurizer(input_shape, self.hparams)<br>        self.classifier = networks.Classifier(<br>            self.featurizer.n_outputs,<br>            num_classes,<br>            self.hparams[<span class="hljs-string">&#x27;nonlinear_classifier&#x27;</span>])<br><br>        self.network = nn.Sequential(self.featurizer, self.classifier)<br>        self.optimizer = torch.optim.Adam(<br>            self.network.parameters(),<br>            lr=self.hparams[<span class="hljs-string">&quot;lr&quot;</span>],<br>            weight_decay=self.hparams[<span class="hljs-string">&#x27;weight_decay&#x27;</span>]<br>        )<br><span class="hljs-comment"># ...others...</span><br></code></pre></td></tr></table></figure><p>可以看到<code>__init__</code>方法需要<code>input_shape, num_classes, num_domains, hparams</code>四个参数，正好是<code>model.pkl</code>里面保存的，所以读取出来传进去就行了。</p><p>注意调用栈里面会用到的自己写的CLIP类，也要保持与原有的ResNet、DinoV2相同的输入结构，才好复用。</p><p>现在只需要把之前用纯CLIP画图的代码中的<code>load_model</code>方法里用from_pretrained下载的模型改成使用<code>model.pkl</code>重新构建的model 即可。</p><h2 id="second-summary">second summary</h2><p>这部分也比较简单，主要难点在看懂DomainBed的结构</p><blockquote><p>其实现在都没完全看懂 (lll￢ω￢)</p></blockquote><p>最后的结果是，<del>太理想了！t-SNE里的各域变得团簇了！</del>，结果很令人迷惑，感觉前后都差不多，纯CLIP的比较团簇，使用方法后反而混合错杂了一点😵‍💫</p><blockquote><p>回顾下这一阶段的目的：</p><p>看相关的图像域泛化方法的t-SNE是否有分开的现象。因为最初的研究动机是，一些文本的域泛化方法使用后反而使域不变特征减少了，也就是t-SNE变得团簇而不错杂</p></blockquote><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://s3.bmp.ovh/imgs/2025/04/05/7801450e88c302eb.png"alt="纯CLIP" /></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://s3.bmp.ovh/imgs/2025/04/05/ec0eb9f3d879f611.png"alt="ERM" /></div><div class="group-image-wrap"><img src="https://s3.bmp.ovh/imgs/2025/04/05/8520d365dbdd7064.png"alt="SagNet" /></div></div></div><h1 id="third-stage">third stage</h1><p>这一阶段开始使用咱们（<del>全是师兄提出的，但不妨碍，我们两个真是太厉害了😋☝️</del>）提出的特征对齐方法了：</p><p>利用的特征对齐方法：</p><p><strong>计算源域和目标域的平均向量，求differ=源域平均向量-目标域平均向量，在分类前给样本特征加上differ，再投入分类器分类</strong></p><p>实验目标：</p><ul><li><strong>不用该方法获得的准确率/F1分数</strong></li><li><strong>使用该方法获得的准确率/F1分数</strong></li><li><strong>CLIP参数固定与不固定</strong></li><li><strong>每个方法跑3次求平均</strong></li></ul><p>用伪代码描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> [<span class="hljs-literal">None</span>, differ]: <span class="hljs-comment"># 是否用differ</span><br><span class="hljs-keyword">for</span> clip <span class="hljs-keyword">in</span> [freeze, unfreeze]: <span class="hljs-comment"># 是否固定CLIP</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>): <span class="hljs-comment"># 不同随机种子重复实验3次</span><br>seed = random<br>train(d, clip, seed)<br></code></pre></td></tr></table></figure><p>首先要训练3n个模型，然后改一下测准确率的方法，向里面加入使用特征对齐的分类方式。在训练后算出differ并保存。</p><h2 id="写代码过程中的问题">写代码过程中的问题</h2><h3id="训练结束后如何调用方法计算平均向量并保存">训练结束后如何调用方法计算平均向量并保存？</h3><p>首先要拼接（<code>torch.utils.data.ConcatDataset</code>）所有源域数据，才能计算源域的平均向量。</p><p>这里没有使用ImageFolder-&gt;DataLoader的常规load方法，而是使用了DomainBed自己的<code>FastDataLoader</code>，用的时候几乎都是ChatGPT写代码，没怎么看<code>FastDataLoader</code>是如何工作和使用的，下面简要记录：</p><p><code>FastDataLoader</code>类(在我修改后)支持DDP(DistributedDataParallel，分布式数据并行，见<ahref="#多卡训练的基础概念和常用库">下文</a>)，传入dataset、batch_size、num_workers、device参数，</p><p>成员<code>loader</code>是<code>DataLoader</code>对象，使用传入的参数定义，另有<code>__iter__</code>方法和<code>__len__</code>方法，分别提供迭代和长度。</p><blockquote><p>看起来似乎就是对DataLoader的简单封装，大概是为了统一实验设置，毕竟DomainBed为的是提供标准统一实验框架</p></blockquote><hr /><p>说完Loader。计算平均向量的代码是师兄提供的，输入backbone、loader、device即可。</p><p>得到平均向量后简单相减，然后<code>torch.save</code>保存为pt文件。</p><h3 id="如何利用differ">如何利用differ？</h3><p>differ要在投入分类器前加到样本的特征上，所以流程应该是：</p><blockquote><p>加载测试数据和模型-&gt;遍历样本-&gt;模型backbone提取样本的特征-&gt;<strong>加上或不加上differ</strong>-&gt;喂给分类器-&gt;统计得到准确率和F1</p></blockquote><p>如<ahref="#怎么换backbone">上文</a>所说，<code>lib.misc.py</code>中有一个测分类准确率的方法，似乎只需要略加修改即可。</p><p>但是我当时并没有意识到，于是自己写了一个evaluate方法😞，包含load_data、extract_features等操作。</p><p>总之，核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python">features = model.featurizer(images) <span class="hljs-comment"># 提取样本特征</span><br><span class="hljs-comment"># 如果传入了differ，就加上</span><br><span class="hljs-keyword">if</span> differ <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> differ.shape == features.shape[<span class="hljs-number">1</span>:]: <br><span class="hljs-comment"># 喂给分类器</span><br>logits = model.classifier(features)<br><span class="hljs-comment"># 取最可能的一个预测值</span><br>predictions = torch.argmax(logits, dim=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># ...correct/total...</span><br></code></pre></td></tr></table></figure><h3id="如何在domainbed中提取特征stupid版问题">如何在DomainBed中提取特征（stupid版问题）</h3><p>问出这个问题是因为，我自己写evaluate时，不知道怎么调出模型的backbone，不知道该怎么把image喂给backbone。</p><p>如<ahref="#怎么换backbone">上文</a>所说，DomainBed中的各种算法类都是实现了一个抽象父类，需要实现<code>update</code>和<code>predict</code>两个方法。</p><p>而下面的各种方法，用来表示backbone和分类器的成员名称都不太一样，导致了不能直接<code>network(image)</code>表示backbone、<code>model(feature)</code>表示分类。</p><p>例如，ERM的是featurizer、classifier，SagNet的是network_f、network_c，于是有了下面的<code>if-else</code>🤡：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(algorithm, <span class="hljs-string">&quot;featurizer&quot;</span>):<br>    feature_extractor = algorithm.featurizer<br><span class="hljs-keyword">elif</span> <span class="hljs-built_in">hasattr</span>(algorithm, <span class="hljs-string">&quot;network_f&quot;</span>):<br>    feature_extractor = algorithm.network_f<br><span class="hljs-keyword">elif</span> <span class="hljs-built_in">hasattr</span>(algorithm, <span class="hljs-string">&quot;network&quot;</span>):<br>    feature_extractor = algorithm.network<br><span class="hljs-keyword">elif</span> <span class="hljs-built_in">hasattr</span>(algorithm, <span class="hljs-string">&quot;predict&quot;</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">feature_extractor</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> algorithm.predict(x)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;args.algorithm&#125;</span> does not support feature extraction!&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="如何固定clip参数">如何固定CLIP参数</h3><p>这里的“固定CLIP参数”就是冻结backbone的意思（见<ahref="#backbone还能训练？什么意思？">上文</a>）</p><p>在初始化CLIP时加上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">if</span> hparams.get(<span class="hljs-string">&quot;freeze_clip&quot;</span>, <span class="hljs-literal">False</span>):  <span class="hljs-comment"># 是否冻结 CLIP</span><br>    <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> self.network.parameters():<br>        param.requires_grad = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>取消CLIP中所有参数的requires_grad就好。</p><h3 id="如何一键训练多个模型">如何一键训练多个模型</h3><p>这一阶段需要训练多个模型，如<ahref="#开头一堆parser,add_argument是什么？">上文</a>所说，每次训练需要用<code>python -m domainbed.scripts.train --hparapms '...' --dataset "..." --algorithm "..." --output_dir "/..." --test_envs "..."</code>这一长串命令来启动，对于目前这种需要训练多个模型的场景：</p><ul><li>模型在服务器上训练，时间就是金钱，最好自动无缝衔接训练</li><li>命令这么长，手滑敲错了很难发现，还浪费了时间</li></ul><p>很不友好</p><p>这时候就要掏出<ahref="https://missing-semester-cn.github.io/">计算机教育中缺失的一课</a>（虽然我只看了一点点）中的shell🤓。需要强调的是，这并不是AI出的主意，而是从我的辣鸡大脑中蹦出来的<del>（自豪）</del></p><p>回想之前的<ahref="#third%20stage">伪代码</a>，这就是良好的草稿，稍作修改，将其中的<code>train</code>改为这一长串命令带参数就好了。简单<del>不知天高地厚地</del>贴个示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>DATASETS=(&quot;PACS&quot;) <br>ALGORITHMS=(&quot;ERMPlusPlus&quot; &quot;SagNet&quot; &quot;ERM&quot;)<br>SEEDS=(17 373 3403)<br>TEST_ENVS=(0)<br>OUTPUT_BASE=&quot;/root/autodl-tmp/results&quot;<br>HPARAMS=(&#x27;&#123;&quot;backbone&quot;: &quot;clip&quot;, &quot;freeze_clip&quot;: true&#125;&#x27;)<br><br>for DATASET in &quot;$&#123;DATASETS[@]&#125;&quot;; do<br>    for TEST_ENV in &quot;$&#123;TEST_ENVS[@]&#125;&quot;; do<br>        for ALGORITHM in &quot;$&#123;ALGORITHMS[@]&#125;&quot;; do<br>            COUNT_NOFREEZE=1  # 计数器（不冻结 CLIP）<br>            COUNT_FREEZE=1     # 计数器（冻结 CLIP）<br><br>            for SEED in &quot;$&#123;SEEDS[@]&#125;&quot;; do<br>                for HPARAM in &quot;$&#123;HPARAMS[@]&#125;&quot;; do<br>                    # 判断是否 freeze CLIP<br>                    if [[ &quot;$HPARAM&quot; == *&quot;freeze_clip\&quot;: true&quot;* ]]; then<br>                        FREEZE_STATUS=&quot;freeze&quot;<br>                        OUTPUT_DIR=&quot;$&#123;OUTPUT_BASE&#125;/$&#123;TEST_ENV&#125;/$&#123;ALGORITHM&#125;_$&#123;FREEZE_STATUS&#125;_$&#123;COUNT_FREEZE&#125;&quot;<br># 检查文件夹是否已存在且包含训练好的 model.pkl<br>                        if [ -f &quot;$&#123;OUTPUT_DIR&#125;/model.pkl&quot; ]; then<br>                            echo &quot;已存在: $&#123;OUTPUT_DIR&#125;/model.pkl，跳过训练。&quot;<br>                            ((COUNT_FREEZE++))<br>                            continue<br>                        fi<br>                        ((COUNT_FREEZE++))<br>                    else<br>                        OUTPUT_DIR=&quot;$&#123;OUTPUT_BASE&#125;/$&#123;TEST_ENV&#125;/$&#123;ALGORITHM&#125;_$&#123;COUNT_NOFREEZE&#125;&quot;<br>                        # 检查文件夹是否已存在且包含训练好的 model.pkl<br>                        if [ -f &quot;$&#123;OUTPUT_DIR&#125;/model.pkl&quot; ]; then<br>                            echo &quot;已存在: $&#123;OUTPUT_DIR&#125;/model.pkl，跳过训练。&quot;<br>                            ((COUNT_NOFREEZE++))<br>                            continue<br>                        fi<br><br>                        ((COUNT_NOFREEZE++))<br>                    fi<br>                    mkdir -p &quot;$&#123;OUTPUT_DIR&#125;&quot;<br>                    python -m domainbed.scripts.train \<br>                        --dataset &quot;$&#123;DATASET&#125;&quot; \<br>                        --algorithm &quot;$&#123;ALGORITHM&#125;&quot; \<br>                        --data_dir &quot;/root/autodl-tmp/data/$&#123;DATASET&#125;&quot; \<br>                        --hparams &quot;$&#123;HPARAM&#125;&quot; \<br>                        --output_dir &quot;$&#123;OUTPUT_DIR&#125;&quot; \<br>                        --test_envs &quot;$&#123;TEST_ENV&#125;&quot; \<br>                        --seed &quot;$&#123;SEED&#125;&quot;<br>                done<br>            done<br>        done<br>    done<br>done<br><span class="hljs-meta prompt_"># </span><span class="language-bash">训练结束，自动关机省钱</span><br>/usr/bin/shutdown<br></code></pre></td></tr></table></figure><p>只需修改数据集名称，打开screen守护进程，<code>./run.sh</code>一键运行，然后关闭ssh连接放手不管😋☝️</p><h1 id="fourth-stage">fourth stage</h1><p>这一阶段的任务是扩大实验，包括：</p><ul><li>多实验几个数据集</li><li>换用更新的方法（24年及以后）</li><li>用resnet当backbone实验</li><li>用t-SNE可视化特征对齐之后的域差异<ul><li>Backbone不做训练，encode得到的分布</li><li>Backbone在某个/些域上训练，w/ w/o differ，encode得到的分布</li></ul></li><li>用MMD衡量特征对齐后的域差异</li><li>设计实验展示该方法的低成本且无参特性</li></ul><p>目前就卡在这一阶段，自我批评一番：</p><ul><li><p>代码能力较弱（没总结整体思路，写简单的可视化代码与实现多卡训练花了半个月）</p></li><li><p>实验策略不合理（选用了过大的数据集DomainNet，白干一周）</p></li><li><p>代码有bug（导致训练缓慢，浪费钱和时间不说，结果还是错的）</p></li><li><p>shell使用不熟练（本想用脚本无缝衔接，结果写错了没检查，得不偿失）</p></li><li><p>实验结果组织不合理（刚开始自动生成latex表格代码，结果布局不好，又花时间手动复制到excel，excel的布局又不合理，又手动修改……花了很多时间）</p></li><li><p>懒（遇到困难常常退缩拖延，总结也拖，整体思路混乱，没有自己的思考和记录）</p></li></ul><p>下面记录这一阶段的问题：</p><h2 id="如何实现多卡训练">如何实现多卡训练</h2><p>动机是：无知地选了个超大的数据集DomainNet，60w图片，之前用的PACS、VLCS、OfficeHome最多的才1w图片。</p><p>由于太大，以DomainBed的默认超参数，batch_size=16，在4090D上都会OOM，减小到4才成功运行，但extremelyslow，一个小时计算刚开始的accuracy都没算出来，把checkpoint全ban掉，测出来一分半计算一个样本，好像一共有几十万个样本待测……，总之非常的慢，想到试试多卡，也许可行。</p><blockquote><p>不动脑子的后果，一张卡慢成这样，难道8张卡就能快了？照样费钱，拿不下来，就不该尝试这个数据集</p></blockquote><p>首先搜索了以前听说的DataParallel，全程问AI+搜博客写代码。</p><h3 id="多卡训练的基础概念和常用库">多卡训练的基础概念和常用库</h3><h4 id="基本概念">基本概念</h4><p>多卡训练应该叫数据并行（DataParallelism）。核心思想是将训练数据分成多个子集，分配到多个计算设备（如GPU）上并行处理，从而减少单次迭代的时间。</p><p>一般的流程是：</p><ul><li>分割batch（解决batch size过大导致的OOM）为多个sub-batch</li><li>每个GPU对自己的sub-batch前向计算反向传播来更新参数</li><li>将所有GPU的梯度汇总（求和或者平均），在主进程上更新全局参数</li><li>再将更新后的参数广播到所有GPU上</li></ul><p>好处是batch可以更大，坏处是要通信，可能成为瓶颈；实现复杂</p><h4 id="pytorch的实现">Pytorch的实现</h4><p>pytorch对于多卡训练有两个库能用，<code>DataParallel</code>和<code>DistributedDataParallel</code>，官方文档：<ahref="https://pytorch.org/docs/stable/generated/torch.nn.DataParallel.html">DataParallel— PyTorch 2.6 documentation</a>、<ahref="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel">DistributedDataParallel— PyTorch 2.6 documentation</a>。</p><blockquote><p>官方强烈建议不使用<code>DataParallel</code>，而使用<code>DistributedDataParallel</code>。理由是：DDP给每个GPU建一个<strong>进程（multiprocessing）</strong>，而DP用的是<strong>多线程（multithreading）</strong>。</p><p>多线程避免了Python解释器的全局解释器锁GIL带来的性能开销GIL在同一时刻只允许一个线程访问CPU，执行字节码，而多进程就可以同时执行多个Python解释器。</p></blockquote><h5 id="dataparallel">DataParallel</h5><p>适用于单机多卡训练，使用简单，把代码里表示模型的变量用DP包装一下就好。</p><p>原理：</p><p>DP有一个<strong>主GPU</strong>，上面维护了一个主模型副本，复制到其他GPU上。每次迭代，主GPU将batch分割，分发到各个GPU，各GPU算完<strong>汇总梯度到主GPU</strong>，主GPU更新模型参数，再<strong>广播</strong>。</p><blockquote><p>相当于计网的<strong>星状拓扑</strong>吧</p></blockquote><h5 id="distribueddataparallel">DistribuedDataParallel</h5><p>单机多卡和多机多卡都适用。</p><p>原理：</p><p>每个GPU都有一个<strong>进程</strong>，<strong>独立</strong>拥有完整的模型副本，通过<code>DistributedSampler</code>，每个进程从数据集中获取不同的子集，<strong>不需要主GPU分发</strong>。每个GPU各自算完，所有GPU直接交换梯度保持同步，并独立更新参数。<strong>没有主GPU</strong>，通信使用NCCL分布式集体通信</p><blockquote><p>这相当于<strong>环状拓扑</strong></p></blockquote><h4 id="我的实现过程">我的实现过程</h4><h5 id="dataparallel尝试过程">DataParallel尝试过程</h5><p>DataParallel比较简单，<code>algorithm=DataParallel(algorithm)</code>就够了，注意在调用原有<code>algorithm</code>的方法时，不能直接调，要用<code>algorithm.module</code>调用。</p><p>当然，这没成功，改为DataParallel后，训练时使用<code>nvidia-smi</code>查看显卡状态，一共2张卡，只有在load_data完成后的极短时间内，两个GPU的使用率都达到了80%+，且状态都是P2。其他时候都是cuda0打满，另一个0%利用率。</p><p>查了问题，虽然最后还是没成功，换用了DDP，但是大概率问题在于模型的实现上，如<ahref="#怎么换backbone">上文</a>所说，<code>algorithms.py</code>中的抽象父类只有有<code>update</code>和<code>predict</code>两个方法，<strong>DomainBed没有显式定义<code>forward</code>方法</strong>（<code>Module</code>抽象基类不强制实现<code>forward</code>），而DataParallel在前向计算时只会自动调用模型的<code>forward</code>方法。</p><p>这就出问题了，模型里面就network有forward，用<code>model()</code>没定义<code>__call__</code>，压根就调不到forward。那么我自己加一个forward不就好了？于是我加了一个，不知道要写什么，所以直接调CLIP的forward，报错没了，但是GPU使用情况还是单卡背负所有，只是第二张卡上出现了一个Python进程，调试打印信息也显示数据全给了cuda0。</p><p>最后还是没解决，然后我气急败坏地改用DDP了</p><h5id="distributeddataparallel实现过程">DistributedDataParallel实现过程</h5><p>如前文，DDP是多进程，且有一个<code>DistributedSampler</code>，所以实现大致分为两部分：实现多进程，添加分布采样器。</p><h6 id="多进程">多进程</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">init_distributed</span>(): <span class="hljs-comment"># 初始化进程组</span><br>    dist.init_process_group(backend=<span class="hljs-string">&#x27;nccl&#x27;</span>)<br>    torch.cuda.set_device(<span class="hljs-built_in">int</span>(os.environ[<span class="hljs-string">&quot;LOCAL_RANK&quot;</span>]))  <span class="hljs-comment"># 设置当前 GPU</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cleanup</span>(): <span class="hljs-comment"># 释放进程组</span><br>    dist.destroy_process_group()<br></code></pre></td></tr></table></figure><h6 id="distributedsampler">DistributedSampler</h6><p>Sampler实际是<code>DataLoader</code>的一个参数，之前一直缺省，现在需要用到。</p><p><code>DistributedSampler</code> 需要在每次 <code>epoch</code> 前调用<code>.set_epoch()</code> 来重置索引，否则容易出现<code>StopIteration</code> 错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 提前过滤出符合 args.test_envs 和 args.src_envs 条件的 in_splits 列表，并保留索引 i。</span><br>filtered_in_splits = [(i, env, env_weights) <span class="hljs-keyword">for</span> i, (env, env_weights) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(in_splits)<br>                          <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> args.test_envs <span class="hljs-keyword">and</span> i <span class="hljs-keyword">in</span> args.src_envs]<br><span class="hljs-keyword">if</span> num_gpus &gt; <span class="hljs-number">1</span>: <span class="hljs-comment"># 多卡时使用 DistributedSampler</span><br>    train_samplers = [<br>        DistributedSampler(env, num_replicas=num_gpus, rank=<span class="hljs-built_in">int</span>(os.environ[<span class="hljs-string">&quot;LOCAL_RANK&quot;</span>]), shuffle=<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">for</span> i, env, env_weights <span class="hljs-keyword">in</span> filtered_in_splits<br>    ]<br><span class="hljs-keyword">else</span>:<br>    train_samplers = [<span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> filtered_in_splits]  <span class="hljs-comment"># 单卡，不使用 DistributedSampler</span><br><br>train_loaders = [<br>    InfiniteDataLoader(<br>        dataset=env,<br>        weights=env_weights,<br>        batch_size=hparams[<span class="hljs-string">&#x27;batch_size&#x27;</span>],<br>        num_workers=dataset.N_WORKERS,<br>        sampler=train_samplers[j] <span class="hljs-comment"># loader中传入参数，指定sampler</span><br>    )<br>    <span class="hljs-keyword">for</span> j, (i, env, env_weights) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(filtered_in_splits)<br>]<br></code></pre></td></tr></table></figure><p>再记得每个epoch或step重置采样器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">if</span> num_gpus &gt; <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">for</span> sampler <span class="hljs-keyword">in</span> train_samplers:<br>        sampler.set_epoch(step)<br></code></pre></td></tr></table></figure><p>最后，在<code>fast_data_loader.py</code>中加上适配DDP的一些<code>if-else</code>小逻辑即可，主要是指定sampler的部分。</p><p>到这里就成功了，训练时多个GPU都是100%用到，DomainNet数据即使开16的batchsize也不会OOM了。</p><blockquote><p>不过，还是非常慢，在程序各处都添加了print，打印各段的耗时，并与之前的小数据集对比，发现就是单纯地数据集太大，单轮迭代的耗时差不多，甚至DomainNet更短一点点，但DomainNet太大，已经是PACS、VLCS等小数据集的60倍以上，难以使用。主要是没那么多卡和钱给我烧，测小数据集就行了。</p><p>在多卡上取消所有checkpoint训练DomainNet，每step也需要较长时间，最终放弃。</p></blockquote><h2id="针对多服务器如何提高evaluate和可视化代码的可移植性">针对多服务器，如何提高evaluate和可视化代码的可移植性</h2><p>提出这个问题主要是因为实验使用AutoDL进行，每个实例的内存有限，所以我每个服务器只能装一两个数据集，因为每个数据集上需要训练出三十多个模型，都要保存，每个模型大概800M，两个数据集差不多打爆AutoDL的60G数据盘了。</p><p>面对这种场景，一份能够尽可能少改动甚至不改动就能直接在<strong>各个服务器的数据集</strong>上直接评估数据集<strong>各个域</strong>下<strong>各个方法</strong>的<strong>各个模型</strong>的准确率和可视化域差异的代码显得很有必要。（4重循环变量）</p><p><strong>可移植性</strong>指软件能够在不同的环境（如操作系统、硬件、文件系统）中运行，而无需或只需最小的修改。强调代码在不同环境下的适应能力，通常通过抽象环境依赖（如路径、配置）来实现。</p><p>所以主要从路径上下手，也就是各种路径读取解析，然后拼接</p><p>本质是复杂的字符串操作和文件结构命名规范。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ERM++: AnImproved Baseline for Domain Generalization 阅读笔记</title>
    <link href="/2025/03/05/25-3-5%E8%AF%BB%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/03/05/25-3-5%E8%AF%BB%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>没什么参考意义，就是tricks堆砌，不用看</p>          </div><h1id="erm-animproved-baseline-for-domain-generalization-阅读笔记">ERM++:AnImproved Baseline for Domain Generalization 阅读笔记</h1><p>作者为PiotrTeterwak，达特茅斯学院学士，波士顿大学博士，在谷歌、苹果都工作过，发表过6篇A会，作者的个人介绍页：<ahref="https://cs-people.bu.edu/piotrt/">Piotr Teterwak</a></p><p>文章发表于ICML 2023</p><h2 id="了解到文章的途径">了解到文章的途径</h2><p>在师兄的指导下做实验验证一个方法，实验过程中接触并使用了<strong>DomainBed</strong>这一域泛化实验框架，其中包含该算法，<strong>DomainBed</strong>中很多模型的类都以ERM作为父类，而ERM++是个例外，所以对其产生兴趣，并深入阅读论文。</p><p>打算在组会上讲解这篇论文。</p><h2 id="文章解决了什么问题">文章解决了什么问题</h2><p>ERM++是文章提出的一个新基线（baseline），如上所述，DomainBed这一广泛使用的框架使用ERM作为baseline。</p><blockquote><p>baseline：指一个经过<strong>充分调优</strong>的模型，一般是一个SOTA方法，不会显著劣于现有的所有方法，是新方法的对比对象。</p></blockquote><blockquote><p>[!TIP]</p><p>ERM：经验风险最小化，统计学习理论原则，由Vapnik提出，熟知的最小二乘法、极大似然法都是ERM的具体例子，在实际使用中，ERM就是“让loss最小”这个思想，也就是让损失函数最小化，这已经成为模型训练的底层逻辑了。</p></blockquote><p>然而，文章发现这个baseline其实不够充分调优，<em>似乎还有一些重要的超参数没有调</em>，会导致过拟合和灾难性遗忘</p><blockquote><p>过拟合：指在训练集上过分拟合，类似死记硬背，泛化能力大大降低，反而没有学到真正的特征，导致在测试集上效果极差，实际效果差</p><p>灾难性遗忘：在大规模数据上训练过的预训练模型对目标数据的泛化能力可能比微调之前更强，因为<strong>预训练数据的分布可能比源域数据的分布更接近目标数据的分布</strong>，如果在训练数据上进行微调，可能导致预训练模型忘记（也就是过拟合）先天的返泛化能力，导致灾难性遗忘。</p></blockquote><p>所以文章从3个方面进一步调整了ERM的参数：</p><ul><li>训练数据使用：一改原本的28分区，采用两轮pipeline（不知道咋翻译，意会吧），第一轮用验证集来选训练长度（trainlength）、学习率（learningrate，LR），然后第二轮把验证集也拿去训练，用第一轮的超参数。具体方法见后。<strong>这样增加了训练数据。</strong></li><li>初始化模型权重：觉得ResNet-50的TorchVision权重太outdated了，于是试验了其他的权重。（这里没咋看懂，看实验部分吧）</li><li>正则化：用MPA平均模型参数，再冻结预训练权重几百步（称为warmstart）。对于ResNet，使用ubn（解冻批次规范，不懂）；对于ViT，由于是transformer，用注意力调优。（没看懂怎么调优的，看代码吧）。<strong>来防止过拟合</strong></li></ul><blockquote><p>28分区：80%训练集，20%验证集，验证集用于在中途的checkpoint做测试</p><p>学习率：梯度下降的权值，学习率高，梯度下降快，容易略过最优解；学习率低，梯度下降慢，收敛慢，容易陷入局部最优。一般采用先快后慢。</p><p>train length：这里指steps。理由：<strong>To determine the traininglength</strong>, we keep training a model until it does not improveperformance on a validation set (held out from source domains)<strong>within the previous N <u>steps.</u></strong></p><p>MPA：Model Parameteraveraging，也就是把训练过程中不同步数时的模型参数求个平均，平均值不会太极端，低可能位于一个局部最优解上，所以找到的解不尖锐，更平坦，受到扰动或者变化时的影响更小，从而鲁棒性更强，<strong>平坦的最小值对应更低的泛化误差</strong></p></blockquote><p>得到新的baseline方法，称之为ERM++。解决了ERM会过拟合以及灾难性遗忘的问题。</p><h2id="作者针对这个问题是如何构建解决思路的如何想到可以这样解决的">作者针对这个问题是如何构建解决思路的？如何想到可以这样解决的？</h2><p>我是从DomainBed了解到这篇的</p><p>作者这篇已经加入到了DomainBed里面，最新的contributor都是这位作者</p><p>这篇文章后面基于ERM的实验全是用DomainBed做的，借鉴了很多DomainBed的内容</p><p>所以，我推断ERM++应该高度依赖于DomainBed那篇论文。</p><p>那么思路也由DomainBed而来，DomainBed论文中提出比ERM获得实质性的域泛化改进是有挑战的。（揭榜意图？）</p><p>DomainBed在最后提到BatchNorm会干扰域泛化算法，这可能是Unfreezing的来源。</p><p>意图分析尚不明朗，继续看</p><h2 id="更多的材料并分析">更多的材料并分析</h2><p>代码有，还没看</p><h2 id="从创新层面上为什么能发表">从创新层面上，为什么能发表</h2><p>虽然我没有觉得眼前一亮（是我太菜），但是感觉实验部分的数据挺重要，提出新baseline也很有意义，第一感觉就是工作量很足，数据很充分。</p><h2 id="方法有什么缺点">方法有什么缺点</h2><p>这真不知道了。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>文献阅读笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bvn总结</title>
    <link href="/2024/12/20/bvn%E6%80%BB%E7%BB%93/"/>
    <url>/2024/12/20/bvn%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="仿死神vs火影">仿《死神vs火影》</h1><h1 id="目录">目录</h1><p><a href="#_Toc185173544">一、 游戏概述 3</a></p><p><a href="#_Toc185173545">1.1 游戏简介 3</a></p><p><a href="#_Toc185173546">1.2 游戏开发环境 4</a></p><p><a href="#_Toc185173547">1.3 总体工作量 4</a></p><p><a href="#_Toc185173548">二、 游戏内容 5</a></p><p><a href="#_Toc185173549">2.1 游戏规则 5</a></p><p><a href="#_Toc185173550">2.2 游戏操作方式 5</a></p><p><a href="#_Toc185173551">2.3 游戏开始界面 6</a></p><p><a href="#_Toc185173552">2.4 游戏选择地图界面 6</a></p><p><a href="#_Toc185173553">2.5 游戏选择人物界面 7</a></p><p><a href="#_Toc185173554">2.6 游戏战斗界面 7</a></p><p><a href="#_Toc185173555">三、 游戏元素 8</a></p><p><a href="#_Toc185173556">3.1 人物 8</a></p><p><a href="#_Toc185173557">3.1.1 我爱罗（Gaara） 8</a></p><p><a href="#_Toc185173558">3.1.2 仙鸣（NarutoS） 8</a></p><p><a href="#_Toc185173559">3.2 战斗特效 9</a></p><p><a href="#_Toc185173560">3.3 行为特效 9</a></p><p><a href="#_Toc185173561">3.4 地图 10</a></p><p><a href="#_Toc185173562">3.4.1 地图1：月夜楼顶 10</a></p><p><a href="#_Toc185173563">3.4.2 地图2：终末之谷 10</a></p><p><a href="#_Toc185173564">3.5 血量条、Chakra条、气条 11</a></p><p><a href="#_Toc185173565">四、 核心逻辑 12</a></p><p><a href="#_Toc185173566">4.1 总体逻辑设计 12</a></p><p><a href="#_Toc185173567">4.1.1 开始界面逻辑 12</a></p><p><a href="#_Toc185173568">4.1.2 选地图界面逻辑 12</a></p><p><a href="#_Toc185173569">4.1.3 选人界面逻辑 12</a></p><p><a href="#_Toc185173570">4.1.4 战斗逻辑 12</a></p><p><a href="#_Toc185173571">4.2 代码架构设计 13</a></p><p><a href="#_Toc185173572">4.2.1 整体架构简述 13</a></p><p><a href="#_Toc185173573">五、 游戏难点、亮点及实现方案 15</a></p><p><a href="#_Toc185173574">5.1 素材收集、整理 15</a></p><p><a href="#_Toc185173575">5.1.1 素材收集 15</a></p><p><a href="#_Toc185173576">5.1.2 素材整理 15</a></p><p><a href="#_Toc185173577">5.2 人物动画 17</a></p><p><a href="#_Toc185173578">5.3 特效动画 18</a></p><p><a href="#_Toc185173579">5.3.2 特效池 18</a></p><p><a href="#_Toc185173580">5.3.3 战斗特效 19</a></p><p><a href="#_Toc185173581">5.3.4 通用特效 19</a></p><p><a href="#_Toc185173582">5.4 状态转移 19</a></p><p><a href="#_Toc185173583">5.5 碰撞检测 20</a></p><p><a href="#_Toc185173584">5.5.1 人物与人物碰撞 20</a></p><p><a href="#_Toc185173585">5.5.2 人物与特效碰撞 21</a></p><p><a href="#_Toc185173586">5.5.3 人物与地图碰撞 22</a></p><p><a href="#_Toc185173587">5.6 镜头跟随 24</a></p><p><a href="#_Toc185173588">5.6.2 不跟随镜头元件 25</a></p><p><a href="#_Toc185173589">5.6.3 跟随镜头元件 25</a></p><p><a href="#_Toc185173590">5.7 打击感 25</a></p><p><a href="#_Toc185173591">5.7.1 震屏 25</a></p><p><a href="#_Toc185173592">5.7.2 顿帧 26</a></p><p><a href="#_Toc185173593">5.7.3 打击感音效 26</a></p><p><a href="#_Toc185173594">5.8 键位设置 27</a></p><p><a href="#_Toc185173595">5.8.1 长按、短按 27</a></p><p><a href="#_Toc185173596">5.8.2 组合键 28</a></p><p><a href="#_Toc185173597">5.9 战斗效果 28</a></p><p><a href="#_Toc185173598">5.9.1 前摇、后摇 28</a></p><p><a href="#_Toc185173599">5.9.2 大招时停动画 29</a></p><p><a href="#_Toc185173600">5.9.3 受击硬直、击飞 30</a></p><p><a href="#_Toc185173601">5.10 性能优化 30</a></p><p><a href="#_Toc185173602">5.10.1 限制帧率 30</a></p><p><a href="#_Toc185173603">5.10.2 纹理图集 30</a></p><p><a href="#_Toc185173604">六、 心得体会 31</a></p><p><a href="#_Toc185173605">6.1 游戏开发历程 31</a></p><p><a href="#_Toc185173606">6.2 游戏版本迭代 31</a></p><p><a href="#_Toc185173607">6.3 结语 31</a></p><h1 id="游戏概述">游戏概述</h1><h2 id="游戏简介">游戏简介</h2><p>本游戏参照4399上的经典2D Flash 横板格斗游戏《死神vs火影》（Bleach vsNaruto）开发。</p><p>游戏实现了《死神vs火影》的大部分基本效果，玩家通过9个键控制角色，能够使用：</p><table><thead><tr><th>三段普攻（仙鸣为四段）</th><th>S远攻二段（仅仙鸣）</th></tr></thead><tbody><tr><td>W普攻</td><td>W远攻二段（仅仙鸣）</td></tr><tr><td>S普攻</td><td>空中远攻</td></tr><tr><td>空中普攻</td><td>大招</td></tr><tr><td>远攻</td><td>W大招</td></tr><tr><td>S远攻</td><td>S大招</td></tr><tr><td>W远攻</td><td>空中大招（仅仙鸣）</td></tr></tbody></table><p>招式汇总表</p><p>共14种攻击方式进行战斗，能够左右移动、二段跳跃、冲刺、防御，具备双人格斗游戏的基本玩法。</p><p>本游戏提供了较好的打击感和动画表现，招式繁多，且作为双人游戏，可玩性较高，玩家通过对角色的理解合理搭配连招，能够获得较好的游戏体验。</p><h2 id="游戏开发环境">游戏开发环境</h2><p>系统：windows 11</p><p>环境：C++ 17，visual studio community 2019</p><p>C++图形库：SFML 2.6.2</p><h2 id="总体工作量">总体工作量</h2><figure><img src="https://s3.bmp.ovh/imgs/2024/12/20/cd3c50d3c815a0d4.png"alt="代码量展示" /><figcaption aria-hidden="true">代码量展示</figcaption></figure><p>最终项目总行数为：4887行，有效代码行数为：4171行。</p><p>素材使用情况：</p><table><thead><tr><th>素材类型</th><th>数量（张）</th></tr></thead><tbody><tr><td>人物头像</td><td>2</td></tr><tr><td>地图</td><td>6</td></tr><tr><td>我爱罗人物动画帧</td><td>1251</td></tr><tr><td>我爱罗技能特效动画帧</td><td>312</td></tr><tr><td>仙鸣人物动画帧</td><td>1286</td></tr><tr><td>仙鸣技能特效动画帧</td><td>47</td></tr><tr><td>开始界面UI</td><td>93</td></tr><tr><td>战斗UI</td><td>17</td></tr><tr><td>通用特效动画帧</td><td>61</td></tr><tr><td>音效</td><td>23（个）</td></tr></tbody></table><p>素材类型汇总表</p><p>总计3075张图片，23个MP3文件。</p><h1 id="游戏内容">游戏内容</h1><h2 id="游戏规则">游戏规则</h2><p>进入游戏后，鼠标右键点击屏幕任意位置唤出开始游戏按钮，右键点击开始游戏按钮后进入地图选择界面，选择地图后进入人物选择界面，双方选择完人物后，待游戏加载完成后进入战斗。</p><p>两位玩家操控两个角色在选定的地图中战斗，战斗期间击中敌方或被击中都会积攒“气”，气共有3段，积攒满一段后即可消耗一段气释放大招或W大招，气满三段之后可消耗全部气释放超级大招——S大招。按下S键可防御敌方攻击——大幅减少伤害并免疫硬直和击飞效果，但每次受击会消耗Chakra，Chakra消耗光后无法再防御。冲刺也会消耗Chakra，当不处于冲刺状态和防御状态时，Chakra会自动恢复。</p><p>当一方受到最后一击，生命值清零时，决出胜负。</p><h2 id="游戏操作方式">游戏操作方式</h2><p>游戏分为1P和2P，键位设置如下：</p><table><thead><tr><th>操作类型</th><th>1P键位</th><th>2P键位</th></tr></thead><tbody><tr><td>向左移动</td><td>A</td><td>方向左键</td></tr><tr><td>向右移动</td><td>D</td><td>方向右键</td></tr><tr><td>跳跃</td><td>K</td><td>小键盘数字2</td></tr><tr><td>冲刺</td><td>L</td><td>小键盘数字3</td></tr><tr><td>防御</td><td>S</td><td>方向下键</td></tr><tr><td>主动落下平台</td><td>S+K</td><td>方向下键+小键盘数字2</td></tr><tr><td>普攻</td><td>J</td><td>小键盘数字1</td></tr><tr><td>S普攻</td><td>S+J</td><td>方向下键+小键盘数字1</td></tr><tr><td>W普攻</td><td>W+J</td><td>方向上键+小键盘数字1</td></tr><tr><td>远攻/空中远攻</td><td>U</td><td>小键盘数字4</td></tr><tr><td>W远攻</td><td>W+U</td><td>方向上键+小键盘数字4</td></tr><tr><td>S远攻</td><td>S+U</td><td>方向下键+小键盘数字4</td></tr><tr><td>大招/空中大招</td><td>I</td><td>小键盘数字5</td></tr><tr><td>W大招</td><td>W+I</td><td>方向上键+小键盘数字5</td></tr><tr><td>S大招</td><td>S+I</td><td>方向下键+小键盘数字5</td></tr></tbody></table><p>玩家键位表</p><h2 id="游戏开始界面">游戏开始界面</h2><p>界面1：具有动效以及主题音乐，详见演示视频</p><figure><img src="https://s3.bmp.ovh/imgs/2024/12/20/c75921dc53a9a159.png"alt="开始界面首页" /><figcaption aria-hidden="true">开始界面首页</figcaption></figure><p>鼠标单击任何位置进入界面2：</p><p>界面中间出现按钮，鼠标悬停后按钮样式变化</p><h2 id="游戏选择地图界面">游戏选择地图界面</h2><p>通过左右键选择地图</p><figure><img src="https://s3.bmp.ovh/imgs/2024/12/20/14bae6dbd685846e.png"alt="选择地图界面" /><figcaption aria-hidden="true">选择地图界面</figcaption></figure><h2 id="游戏选择人物界面">游戏选择人物界面</h2><p>通过左右键先选择1P的角色，再选择2P的角色，选择结束后进入战斗界面。</p><figure><img src="https://s3.bmp.ovh/imgs/2024/12/20/dc90a44d8a94ed24.png"alt="选择人物界面" /><figcaption aria-hidden="true">选择人物界面</figcaption></figure><h2 id="游戏战斗界面">游戏战斗界面</h2><figure><img src="https://s3.bmp.ovh/imgs/2024/12/20/d0f816e696679ec2.png"alt="战斗界面组图" /><figcaption aria-hidden="true">战斗界面组图</figcaption></figure><h1 id="游戏元素">游戏元素</h1><h2 id="人物">人物</h2><h3 id="我爱罗gaara">我爱罗（Gaara）</h3><figure><img src="https://s3.bmp.ovh/imgs/2024/12/20/a73b25c007a9e9dd.png"alt="我爱罗素材部分展示图" /><figcaption aria-hidden="true">我爱罗素材部分展示图</figcaption></figure><h3 id="仙鸣narutos">仙鸣（NarutoS）</h3><figure><img src="https://s3.bmp.ovh/imgs/2024/12/20/0be952abcb07c9f5.png"alt="仙鸣素材部分展示图" /><figcaption aria-hidden="true">仙鸣素材部分展示图</figcaption></figure><h2 id="战斗特效">战斗特效</h2><p>仙鸣的部分战斗特效动画帧：</p><figure><img src="https://s3.bmp.ovh/imgs/2024/12/20/468ba27eb21a5475.png"alt="螺旋手里剑特效" /><figcaption aria-hidden="true">螺旋手里剑特效</figcaption></figure><p>我爱罗的部分战斗特效动画帧：</p><figure><img src="https://s3.bmp.ovh/imgs/2024/12/20/ac4bd72698edf214.png"alt="我爱罗的部分战斗特效" /><figcaption aria-hidden="true">我爱罗的部分战斗特效</figcaption></figure><h2 id="行为特效">行为特效</h2><p>包含地面冲刺尾尘、空中冲刺尾烟、大招闪光特效、落地灰尘</p><h2 id="地图">地图</h2><h3 id="地图1月夜楼顶">地图1：月夜楼顶</h3><p>分为地图背景和地图前景，其中前景具有多个平台，可供人物站立。</p><p>背景始终填满视图图层底部，而前景固定不动，形成固定的2D世界参考系系。</p><figure><img src="https://s3.bmp.ovh/imgs/2024/12/20/6a6283626c5e13b1.png"alt="月夜楼顶地图" /><figcaption aria-hidden="true">月夜楼顶地图</figcaption></figure><h3 id="地图2终末之谷">地图2：终末之谷</h3><p>分为前景和背景，其中前景具有多个平台可供站立</p><figure><img src="https://www.helloimg.com/i/2024/12/20/676527c706674.png"alt="终末之谷地图" /><figcaption aria-hidden="true">终末之谷地图</figcaption></figure><h2 id="血量条chakra条气条">血量条、Chakra条、气条</h2><p>每个人物都具有自己的战斗相关UI，包括：血条框blood_bar、血条blood、Chakra框、Chakra条（表示充足的蓝色条、表示不足的粉色条）、Chakra示意文字贴图、气条框、气段数字、不同段对应的气条。</p><h1 id="核心逻辑">核心逻辑</h1><h2 id="总体逻辑设计">总体逻辑设计</h2><h3 id="开始界面逻辑">开始界面逻辑</h3><p>main函数首先执行键位映射，然后新建Game对象，运行run方法，Game对象初始状态为Init，对应开始界面，先轮播首页动画帧，轮播背景音乐。</p><p>鼠标点击后切换另一批动画帧，表现为画面从中间分开，露出内部的开始游戏按钮。</p><h3 id="选地图界面逻辑">选地图界面逻辑</h3><p>点击开始游戏按钮后Game的状态变为SelectMap，黑色为背景，绘制准备好的地图示意图片，图片周围有高光表示选择框，上有文字操作提示。选择地图后，Game类内部的Map对象获取到具体的子类对象指针，调用相应的加载方法加载地图资源。</p><h3 id="选人界面逻辑">选人界面逻辑</h3><p>地图选择完毕后，Game的状态变为SelectCharacter，画面以黑色为背景，绘制准备好的人物头像，周围有黄色、蓝色高光框分别表示1P和2P的选择框。1P选择后，Game类的成员player获得具体的子类对象指针（Gaara或NarutoS），2P选择同理。</p><h3 id="战斗逻辑">战斗逻辑</h3><p>人物加载完毕后，Game类进入Playing状态，此时循环执行process、update、render三个方法，分别代表：交互层、业务层、渲染层：</p><table><thead><tr><th></th><th>交互层</th><th>业务层</th><th>渲染层</th></tr></thead><tbody><tr><td>逻辑</td><td>先后调用1P和2P的键盘交互方法handleMove；在handleMove中，通过一系列实时键盘监听函数监听键盘输入，识别组合键和运动、攻击状态，同时屏蔽非法输入；监听到键盘输入后，调用Character的相关方法，改变人物的状态，赋予速度等</td><td>首先调用pause暂停管理器的更新方法，处理两个人物的暂停消息队列；根据暂停情况选择性调用1P和2P的update方法；然后处理两个人物的震屏、音乐触发消息队列； 最后更新视图位置。</td><td>首先判断是否触发大招的部分暂停，选择渲染黑色背景或正常地图背景；然后以：人物、特效、战斗UI的顺序绘制图像；最后设置视图位置，将视图放在2D世界的一个位置，表示窗口。</td></tr></tbody></table><p>游戏主循环架构</p><p>同时，循环播放战斗背景音乐。</p><p>一方生命值清零后，Game进入Over状态，屏幕中间出现结算字样，更新停止，待鼠标点击后关闭窗口结束。</p><h2 id="代码架构设计">代码架构设计</h2><h3 id="整体架构简述">整体架构简述</h3><p>整体类图</p><p>代码中各类的职责简述：</p><table><thead><tr><th>类名</th><th>职责简述</th></tr></thead><tbody><tr><td>Game</td><td>游戏整体流程控制</td></tr><tr><td>Character</td><td>抽象类，包含各种基本属性和方法，作为基类供各子类继承</td></tr><tr><td>CharacterFactory</td><td>工厂类，以工厂模式生产具体的人物子类指针</td></tr><tr><td>NarutoS</td><td>代表仙鸣角色，继承Character，通过重写实现个性化的机制</td></tr><tr><td>Gaara</td><td>代表我爱罗角色，继承Character，通过重写实现个性化机制</td></tr><tr><td>Effect</td><td>抽象类，包含特效的各种基本属性和方法，作为抽象类供各子类继承</td></tr><tr><td>EffectPool</td><td>特效池，包含多个Effect的指针，封装特效，对外提供产生特效的接口和绘制特效的接口</td></tr><tr><td>DefaultEffect</td><td>继承Effect类，代表通用特效，包含加载、更新、绘制等方法</td></tr><tr><td>NarutoEffect</td><td>继承Effect类，代表NarutoS的攻击特效</td></tr><tr><td>GaaraEffect</td><td>继承Effect类，代表Gaara的攻击特效</td></tr><tr><td>Map</td><td>抽象类，包含地图的基本属性和方法，供具体的地图子类继承</td></tr><tr><td>MapFactory</td><td>工厂类，以工厂模式生产具体的地图类对象指针</td></tr><tr><td>Platform</td><td>代表地图可站立平台，用于定义平台和碰撞检测</td></tr><tr><td>MR</td><td>继承Map类，代表月夜楼顶地图(Moon night Roof)</td></tr><tr><td>VE</td><td>继承Map类，代表终末之谷地图(Valley of End)</td></tr><tr><td>StartUI</td><td>代表开始界面，负责开始界面的贴图循环播放和点击效果</td></tr><tr><td>CameraShake</td><td>负责控制屏幕震动，向外提供触发屏幕震动的方法</td></tr><tr><td>Pause</td><td>负责全局暂停和部分暂停</td></tr><tr><td>GameAudio</td><td>负责加载以及控制游戏音乐、音效的播放</td></tr><tr><td>CharacterState</td><td>枚举类，包含人物所有的状态</td></tr><tr><td>EffectState</td><td>枚举类，包含特效的所有种类</td></tr><tr><td>GameState</td><td>枚举类，包含游戏的5种状态</td></tr><tr><td>CharacterType</td><td>枚举类，包含两个人物类别NarutoS和Gaara</td></tr><tr><td>MapType</td><td>枚举类，包含两个地图类别MR和VE</td></tr><tr><td>EventType</td><td>枚举类，包含事件类别，控制屏幕震动和暂停，用于事件队列机制，实现类间通信</td></tr></tbody></table><p>类职责简述</p><h1 id="游戏难点亮点及实现方案">游戏难点、亮点及实现方案</h1><h2 id="素材收集整理">素材收集、整理</h2><h3 id="素材收集">素材收集</h3><p>最开始开发时使用github仓库：<ahref="https://github.com/KevinChenXue/Naruto-vs-Bleach">KevinChenXue/Naruto-vs-Bleach:2-D platform fightergame</a>中的素材。开发到战斗阶段时发现素材严重不足，于是找到了原版游戏素材的github仓库：<ahref="https://github.com/5DPLAY-Game-Studio/assets_lib">5DPLAY-Game-Studio/assets_lib:《死神vs火影》素材库</a></p><p>但由于《死神vs火影》使用Flash开发，素材格式为swf，无法直接查看和使用。经过搜索，使用<ahref="https://github.com/jindrapetrik/jpexs-decompiler">jindrapetrik/jpexs-decompiler:JPEXS Free FlashDecompiler</a>将swf文件反编译，从中选择所需的图片、声音资源并导出。</p><h3 id="素材整理">素材整理</h3><p>问题：</p><ol type="1"><li>使用JPEX反编译导出的图片资源仍然不能直接使用，swf文件中的每个Sprite（计算机图形学概念，精灵，指具有各种属性的二维图像）导出后都是一组大小相同的图片，具有极大的空白区域（2600*1300的图片可能只有30*40的有效区域），需要裁切；</li></ol><figure><img src="https://www.helloimg.com/i/2024/12/20/676526b849270.png"alt="直接导出的素材示例" /><figcaption aria-hidden="true">直接导出的素材示例</figcaption></figure><ol type="1"><li>在程序中频繁切换Sprite的纹理将会产生巨大的GPU压力，导致程序性能严重下降，所以，需要将图片合并为一张纹理图集，同时记录每张图片在纹理图集中的锚框坐标，方便Sprite单次加载纹理图片，通过切换锚框的方式切换绘制出的纹理范围；</li><li>将纹理赋给Sprite后，如果直接循环播放，由于源点位置不同，会产生抖动现象，所以还需要确定所有图片的参考系源点坐标；（如下图例，直接绘制对齐的不是底部，而是顶部对齐，人物会上下抖动）</li></ol><figure><img src="https://www.helloimg.com/i/2024/12/20/676526b8b7cc7.png"alt="人物抖动示意图" /><figcaption aria-hidden="true">人物抖动示意图</figcaption></figure><ol type="1"><li>组图没有分区，还需要手动将每个行为对应的图组划分开</li></ol><p>解决：</p><ol type="1"><li>使用Python编写脚本，根据找到的所有图片的共同源点坐标，自动裁切空白区域后，得到裁切后源点的相对坐标，保存在origin.txt中；</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">crop_and_record</span>(<span class="hljs-params">input_dir, output_dir, record_file</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Crop PNG images to remove blank spaces and record new center coordinates.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        input_dir (str): Path to the folder containing input PNG images.</span><br><span class="hljs-string">        output_dir (str): Path to the folder to save cropped images.</span><br><span class="hljs-string">        record_file (str): Path to the file to save center coordinates.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># Ensure output directory exists</span><br>    os.makedirs(output_dir, exist_ok=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-comment"># Open the record file for writing</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(record_file, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> record:<br>        <span class="hljs-comment"># Iterate through sorted filenames in the input directory</span><br>        <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(os.listdir(input_dir), key=<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">int</span>(os.path.splitext(x)[<span class="hljs-number">0</span>])):<br>            input_path = os.path.join(input_dir, filename)<br><br>            <span class="hljs-comment"># Skip non-PNG files</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> filename.lower().endswith(<span class="hljs-string">&quot;.png&quot;</span>):<br>                <span class="hljs-keyword">continue</span><br><br>            <span class="hljs-comment"># Open the image</span><br>            <span class="hljs-keyword">with</span> Image.<span class="hljs-built_in">open</span>(input_path) <span class="hljs-keyword">as</span> img:<br>                <span class="hljs-comment"># Ensure the image is in RGBA mode</span><br>                img = img.convert(<span class="hljs-string">&quot;RGBA&quot;</span>)<br>                bbox = img.getbbox()  <span class="hljs-comment"># Get bounding box of non-empty regions</span><br><br>                <span class="hljs-keyword">if</span> bbox <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    <span class="hljs-comment"># If the image is completely blank, skip it</span><br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Image <span class="hljs-subst">&#123;filename&#125;</span> is completely blank. Skipping.&quot;</span>)<br>                    <span class="hljs-keyword">continue</span><br><br>                <span class="hljs-comment"># Crop the image to the bounding box</span><br>                cropped_img = img.crop(bbox)<br><br>                <span class="hljs-comment"># Calculate the new center relative to the cropped image</span><br>                original_width, original_height = img.size<br>                original_center = (xx, yy) <span class="hljs-comment"># 原图的源点</span><br>                new_center = (original_center[<span class="hljs-number">0</span>] - bbox[<span class="hljs-number">0</span>], original_center[<span class="hljs-number">1</span>] - bbox[<span class="hljs-number">1</span>])<br><br>                <span class="hljs-comment"># Save the cropped image</span><br>                output_path = os.path.join(output_dir, filename)<br>                cropped_img.save(output_path)<br><br>                <span class="hljs-comment"># Write the record to the file</span><br>                record.write(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;os.path.splitext(filename)[<span class="hljs-number">0</span>]&#125;</span>-<span class="hljs-subst">&#123;new_center&#125;</span>\n&quot;</span>)<br><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Cropped <span class="hljs-subst">&#123;filename&#125;</span>, new center: <span class="hljs-subst">&#123;new_center&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># Define input/output paths and record file</span><br>    input_directory = <span class="hljs-string">r&quot;&quot;</span><br>    output_directory = <span class="hljs-string">r&quot;&quot;</span><br>    record_file_path = <span class="hljs-string">r&quot;&quot;</span><br><br>    <span class="hljs-comment"># Run the cropping and recording function</span><br>    crop_and_record(input_directory, output_directory, record_file_path)<br><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>使用Python编写脚本，将多张图片合并为一张大图，同时保存每张图片在大图中的锚框位置和大小，保存在anchors.txt中；</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pack_images_with_metadata</span>(<span class="hljs-params">input_folder, origin_file, output_atlas, output_metadata</span>):<br>    <span class="hljs-comment"># 读取原点信息</span><br>    origins = &#123;&#125;<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(origin_file, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>            parts = line.strip().split(<span class="hljs-string">&quot;-&quot;</span>)<br>            image_number = <span class="hljs-built_in">int</span>(parts[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 获取图号</span><br>            origin_coords = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, parts[<span class="hljs-number">1</span>].strip(<span class="hljs-string">&quot;()&quot;</span>).split(<span class="hljs-string">&quot;, &quot;</span>)))  <span class="hljs-comment"># 提取 (x, y)</span><br>            origins[image_number] = origin_coords<br><br>    <span class="hljs-comment"># 读取所有图片</span><br>    images = []<br>    <span class="hljs-keyword">for</span> file_name <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(os.listdir(input_folder), key=<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">int</span>(os.path.splitext(x)[<span class="hljs-number">0</span>])):<br>        <span class="hljs-keyword">if</span> file_name.endswith(<span class="hljs-string">&quot;.png&quot;</span>):<br>            image_number = <span class="hljs-built_in">int</span>(os.path.splitext(file_name)[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 获取图号</span><br>            image_path = os.path.join(input_folder, file_name)<br>            image = Image.<span class="hljs-built_in">open</span>(image_path)<br>            images.append((image_number, image))<br><br>    <span class="hljs-comment"># 排列图片并计算图集大小</span><br>    MAX_ATLAS_WIDTH = <span class="hljs-number">1024</span><br>    atlas_width, atlas_height = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    row_width, row_height = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    packed_positions = []  <span class="hljs-comment"># 每张图片在图集中的位置 (x, y)</span><br><br>    <span class="hljs-keyword">for</span> _, img <span class="hljs-keyword">in</span> images:<br>        <span class="hljs-keyword">if</span> row_width + img.width &gt; MAX_ATLAS_WIDTH:<br>            <span class="hljs-comment"># 换行</span><br>            atlas_width = <span class="hljs-built_in">max</span>(atlas_width, row_width)<br>            atlas_height += row_height<br>            row_width = <span class="hljs-number">0</span><br>            row_height = <span class="hljs-number">0</span><br><br>        packed_positions.append((row_width, atlas_height))  <span class="hljs-comment"># 记录左上角位置</span><br>        row_width += img.width<br>        row_height = <span class="hljs-built_in">max</span>(row_height, img.height)<br><br>    atlas_width = <span class="hljs-built_in">max</span>(atlas_width, row_width)<br>    atlas_height += row_height<br><br>    <span class="hljs-comment"># 创建纹理图集</span><br>    atlas = Image.new(<span class="hljs-string">&quot;RGBA&quot;</span>, (atlas_width, atlas_height), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br><br>    <span class="hljs-comment"># 合成纹理图集，并生成元数据</span><br>    metadata_lines = []<br>    <span class="hljs-keyword">for</span> (image_number, img), (x1, y1) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(images, packed_positions):<br>        atlas.paste(img, (x1, y1))  <span class="hljs-comment"># 将图片粘贴到图集上</span><br>        width, height = img.size<br>        metadata_lines.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;image_number&#125;</span>-(<span class="hljs-subst">&#123;x1&#125;</span>, <span class="hljs-subst">&#123;y1&#125;</span>, <span class="hljs-subst">&#123;width&#125;</span>, <span class="hljs-subst">&#123;height&#125;</span>)&quot;</span>)<br><br>    <span class="hljs-comment"># 保存纹理图集</span><br>    atlas.save(output_atlas)<br><br>    <span class="hljs-comment"># 保存元数据</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_metadata, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(<span class="hljs-string">&quot;\n&quot;</span>.join(metadata_lines))<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Texture atlas saved to <span class="hljs-subst">&#123;output_atlas&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Metadata saved to <span class="hljs-subst">&#123;output_metadata&#125;</span>&quot;</span>)<br><br><br><span class="hljs-comment"># 输入与输出配置</span><br>input_folder = <span class="hljs-string">r&quot;&quot;</span>  <span class="hljs-comment"># 包含数字命名图片的文件夹路径</span><br>origin_file = <span class="hljs-string">r&quot;&quot;</span>  <span class="hljs-comment"># 每张图片的原点坐标文件</span><br>output_atlas = <span class="hljs-string">r&quot;&quot;</span>  <span class="hljs-comment"># 输出纹理图集路径</span><br>output_metadata = <span class="hljs-string">r&quot;&quot;</span>  <span class="hljs-comment"># 输出元数据路径</span><br><br><span class="hljs-comment"># 执行函数</span><br>pack_images_with_metadata(input_folder, origin_file, output_atlas, output_metadata)<br><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><p>通过JPEX，手动确定每个Sprite的源点坐标，设置在裁切脚本中；</p></li><li><p>手动分区，保存在section.txt中</p></li></ol><p>人物、特效、StartUI等需要循环播放图片实现动画效果的，都采用这样的方式处理素材，在程序加载时读取这些txt文件。</p><h2 id="人物动画">人物动画</h2><p>人物通过updateSprite方法实现动画循环播放和贴图切换，并且设置单独的贴图更新帧率，独立于游戏的70帧，贴图播放仅有30帧，使动画更自然。</p><p>Game的update方法会记录每次调用该方法的间隔时间deltaTime，传给updateSprite方法，Character类中有一个成员变量elapsedTime通过累加每次的deltaTime记录过去的时间，当过去的时间超过0.034秒后，触发贴图切换，根据人物当前的状态选择不同的区间，自增帧号，再通过类似段寻址的方式，以区间起始+帧号作为索引，获得纹理图集的锚框和源点坐标，设置给Sprite，特殊的状态还会根据当前帧号大小触发特效、暂停、语音、震屏。当单播类型的动画帧结束后，还会触发状态转移，转移到循环播放的状态。</p><p>贴图切换后，根据Character中的boolleft变量，对sprite进行方向设定，最后设置位置，完成贴图切换。</p><p>为了实现人物被埋的效果（Gaara的W大招），设置Default状态，Default状态不参与任何按键逻辑，贴图为特殊的0号，透明，表示消失。</p><h2 id="特效动画">特效动画</h2><p>动画实现方式与人物动画类似。</p><p>对于持续存在直到离开画面的特效，采用循环播放，对于具有持续时间的特效，采用单次播放：</p><p>特效结束后，会重置为Default状态，实现复用。</p><h3 id="特效池">特效池</h3><p>特效位于特效池EffectPool中，人物通过特效池提供的run方法生成分体战斗特效。</p><p>特效池包含一个Effect指针容器，在人物的构造函数中完成初始化，通过多态将子类NarutoSEffect、GaaraEffect或DefaultEffect的指针装入特效池的Effect指针容器中，通过run、render、update方式集中处理特效池中的特效。</p><p>渲染时，调用特效池EffectPool的render方法，绘制池中非Default状态的特效，特效池的update方法也只更新池中非Default状态的特效。</p><h3 id="战斗特效-1">战斗特效</h3><p>战斗特效是人物在战斗中打出的离体攻击，有追身、运动两种类型。</p><p>追身特效有Gaara的W远攻、大招、S大招，能够突然出现在敌方的位置对敌方进行攻击，难以被闪避。</p><p>运动特效类似于子弹，能够离体运动，具有直线飞行、对角线飞行两种运动方式，能对敌方造成伤害。</p><p>其中，大招特效还具有before、after、miss三种状态，对应击中前、击中后、未击中三种状态，通过updateSprite方法实现状态转移。</p><p>战斗特效有NarutoSEffect和GaaraEffect两类，对应两个人物的战斗特效，人物在updateSprite中，播放到特定动画帧时，通过特效池的run方法触发战斗特效：</p><h3 id="通用特效">通用特效</h3><p>通用特效包含：在地面冲刺时的灰尘、在空中冲刺时的烟气、落地时的灰尘、是放大招的闪光特效。</p><p>在Character类中以单独一个特效池defaultEffectPool存放，在冲刺、落地、释放大招时通过run方法触发。</p><h2 id="状态转移">状态转移</h2><p>游戏大范围使用状态机思想，包含GameState、CharacterState、EffectState三类状态，对应游戏状态、人物状态、特效状态，其中CharacterState和EffectState对齐。</p><p>人物具有38种状态，具体为：</p><table style="width:100%;"><thead><tr><th>CharacterState</th><th>对应状态</th><th>CharacterState</th><th>对应状态</th><th>CharacterState</th><th>对应状态</th></tr></thead><tbody><tr><td>Default</td><td>消失</td><td>Stand</td><td>站立</td><td>U</td><td>远攻中</td></tr><tr><td>KI_before</td><td>空中大招命中前</td><td>Running</td><td>跑动</td><td>U_after</td><td>远攻命中后</td></tr><tr><td>KI_after</td><td>空中大招命中后</td><td>Jumping</td><td>跃起</td><td>WUU</td><td>二段W远攻</td></tr><tr><td>KI_miss</td><td>空中大招未命中</td><td>Fall</td><td>下落</td><td>SUU</td><td>二段S远攻</td></tr><tr><td>I_before</td><td>大招未命中</td><td>Landed</td><td>着陆</td><td>WU</td><td>W远攻</td></tr><tr><td>I_after</td><td>大招命中</td><td>S</td><td>防御</td><td>SU</td><td>S远攻</td></tr><tr><td>I_miss</td><td>大招未命中</td><td>S_Release</td><td>防御释放中</td><td>Flash</td><td>冲刺</td></tr><tr><td>WI_before</td><td>W大招命中前</td><td>WJ</td><td>W普攻</td><td>J2</td><td>普攻2段</td></tr><tr><td>WI_after</td><td>W大招命中后</td><td>SJ</td><td>S普攻</td><td>J3</td><td>普攻3段</td></tr><tr><td>WI_miss</td><td>W大招未命中</td><td>J1</td><td>普攻1段</td><td>J4</td><td>普攻4段</td></tr><tr><td>KU</td><td>空中远攻</td><td>KU_down</td><td>空中远攻着陆</td><td>KJ</td><td>空中普攻</td></tr><tr><td>Hit</td><td>受击硬直</td><td>Kick</td><td>击飞</td><td>SI_before</td><td>S大招命中前</td></tr><tr><td>SI_after</td><td>S大招命中后</td><td>SI_miss</td><td>S大招未命中</td><td></td><td></td></tr></tbody></table><p>人物状态汇总表</p><p>Effect另外多出4种：Flash_air, Flash_ash, Landed_ash, I_effect。</p><p>状态转移发生在：交互层触发的行为方法中、贴图更新中、碰撞检测中。整体的人物状态转换图如下：</p><h2 id="碰撞检测">碰撞检测</h2><h3 id="人物与人物碰撞">人物与人物碰撞</h3><p>本游戏尽量避免人物重合，当人物没有攻击，而是相互靠近并发生碰撞时，不会发生重合和穿越，会互相阻挡，产生推动效果。</p><p>此时只需要计算出图片的矩形区域，以sf::FloatRect类型保存，并调用intersact方法即可判断是否重合。</p><p>如果出现重合，人物的运动速度会降低，同时调用separate方法，以类似库仑力的效果使角色之间相斥，相斥速度计算式为，REPULSION为斥力常数，由于人物不设置重量，故将库仑力计算式的分子部分合并为一个斥力常数，分母由于始终大于1，用一次方替代二次方，能够实现间距越小，斥力越大。在人物都挤在墙角时，可以实现平滑地将对方挤出，而非生硬地瞬间位移。</p><h3 id="人物与特效碰撞">人物与特效碰撞</h3><p>战斗特效，以下也称为人物的“攻击部”，也就是能够对敌方造成伤害的部分。</p><p>许多招式的攻击部分和人物本身绘制在同一张图片中，如下例所示：</p><figure><img src="https://www.helloimg.com/i/2024/12/20/676526b8b75c9.png"alt="人物与其攻击部于同一张图片的示例" /><figcaptionaria-hidden="true">人物与其攻击部于同一张图片的示例</figcaption></figure><p>此时需要对人物本体和攻击部做出划分，正确地判定碰撞。</p><p>对于我爱罗，通过观察发现绝大部分的攻击图片，其本体都在图片左侧，攻击部在右侧。所以设定宽40，高50的矩形作为本体框，右侧部分作为攻击部，分别参与碰撞判定。</p><p>比如，当判定仙鸣是否被我爱罗的攻击部命中时，需要计算出仙鸣目前的本体部分以及我爱罗的攻击部，用这两者来进行碰撞判定，而不是简单地判断图片是否重合。</p><p>对于仙鸣，我爱罗的规律不再适用，仙鸣的攻击分布可分为三类：（以1P键位指代招式）</p><ul><li>攻击部位于图片右部：KJ、SUU、WJ、KU</li></ul><figure><img src="https://www.helloimg.com/i/2024/12/20/676526b89057e.png"alt="攻击部位于右侧的示例" /><figcaption aria-hidden="true">攻击部位于右侧的示例</figcaption></figure><ul><li>攻击部在图片右上部：WU、WUU</li></ul><figure><img src="https://www.helloimg.com/i/2024/12/20/676526b8633f0.png"alt="攻击部位于右上部的示例" /><figcaption aria-hidden="true">攻击部位于右上部的示例</figcaption></figure><ul><li>攻击部占满整个图片：WI、SJ、J等</li></ul><figure><img src="https://www.helloimg.com/i/2024/12/20/676526bb0e8b1.png"alt="攻击部占满整个图片的示例" /><figcaption aria-hidden="true">攻击部占满整个图片的示例</figcaption></figure><p>于是有以下划分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 对于NarutoS，KJ SUU WJ KU取除体右段，WU WUU取右上角，其他全匹配</span><br><span class="hljs-keyword">if</span> (enemy-&gt;currentState == CharacterState::KJ ||<br>    enemy-&gt;currentState == CharacterState::SUU || <br>    enemy-&gt;currentState == CharacterState::WJ || <br>    enemy-&gt;currentState == CharacterState::KU) &#123; <span class="hljs-comment">// 左裁40</span><br>    <span class="hljs-keyword">if</span> (!enemy-&gt;left) &#123;<br>        enemyRect.left += <span class="hljs-number">40.f</span>;<br>    &#125;<br>    enemyRect.width -= <span class="hljs-number">40.f</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (enemy-&gt;currentState == CharacterState::WU ||<br>         enemy-&gt;currentState == CharacterState::WUU) &#123;<span class="hljs-comment">// 左裁35，下裁40</span><br>    enemyRect.height -= <span class="hljs-number">40.f</span>;<br>    <span class="hljs-keyword">if</span> (!enemy-&gt;left) &#123;<br>        enemyRect.left += <span class="hljs-number">35.f</span>;<br>    &#125;<br>    enemyRect.width -= <span class="hljs-number">35.f</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="人物与地图碰撞">人物与地图碰撞</h3><p>人物本身具有一个sf::Vector2f类型的位置变量position，分为x分量和y分量，代表相对于绝对2D世界左上角的xy坐标，在绘制时，position点需要与图片的origin（素材整理阶段确定的源点）保持相对位置不变，才能避免抽搐。</p><p>但是，position不能直接与origin重合，因为每张图片的origin大多位于人物本体的中心，如果与position重合，会导致人物绘制出来不是站在平台上，而是“挂”在了平台上。</p><p>所以，需要得到一个适用于大部分图片的偏移量，使position点绘制的部位为人物本体的脚底。</p><p>得到该偏移量后，为了避免修改源程序，故编写Python脚本，统一修改origin.txt的y坐标，使其增加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">adjust_y_coordinate</span>(<span class="hljs-params">input_file, output_file, y_increment=<span class="hljs-number">25</span></span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(input_file, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>        lines = file.readlines()<br><br>    updated_lines = []<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>        line = line.strip()<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-keyword">in</span> line:<br>            <span class="hljs-comment"># 拆分图号和坐标</span><br>            key, value = line.split(<span class="hljs-string">&#x27;-&#x27;</span>)<br>            value = value.strip(<span class="hljs-string">&#x27;()&#x27;</span>)<br>            x, y = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, value.split(<span class="hljs-string">&#x27;, &#x27;</span>))<br>            <span class="hljs-comment"># 增加 y 坐标</span><br>            y += y_increment<br>            updated_lines.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;key&#125;</span>-(<span class="hljs-subst">&#123;x&#125;</span>, <span class="hljs-subst">&#123;y&#125;</span>)&quot;</span>)<br><br>    <span class="hljs-comment"># 保存到新文件</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_file, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>        file.write(<span class="hljs-string">&#x27;\n&#x27;</span>.join(updated_lines))<br><br>input_file = <span class="hljs-string">r&quot;&quot;</span><br>output_file = <span class="hljs-string">r&quot;&quot;</span><br>adjust_y_coordinate(input_file, output_file)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;处理完成！结果已保存到 <span class="hljs-subst">&#123;output_file&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><center>批量修改origin.txt的Python脚本</center><p>修改origin.txt后，人物的参照点变为脚底，不仅方便绘制，而且方便计算本体框。</p><p>判断与地图平台碰撞只需要在每次更新时遍历所有平台，判断人物的position是否位于平台上方极近距离内。</p><p>由于人物下落速度过快时可能导致在相邻两次更新间直接越过平台的判定区域，所以我限制了最大下落速度，并以此作为最大下落速度设置平台的判定距离。</p><p>当触发主动下落操作（S+K）时，通过令人物垂直位置增加一个略大于TOLERANCE的距离即可落下当前平台。</p><h2 id="镜头跟随">镜头跟随</h2><p>镜头跟随是本游戏的一大主要亮点和难点，主要依赖SFML的视图（View）机制实现。</p><p>不同于其他2D游戏，如酷跑类、地图类等的镜头永远跟随单个角色、角色在画面中的相对位置永远不变等简单机制。</p><p>本游戏具有两个角色，对镜头的移动都具有话语权，本游戏的地图虽然是固定不变的，但是窗口远小于整个地图，窗口具有镜头效果，只展示地图的一部分，具体机制如下：</p><ul><li><p>远景永远不动，铺满镜头作为背景；</p></li><li><p>两角色的连线中点作为镜头的焦点；</p></li><li><p>在一定距离内，镜头宽度不变；</p></li><li><p>角色尝试分离并离开镜头区域，镜头区域宽度增加以装下角色，同时镜头焦点变化；</p></li><li><p>镜头达到最大放大程度，不再放大，同时限制角色离开镜头区域；</p></li><li><p>角色靠近，镜头缩小，镜头两侧与角色的间距不变(约1/10宽度，平滑)，直到进入一定距离，缩放达到最大程度，角色很靠近，且具有放大效果。</p></li><li><p>镜头的放缩都采用线性插值实现平滑移动，避免高速运动时的镜头剧烈变化</p></li></ul><p>机制参考了<ahref="https://game.academy.163.com/course/careerArticle?course=438">2D视角游戏镜头机制研究（二）：镜头的部署和移动方式-网易游学-为热爱赋能</a></p><h3 id="不跟随镜头元件">不跟随镜头元件</h3><p>游戏具有绝对的2D世界坐标系，独立于产生的窗口，地图中的建筑、人物、特效就采用绝对2D世界坐标系，固定不动，不随镜头变化而改变位置。</p><p>绘制时就采用绝对坐标</p><h3 id="跟随镜头元件">跟随镜头元件</h3><p>血条、气条、Chakra条等战斗UI需要时刻位于窗口的固定位置，所以需要指定每个元件在窗口中的相对位置，并每帧实时计算这些相对位置的绝对位置。</p><h2 id="打击感">打击感</h2><p>本游戏是格斗类游戏，营造打击感非常重要，本游戏通过三个方面营造打击感，分别是震屏、顿帧、音效。三种效果都采用事件队列机制实现。</p><h3 id="震屏">震屏</h3><p>在5.6镜头跟随的基础上，屏幕震动不难实现，只需要使镜头发生抖动即可。</p><p>具体实现方式为：</p><p>角色受击后，向自己的事件队列中加入震屏事件🡪Game的业务层处理角色的事件队列，根据事件触发震屏，产生随机的垂直方向偏移量🡪业务层更新视图（View）时应用震屏偏移量，实现视图抖动。</p><h3 id="顿帧">顿帧</h3><p>顿帧代表受击的瞬间暂停一会，营造一种“卡肉感”和“阻滞感”。</p><p>暂停可以通过在update层跳过人物的update方法实现，具体实现方法是：</p><p>角色受击后，向自己的暂停事件队列中加入事件，表示发出暂停请求🡪Game的update层在更新人物前先处理暂停事件🡪如果是全局暂停，则跳过1P和2P的update方法，使其维持现状🡪当暂停计时器到点后，取消暂停状态，恢复对1P和2P的update方法执行。</p><h3 id="打击感音效">打击感音效</h3><p>本游戏共有21种音效，包含人物语音，招式音效和打击音效，打击感音效主要有受击音效和击飞音效。</p><p>音效播放依赖于SFML的Sound类，SFML的Sound类和Music类都能使用单独的线程播放音乐和音效，方便了程序的编写，本游戏的主要实现方式为：</p><p>角色向自己的音效事件队列audioEventQueue中加入特定的音效事件，表示请求播放音效🡪Game类的update方法处理音效事件，根据队列中的请求播放对应的音效。</p><h2 id="键位设置">键位设置</h2><p>本游戏招式繁多，每个玩家能够使用9个键位操纵角色，共有15种操作方式，详见2.2游戏操作方式。下面主要介绍如何实现各种键位操作：</p><h3 id="长按短按">长按、短按</h3><p>SFML提供两种键盘监听方式：</p><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>键盘事件队列</td><td>能够区分按下次数，长按也只算一次按键，避免单次按键多次判定；能够识别按键释放事件；</td><td>原子性过高，无法识别多个键是否被同时按下；</td></tr><tr><td>实时监听</td><td>灵敏，能够实现组合键；</td><td>过于灵敏，单次按键会多次判定 只能监听是否按下；</td></tr></tbody></table><p>SFML键盘监听方式分析表</p><p>由于本游戏无法放弃组合键机制，所以只能使用实时监听方式。</p><p>单次按键多次判定会导致：在一瞬间触发多次跳跃，浪费次数，无法实现二段跳效果；在一瞬间普攻十几次，无法实现多段普攻。</p><p>针对这两个问题，解决方案如下：</p><p>对二段跳设置速度限制，起跳是初速度向上的匀减速运动，为了防止在短时间内连续触发跳跃，限制起跳时的速度不能太快，等到首段跳跃的向上速度减速到一定程度后，再开放二段起跳的功能：</p><p>程序中的“LIMIT_V”为起跳初速度JUMP_VELOCITY +0.1秒的重力GRAVITY减速，0.1秒是实测得到的连续两次点按键盘的最短间隔时间。</p><p>普攻同样设置触发限制，通过动画帧号限制多段普攻的触发，如果第一段普攻只播放了一两帧（每帧动画0.034秒），却导致了多次J键判定，那么由于帧号不足，将被屏蔽，由此实现多段普攻。</p><p>仙鸣的二段WU和二段SU同理。</p><h3 id="组合键">组合键</h3><p>对于游戏中的组合键，通过设置父子状态的方式实现，以SJ举例：</p><p>首先监听S是否按下，如果没有按下，则不进入“S”系列招式（S、SJ、SU、SI等）的进一步判定，如果按下，则进入“S”系列招式的进一步判定，判定J是否按下，如果按下并通过状态限制后，则调用sj()方法，触发S普攻招式。区分SJ和J的方式为：</p><p>当S按下，则为SJ，当S未被按下，再检测J键，此时判定是否进行普攻。</p><p>游戏还具有抗打断机制，即释放部分招式时无法左右移动、跳跃从而打断招式释放。主要通过角色当前状态来屏蔽移动、跳跃操作，只需要加一个if判断状态即可。</p><h2 id="战斗效果">战斗效果</h2><p>本游戏作为格斗游戏，具有前摇、后摇、大招时停动画、受击硬直、击飞等丰富的战斗效果。</p><h3 id="前摇后摇">前摇、后摇</h3><p>前摇、后摇指人物释放技能前、后不可打断，脱离控制的行为，主要用于向敌方提供反应时间和攻击窗口期。如果人物能够无前摇、后摇地释放技能，那么将导致无法近身攻击，只需要一直不停地释放技能就能产生“金钟罩”从而立于不败之地，对游戏性产生很大影响。</p><p>最初，前摇和后摇机制计划使用针对角色的局部暂停来实现，在角色释放技能前后添加暂停，屏蔽键盘输入，达到一瞬间的不可控状态，但是过于繁琐。</p><p>最终的解决方法为：将人物的38种状态做区分，有非攻击态和攻击态，当角色处于攻击态时，屏蔽特定的键盘输入，同时增加技能前后的相同动画帧，拉长动画播放时间，就形成了前摇和后摇。以下以Gaara的SJ技能举例：</p><figure><img src="https://www.helloimg.com/i/2024/12/20/676526bb785b1.png"alt="招式前摇、后摇动画帧分区示意图（Gaara的S普攻）" /><figcaptionaria-hidden="true">招式前摇、后摇动画帧分区示意图（Gaara的S普攻）</figcaption></figure><h3 id="大招时停动画">大招时停动画</h3><p>Gaara的三种大招都是瞬发，没有设置时停和黑屏动画。但是仙鸣的大招具有很长的前摇动画，如果全部作为前摇播放，将大大削弱角色的战斗力和动画的表现力。</p><p>所以需要为仙鸣设置大招时停动画，具体包含：</p><ul><li>仙鸣大招前摇期间，背景全黑突出人物；</li><li>除仙鸣本体之外，其他人物、特效全部暂停；</li><li>大招释放瞬间，人物周围出现蓝色闪光特效，播放大招对应人物语音；</li><li>大招前摇结束后，恢复正常更新；</li></ul><p>结合已经实现的暂停器pause、通用特效池defaultPool、音效触发器gameAudio，只需要额外实现背景黑屏即可。实现方式为：为Game类添加一个专门的黑色背景sprite，如果处于部分暂停期间，则不绘制地图，而是绘制黑色背景。</p><h3 id="受击硬直击飞">受击硬直、击飞</h3><p>游戏设置了受击的硬直时间和击飞效果。</p><p>受击硬直的特点是：持续时间内无法操控，能够被再次攻击，能够以正常的物理规律运动。</p><p>击飞的特点是：持续时间内无法操控，不能被再次击中。</p><p>受击硬直主要用于供对手打出连招，而击飞则用于限制对手无法一直连击。</p><p>在代码中，击飞对应Kick状态，受击对应Hit状态。当处于这两个状态时，键盘控制会被屏蔽，无法释放招式或移动跳跃；刚进入状态时，会触发打击音效，击飞状态额外有人物闷哼语音，用于表现打击感。</p><h2 id="性能优化">性能优化</h2><p>性能优化为开发过程中遇到的难点之一，主要的性能问题是：</p><ul><li>频繁切换sprite的纹理，程序运行时GPU占用率100%</li><li>每增加一个需要绘制的sprite，每秒执行游戏主体大循环的次数就会减少，导致运行过程中帧率不稳定，表现为游戏过程中的卡顿、掉帧</li></ul><h3 id="限制帧率">限制帧率</h3><p>SFML提供了限制窗口帧率的方法，本游戏限制帧率为70帧。该方法限制帧率的机制为：在每次循环后睡眠一段时间，使一秒钟执行的循环总数在70次左右</p><p>由于限制之前，游戏的帧率在200~400帧，所以设置的物理体系数值全部出错，表现为人物运动迟缓，速度、加速度都大幅降低。所以通过计算，得到了70帧下适用的各项速度数值，保存在Constant.h中以宏定义形式在代码中使用。</p><h3 id="纹理图集">纹理图集</h3><p>如5.1.2素材整理，编写Python程序，将上千张图片合并为一张图片，称为纹理图集，避免每次更新贴图都要切换sprite的纹理，使GPU使用率从最初的100%降低到目前的30%左右。</p><figure><img src="https://www.helloimg.com/i/2024/12/20/676526b9218a3.png"alt="GPU使用率实测的截图" /><figcaption aria-hidden="true">GPU使用率实测的截图</figcaption></figure><h1 id="心得体会">心得体会</h1><h2 id="游戏开发历程">游戏开发历程</h2><p>见<ahref="https://github.com/novelyear/bvn/commits/master/">git历史记录</a></p><h2 id="游戏版本迭代">游戏版本迭代</h2><p>最初设想的版本是单人对战人机，但是从上面的git历史可以看到完成初步narutoAI已经非常靠后了，由于人机实现难度较大，效果不好，于是改为双人游戏版本，能提供更好的游戏体验。</p><h2 id="结语">结语</h2><p>四千多行代码，近三千张图片，历时一个月，虽然和真正的游戏相比规模尚小，但已经这是我迄今为止独立写过的最大工程了，每一个小功能都花费了很多精力，许多个小功能才累积成了现在的样子。这也是我首次全程使用git做版本管理，使用多个分支进行工作很有条理。</p><p>开发的过程见证了我编码能力的一步步加强，最开始设计能力不足，类结构混乱，代码严重耦合，这也导致最后Character类和Game类显得比较臃肿，难以重构，其中Character类的定义竟然将35种动画的图号区间每个都写为一个成员变量。</p><p>后来，我的思路更加清晰，编码更合理，之后的特效类采用哈希表保存大量的动画帧信息；人物、地图、特效的生成充分利用工厂模式等设计模式优化代码结构；事件队列的使用也越来越合理，最开始的震屏事件队列和Character类耦合，之后的暂停事件队列和音效事件队列就与Character类实现解耦。</p><p>最初想要将这个项目作为长期项目来做，希望能够用C++重写整个游戏，并且加入自己的一些魔改素材整活。但真正开发后发现，人物之间的区别很多，各有特色，最初设计的Character抽象类并不能满足作为所有人物基类的功能，设计得太“个性化”，导致后续增加角色困难。所幸Map类还是设计得比较好，扩展很容易。</p><p>这个游戏的开发让我把从软件工程课上学到的东西用了出来，设计模式和代码架构对于整个工程的作用的确很巨大。开发到后期，debug也逐渐得心应手，图形化调试不像一般的调试，看不到实时画面，找到问题的难度更大，但是到了后期，解决的问题成为了经验，往往一次调试就能直接找到bug，这表示我对整体有了更清晰的了解。</p><p>如果看过项目的素材库<ahref="https://github.com/novelyear/bvn/tree/master/access">/access</a>，就会发现我还有很多没用到的素材，还有很多机制没有实现，相比于原游戏，游戏性还很不足，以后如果有时间，也许会完善机制，实现没有实现的构想。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SFML</tag>
      
      <tag>游戏开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bvn过程记录</title>
    <link href="/2024/11/13/bvn%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/11/13/bvn%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>此为研开大作业——仿《死神vs火影》(Bleach vsNaruto，故名bvn)的项目开发过程记录</p><p><del>实际上是类似草稿本的存在</del></p><h1 id="section">11.13</h1><p>配好了环境，SFML需要：</p><ul><li>下载</li><li>设置项目的附加lib和include，还有链接的文件，再把dll文件复制到x64下的debug。</li></ul><p>把图片准备好，地图后景和前景。</p><p>人物目前暂定就itachi、garra跟一护，特效和人物动作都齐全，鸣人的三段变身缺第三段变身的素材，第二段的缺技能特效。</p><blockquote><p>地图得做视差滚动，看是直接贴图还是以材质形式贴上去</p></blockquote><h6 id="小坑">小坑</h6><p>visual studio的相对路径是以sln所在的目录开始的，不是exe的。</p><h1 id="section-1">11.14</h1><ul><li>调好窗口大小</li><li>贴好图片</li><li>放个人物上去，先左右，再上下，根据人物的位置实现地图视差滚动</li><li>实现地图的高台站立</li></ul><p>只有一张地图？先弄好一个地图吧，记得面向对象，后面才好换地图和人物。</p><p>软件工程起作用了，不能直接开始写，不然就是堆在一个文件里了，得OOP，就要先设计好整体的架构，先整个类图出来。</p><p>暂定Game、Character分Player，Enemy、Map、Platfrom、SoundManager、GameClock、Effect这几个类，共同组成Game大类（感觉要重构，一开始就设计好太难了，软件工程上是怎么敏捷开发的呢？）</p><blockquote><ul><li>远景永远不动</li><li>在一定距离内，窗口不缩放</li><li>角色尝试分离并离开窗口，窗口放大以装下角色，同时窗口被拖动</li><li>窗口达到最大放大程度，不再放大，同时限制角色离开窗口</li><li>角色靠近，窗口缩小，窗口两侧与角色的间距不变(约1/10宽度，平滑)，直到进入一定距离，缩放达到最大程度，角色很靠近。</li></ul></blockquote><p>搜了一下，这可以叫盒子模型，SFML正好有机制能够实现这种类似于有一个镜头的逻辑，叫做“视图”。先学习一下。</p><p>引入视图，实现大地图固定绘制，移动视图来实现镜头感</p><p>视图有最小尺寸和最大尺寸，最大会反过来限制人物的位置，但是视图的坐标好像和实际2D空间的坐标不一致，写写停停没时间了，调试之前还需要初始化人物和视图的位置，但是已经初步完成了视图聚焦图像的一部分，只不过背景没固定，前景没铺开。</p><p>背景固定铺满窗口需要在view中绘制，而不能在window中绘制，window对应着2D世界，而view是可视界面</p><p><imgsrc="https://s3.bmp.ovh/imgs/2024/11/14/17afd9dcd1208c8d.png" /></p><p>明天继续</p><h1 id="section-2">11.15</h1><p>人物是贴上去了，速度如何设置呢？</p><p>按键-&gt;运动-&gt;松开-&gt;不运动，所以按键就让速度生效，不按键就不影响position。抛开牛顿定律，按键影响速度，不按键速度归零，位置每一帧都得加上速度</p><p>游戏循环为：处理事件 ==&gt; 更新状态 ==&gt; 绘制画面。</p><blockquote><p><del>问题：</del></p><p>人物不能同时跳跃和左右移动，只能垂直起跳，且朝向切换迟滞</p><p>预估是事件队列的原因</p><p>问题2：</p><p>窗口的跟随移动稍微有点大，还需要做：</p><p>窗口的极大限制；人物与窗口边缘的间距</p></blockquote><blockquote><p>BUG1：</p><p>把按键逻辑放在处理事件中，就会很卡，但是如果鼠标一直移动就会顺畅，甚至能够在空中保持水平速度！</p><p>如果把按键逻辑放在update中，就会顺畅，但是速度值会莫名变大，同样的数值会有更快的速度</p><p>解决：</p><p>之前是从窗口捕获的事件队列里逐个取出然后传给handle函数判断，显然效率很低</p><p>现在改为sf::Keyboard::isKeyPressed()，执行到的时候即时查询键盘状态，由于这个游戏大部分都会长按AD键移动，所以即时更合理</p></blockquote><p>但是，原游戏只有AD可以长按，其他都只能点按，例如长按K不会一直跳跃。</p><blockquote><p>BUG2：</p><p>又无法二段跳了。。</p><p>解决：</p><p>测了下当前的帧率，基本都有300+帧/秒，所以在短时间内就跳了两段，要么引入限制，要么用事件取消K的即时查询而放过AD，技能释放肯定也会有这样的问题，短时间释放了好几个，现在就解决掉。</p><p>又把事件队列引回来了，正好实现了跳跃的：无法长按连跳、按键事件区分</p></blockquote><p>和原型游戏对比，得到镜头最大放大<strong>2.5</strong>倍。用mapPixelToCoords函数转坐标来固定后背景，前景就设在绝对2D坐标系下，图片的大小和人物的比例正好匹配，当前图像尺寸是800<em>600，窗口尺寸1600</em> 1200，人物是背景图的1/10高。</p><p>已经完成地图贴图和角色控制移动了</p><p><imgsrc="https://s3.bmp.ovh/imgs/2024/11/15/bcdd7d3e0c3d5c2f.png" /></p><p>然后需要：</p><ul><li>定义平台，实现站立、主动落下</li><li>人物贴图轮播，实现动态效果</li><li>敌方贴图</li></ul><p>定义了个枚举类，给不同的状态区分不同的图片组。</p><p>感觉得用上GameClock类来控制帧率了，不然不好贴图，每帧一张图片，人物、特效的贴图都需要更新，需要统一帧率和时间。</p><blockquote><p>明天白天进“大观园”开眼界，晚上再写</p></blockquote><h1 id="section-3">11.16</h1><p>下午四点，开工。</p><p>先弄好帧率</p><blockquote><p>使用elapsedTime记录当前时间，在update时传入距离上次更改贴图的时间，如果大于了deltaTime，就根据当前状态切换贴图。</p><p>这样相当于实际每秒有几百帧，极短时间内有好几帧都相同，以此降低了看到的整体帧率，整体帧率由各对象的deltaTime决定。</p></blockquote><p>但是切换到哪一张呢？站立、跑动、空中姿态需要轮播；防御需要按顺序切换后停在最后一张图片；释放技能、受击只播一轮，结束后回到站立姿态；击飞则是受击后停在最后的状态直到重新站起</p><p>所以有：</p><ul><li>只要状态不变，就一直轮播</li><li>只播一轮然后停在最后一帧</li><li>只播一轮然后必须切换到其他状态</li></ul><blockquote><p>仅播一轮最后也会停留，比如释放技能，最后一两帧为了营造慢动作效果，切换时间更久</p></blockquote><p>每组贴图都需要一个变量记录当前的图号，以便按顺序切换贴图——可以状态切换时置零唯一的图号变量。</p><p>每个角色对应的贴图不同，所以要根据Player的角色名来选择相应的loadImage方法，加载正确的资源，同样的，每个角色的技能组各不相同，所以还需要统一的技能分类对应到正确的技能组。</p><p>如果给每个角色都重写一遍函数，好像有点冗余和复杂了，所以！得重构！</p><h4 id="第一次重构">第一次重构</h4><ul><li><p>Character类变抽象类，现有的实现具有共通性的保留，其他的变纯虚函数让子类单独实现</p></li><li><p>取消单独设置的Player类和Enemy类，而为每个角色都建立一个类，继承Character</p></li><li><p>对应的，Game类中的Player和Enemy改为Character类的智能指针，用来多态。</p></li><li><p>利用工厂模式，新建CharacterFactory类，在Game主类中将原来的Player类和Enemy类改为两个Character类型的成员Player和Enemy，游戏开始前通过选择类型，从工厂中获得选取的子类赋给player和enemy（<strong>多态的典例应用场景啊！大一学的竟然忘光了😭）</strong></p></li></ul><blockquote><p>特效类和Effect和地图类Map也可以这样，但是先就一个地图做着吧，如果后面有时间加地图就把Map类也这样重构了。</p></blockquote><p>BUG记录：</p><ul><li>重构完贴图失败，原因未知——Texture用了个局部变量，对SFML的机制不了解，set给sprite的并不是sprite保存的，如果texture被释放，sprite的纹理就没了。</li><li>运动出问题，左右走可以，跳可以，跑跳就会直接飞天——状态机没设置好</li></ul><p>状态转移的时候还需要更谨慎和精细，最好能把状态转移都集中到一个地方，但是键盘事件处理和位置信息处理分别在process和update层，没法集中，也许可以改架构。</p><p>明天再写。</p><h1 id="section-4">11.17</h1><p>贴图基本完成，接下来是：</p><p>方向：</p><p><del>引入敌人==完善双角色的视图逻辑和边界设置==设计人物作为敌人时的逻辑</del>==方向状态转移==方向变化时镜像素材==方向</p><blockquote><p>确实是改一个小功能就要大改整个项目🥲</p></blockquote><p>敌人如何行动呢？要想象是另一个玩家在与我对战，他会如何行动，我要为他设计操作接口。</p><p>玩游戏的流程是：</p><p>看画面（获取地图、敌方信息）==&gt;心中指定策略（根据信息，进入状态机转移状态）==&gt;按键控制，实施策略（敌方调用控制方法）——&gt;进入update，使行为真正实施到游戏系统中——&gt;绘制画面==&gt;重新循环</p><p>所以，敌方的获取信息和行为的状态机都放在process层，敌方需要map信息和player信息，凡是在画面上能展示的，敌方都能够获取。</p><p>此时敌方已经不仅仅是enemy了，而是另一个更类人的事物，于是新建类<code>AIController</code>表示与玩家对战的智能，该智能操纵Game中的enemy与我操纵的player对战。</p><blockquote><p>为了打字简单，命名为Controller好了</p></blockquote><p>经过：</p><p>引入敌人、完善双角色的视图逻辑和边界设置、设计人物的方向状态转移、方向变化时镜像素材</p><p>最终实现了人物自动面对面，以下是错误示范：</p><figure><img src="https://s3.bmp.ovh/imgs/2024/11/17/dd1b87ffe84fa53d.png"alt="闹别扭但不愿打架的Gaaras" /><figcaption aria-hidden="true">闹别扭但不愿打架的Gaaras</figcaption></figure><p>然后需要：</p><ul><li>做完地图</li><li>做更多的人物</li></ul><h1 id="section-5">11.18</h1><p>碰撞检测：</p><ul><li>人物与人物——player和enemy都需要互相判断，或者先判断的传递结果给另一个</li><li>人物与平板——player和enemy都需要与所有的platform判断是否在其上</li><li>人物与视图边界——视图会获取player和enemy的坐标动态扩大，player和enemy也会根据视图限制运动</li><li>人物与特效——特效类尚未开发，暂时忽略</li></ul><p>都需要在update层判断。都是人物的，都传给人物的update</p><p>似乎原游戏存在重量，人物相推速度变化不一致，有的减半，有的更慢这里都设置为一样的重量，如果有人物挡道，则速度减半</p><h5 id="人物碰撞">人物碰撞：</h5><ul><li>从垂直方向碰撞，依据相对位置互斥，直到无重叠，各自垂直速度不变</li><li>从水平方向碰撞<ul><li>如果碰撞方有速度，则减半，同时被撞方互斥，与碰撞方一起运动，直到不重叠</li><li>如果碰撞方无速度，依据相对位置互斥，直到无重叠</li></ul></li></ul><blockquote><p>角色互斥效果类似于引力和库仑力，与距离平方成反比，越近互斥速度越快</p><p>因碰撞产生的运动不改变当前运动状态，比如正在站立或跳跃，被碰撞获得水平速度，不会转移为running状态，因此贴图组不变</p></blockquote><p>🤣🤣🤣，如果我闲的没事的话，一定会录个gif贴出来，照着引力公式写，结果写出楞次定律的效果了，来拒去留🤣。（没有在消除碰撞后消除掉加速度）</p><p><del>为了测效果，一不小心打了一个多小时，原游戏的人机也没那么厉害，但是也足够厉害了</del></p><p>平台的判定有问题，站上去就被锁住不能离开了，移速也变慢了，应该还是状态转移的错误：必须在站立或跑动状态下离开平台才转移为下落/跳跃状态。再将按键效果的实施提前到平台效果前，并且如果还有上升速度，就不检测平台。这样就能丝滑地飞檐走壁啦！</p><p>继续搞定人物相斥的功能：在速度生效后取消掉速度就可以了：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">position.<span class="hljs-keyword">x</span> +<span class="hljs-operator">=</span> velocity.<span class="hljs-keyword">x</span><span class="hljs-comment">;</span><br>velocity.<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;// 取消掉速度</span><br></code></pre></td></tr></table></figure><p>然后把系数调大一点，看似完成，实际有大bug，当把对方推到角落后，斥力竟失效了，待越过对方，竟直接将对方弹射出去?!😭</p><p>原因未知，把update的顺序调整了一下就过了，似乎是智能指针的问题，前一轮循环赋的速度，到下一轮循环就没了，不得已只能在同一轮循环中处理掉碰撞产生的速度。</p><p>之前用队列替代即时检测实现二段跳，但是现在需要检测多键了，事件队列没办法检测多键，而且改为即时检测多键似乎也有点问题，要测试一下<strong>即时检测多键的可行性</strong>和<strong>队列检测单键+状态转移实现多键操作的可行性</strong>。</p><p>连续按键盘间隔一般为0.1秒，而当前的帧率，每0.1秒平均有90帧，也就是90次主循环，垂直速度减去90次GRAVITY，那么只需要在按下K时限制垂直速度必须小于<span class="math inline">\(v_{init}-90\times g\)</span>即可，若大于则不执行逻辑。</p><p>判断完状态合法后，让纵坐标下移平板碰撞误差多一点的距离即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Character::down</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (currentState == CharacterState::Stand || currentState == CharacterState::Running) &#123;<br>currentState = CharacterState::Jumping;<br>currentFrame = <span class="hljs-number">0</span>;<br>position.y += TOLERANCE + <span class="hljs-number">0.01f</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终还是使用即时查询，添加了防连点机制，队列暂时舍弃。</p><h1 id="section-6">11.19</h1><p>注意到程序运行时电脑很烫，目前没有限制帧率，都是把核显跑满的，切换Nvidia的独显也是跑满，10秒钟就70度了，风扇呼呼转。但是限制帧率后，当前的数值就全乱了，全部开了慢速，限制100帧都还是慢。暂时不调整，后面加了操作可能帧率还会降，到时候快写完了再限制帧率调整数值。</p><p>找到了原游戏的仓库，从里面找到了游戏的源码和资源，源码是用ActionScript写的，规模比较庞大，借鉴难度可能和自己写差不多，于是放弃借鉴。</p><p>经过探索，发现游戏的人物资源等都是.swf文件，用于Flash的，于是下载了个swf的反编译工具JPEX，把人物素材提取出来，所幸素材比较齐全，人物、特效、音效、图像都在里面，不过普通的通用灰尘特效和冲刺特效没有。</p><p>里面的图片相对分散，缺乏组织和顺序，所以从sprite里提取，似乎每个人物包都会有一个展示所有操作的sprite动画，包含一千多张png图片，导出后发现尺寸很怪异，明明实际大小只有100<em>100左右，但是图片却是2600</em>1300那么大，所以又让GPT写了个自动裁切图片的python脚本，总算把人物素材搞齐了。<del>提取了两个人物软件就崩了啊啊啊啊</del></p><p>然后需要给素材分好组，确定是什么操作。</p><p>分组时突然发现，游戏实现前后摇的方法竟然是插入连续相同帧，比如普攻3段后有后摇，在普攻3段后就会有连续多张相同姿势的帧。甚至频闪效果都是一帧有一帧无来实现的</p><p>所以，也许可以以贴图播放时间来决定状态转移，而不是以状态转移来决定贴图变化。</p><p>大招的束缚效果是否被防御、是否命中，效果都会不同，还是需要根据状态来决定贴图。</p><p>那么至此这周的人物就算基本完成了，差个冲刺姿态和招式动作，加个<code>vector&lt;sf::Texture&gt;</code>和配套的贴图切换case、按键控制就行。</p><h1 id="section-7">11.20</h1><p>整理好素材，分门别类，然后写好loadImage函数，注意文件前缀常数化和文件下图片数量，可以问问GPT有没有什么更好的load方式。</p><blockquote><p>保存了目前能运行的分支，但是git操作还是不熟练，又出问题了，两个平行的分支竟然冲突了，合并来合并去，结果推送不上去了QAQ。</p></blockquote><p>GPT写了更集成的load方式，但是load进去之后，之前想到的问题出现了，原本的素材图像很大，播放时人物始终在中间，位置没有动。如果自动裁剪之后，因为坐标始终设置为底部中间，所以人物就无法保证在中间了，要等比例裁剪才行，不然素材对不齐，白整了一天啊😭。</p><p>重来：先把素材导出，然后确定裁剪方法，从所有等大小图片中确定一个相对原点，程序中都以这个点为参照点，素材都是朝右的，所以以左下角为参照点，右边有图像就保留，没有就截掉。对应地，程序中的镜像逻辑也需要修改，要保证镜像后参照点位置不变，不能转向后发生突变。</p><p>裁剪恐怕需要针对每张图片做定制化方案了，只定制了stand、animation、run。感觉工作量有点大，要简化，不然整理素材都得两三天。还要好好设计一下裁剪的算法</p><p>走路的时候突然有思路了：</p><ul><li>仍然采用自动裁剪空白区域的脚本，保留原图片全部的有效信息，但<strong>同时要记录中心点在裁剪后图片的相对位置</strong>（依照SFML的源点定义记录，比如sprite采用左上角作为原点，就记录中心点相对于图片左上角的坐标），依照图片的文件名序号，依次保存在文件中（txt、json、甚至excel等等）</li><li>在Character类中仍然保留一堆Texture，加载方式改变，不分开调用函数了，因为所有的图片都不会再细分各种文件夹，而是在类中使用区间来指定图片，比如[1,9]是stand状态的图片，就加载给standTexture.</li><li>最最核心的：<strong>每个Texture都要配一个Vector2f，即中心点的相对坐标</strong>，从第一步产生的文件里面读取出来，用于sprite纹理的原点重设，从而实现人物的原点不变，就解决了素材错位问题。</li><li>每个子类仍然需要重写loadImage，可以不重写，但要单独指定每个子类各个操作对应的素材号区间。</li></ul><h1 id="section-8">11.21</h1><p>裁剪好了图片，得到了相对坐标表。然后要得到各动作的图号区间，改写load方法，通过表重设sprite的origin。又有问题，图和图号没建立关系，load进程序后就没有图号了，关联就没了。</p><p>还得重构：需要建立“状态-图号区间”、“图号-图片”、“图号-原点坐标”的关系，把图片都拉通存在一个vector里，stand、jump都改<code>pair&lt;int, int&gt;</code>，origin不变。得到状态==&gt;索引图号==&gt;得到图片和原点==&gt;完成sprite更新</p><p>好消息：完成了</p><p>坏消息：原点坐标有误差，还是会抽搐，而且原点不是脚底，平面高度都错了</p><p>😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭</p><p>太难了！！素材整理都花了两天时间了😭😭😭</p><p>GPT真神了！向其寻求减一，他说可能是同一帧内多次调用setOrigin方法可能导致异常，然后我把每帧默认调用的setOrigin放到了帧切换里面，就不抖动了！！太好啦！</p><p>经过这一通重构，update已经完全与人物子类解耦，直接提升到Character类层级，现在人物子类实现了0个接口，不过还是需要实现的，毕竟技能数值效果不同，发生的位移也不同。</p><h1 id="section-9">11.22</h1><p>完成其他任务，搁置一天。</p><h1 id="section-10">11.23</h1><p>晚上七点才开始，事情好多，不能像上周那样90%的空余时间都投在这上面了😰</p><p>之后的开发顺序是：</p><ul><li>完成各种招式的动画</li><li>完成招式与敌方的碰撞检测</li><li>引入技能条</li></ul><p>动画播放==&gt;无法控制+前后摇+无敌时间==&gt;冲刺</p><p>冲刺不能直接把x坐标加减，只是在几帧之内<strong>脱离键盘控制快速移动</strong>，中途以空白帧表示瞬移，实际仍然在移动。关键要实现状态的中断和转移，之后释放大招时也会有中途无法控制的时候。</p><p>经过实测，I的优先级最高，可以打断冲刺，复合键位则看绝对先后顺序，SL是幽步，中途不会被任何操作打断。但是我不开发幽步，所以废置SL键位，为了简化开发，放弃I打断L的操作。</p><p>无法控制状态为Default，脱离于常规状态，此状态下无法通过键盘操控角色。</p><blockquote><p>正在变复杂和混乱，我想到可以用实现状态机的一些C++库来开发游戏的状态机，这样在后面开发敌方状态机的时候可能会更容易更清晰一些。</p><p>但是学习状态机的库需要时间，还是学一下吧，磨刀不误砍柴工，也许这会极大简化后续开发，也许这只是进一步复杂化问题，总之，先看一下，今晚的时间就用于学习C++的状态机相关API好了。</p></blockquote><p>整体上看，改变人物状态的地方有：</p><ul><li>键盘控制（ADJKUIS）</li><li>2D世界的物理特性（下落和站立）</li><li>敌方的行为（攻击命中）</li></ul><p>而角色的position、velocity等在状态不变时也会改变，与状态无关，状态用于控制贴图、限制键盘操作逻辑。贴图有单独的方法，输入状态，输出贴图；键盘也是，输入当前状态和键盘输入，输出velocity变化以及下一步状态。</p><p>开始状态为Stand；</p><p>AD键控制左右移动，如果当前在平台上，则切换为Running状态，动画改变，如果在空中处于跳跃Jump或下落Fall状态，则不改变状态，只造成位移效果。释放AD键则取消位移效果，同时离开Running状态。</p><p>K键单独按下且跳跃次数有剩余且当前状态为Stand或Running则进入Jump状态，同时获得向上的速度</p><p>SK同时按下且位于平台上且处于Stand或Running状态时，转为Fall状态，发生向下的极短位移以脱离平台向下坠落</p><h1 id="section-11">11.24</h1><p>感觉状态机可行，结果导入库的时候寄了，明明说的是导入hpp文件就行，结果导进去一堆报错。耗费3小时，配置仍未成功，放弃使用状态机，采取if-else堆砌的方式😞。</p><p>通过打补丁的方式，写好了冲刺。接下来是引入技能动作。先写个平A，每个技能都不好写，各有特色，机制复杂。</p><p>平A的动画和控制主要就是连续J的判定和状态转移，至少现在动画不错。为了展示工作量，先不写碰撞判定，把各种动画写完吧。</p><h1 id="section-12">11.25</h1><p>防御状态和AD一样，按着才生效，不按就不生效，而且放开之后还有松开的动画，松开的几帧还不能AD，但是已经不是S状态了，可以被揍。S状态被揍还要扣chakra。</p><p>即时查询没有按键释放的事件，所以用状态残留来判断是否释放。（bug留给之后，先实现再说）</p><p>复习了一下SFML的教程，发现SFML建议我不要经常切换纹理，会造成显卡负担，我仔细了解了一下，原来贴吧的素材以大图的方式给是有原因的啊，所有的动画帧在同一张图上，这叫纹理图集，通过滑动窗口的方式切换纹理，这才是性能最高的方式。（重构任务+1😭）</p><p>简单的动态都写完了，为了之后开发，先搞纹理图集。</p><h5 id="重构纹理图集">重构：纹理图集</h5><p>纹理图集需要将所有动画帧放在一张大图上，sections和origins不变，原来的textures变成窗口的坐标，另外单开一个texture存大图。有之前的基础，重构还是挺简单的，只需要改load方法和改setTexture为setTextureRect就可以了</p><p>完善了S系列的状态之后，我爱罗的J、SJ、SU、S、WJ、L、ADK就都完成了</p><p>接下来的工作路线是：</p><p>把有特点的方法迁移到子类==》特效图片整合==》特效类==》特效的图片整合进大图==》完成远程攻击和追身攻击</p><p>特效图片原点不规则，不是在正中心，迷惑，得一组一组找中心才能用分割程序。还差一个SI的，弄完再把空帧的坐标补了就完成第二步了。</p><h1 id="section-13">11.26</h1><p>特效图片整合完了，编写特效类，为了正确展示，基本的成员得有，沿用currentFrame。由于特效可能属于不同的技能，每个人物具有单独特效的技能又不一样，开个Map，加个枚举类当索引，有就放map里，没有就不放，切图的时候先检查一下map有没有就行了。</p><p>特效类定义完了，得让角色能打出特效，以及特效能动飞或者追身。</p><p>又有问题，如果一个任务的wu是追身，另一个是远程，那怎么分辨呢？还是要给每个人物写特效类，贴图可以通用，但是逻辑没法通用。</p><p>触发逻辑参照人物，像触发人物动作那样，用人物状态触发特效。</p><p>又想到问题了，一个人物不一定只有一个特效，即使是u也可以连发，那是在人物里开特效池还是特效里面开组呢？在人物类里面开特效池比较好。开个vector，每个都先构造了，设置成Default。放技能就拿出一个Default来用，绘制的时候就批量绘制。</p><h1 id="section-14">11.27</h1><p>U的特效打不出来，很奇怪，调试时明明都看到坐标变化和render调用了，但是没有。</p><p>今天没什么进度。</p><h1 id="section-15">11.28</h1><p>U的特效没对齐，延后11帧再播放特效。位置偏移量硬编码。完成U。KU、WI_before直接贴图。</p><p>然后是追身系列技能。I只获取x，而SI获取完整坐标。SIbefore的追身写好了，写I的时候发现I没有before，将就把miss的倒放。</p><p>现在所有招式都写完了，把人物的特效改为特效池，然后开发招式与敌人的碰撞检测。</p><p>在自己的update里面新增updateWithEffect，然后传入敌方的位置。</p><h1 id="section-16">11.29</h1><p>将人物的特效改为特效池之后，实际帧率断崖式降低，竟然只有25帧左右，非常卡，尝试优化优化，如果还是这么低就只能放弃多特效了。</p><p>帧率计算一直用的0.1秒，所以实际帧率一直是几百甚至上千帧，离谱了。</p><p>而且多次测试，发现帧率其实是变动的，很不稳定，使用率低的时候就很流畅，一旦多任务忙起来就会变慢，甚至在游戏过程中都会时快时慢。还是把帧率限制一下吧，天晴了，写这玩意火气都没那么大了🌞。差个WU，给补了。</p><p>现在需要：弄好特效池=》特效与人物的碰撞判定=》hit和kick的状态转换=》hit和kick的击飞位移=》加入仙鸣</p><p>攻击判定，要有延后，得能躲过去，要给判定函数滞后的位置信息，但是帧内好像没区别，总会先更新一个人物，再更新另一个人物，同一帧内的顺序好像不太大，看状态转换图而定吧，应该会有个优先级的。</p><p>检测到碰撞后，得让敌人被击打或者击飞，不能直接在自己的操作里修改敌人的状态，得调一个敌人的方法来，受击也有位移，击飞更有位移，所以实际是给对手一个速度，所以受击和击飞函数都得接收一个力也就是速度，像冲刺那样，不可操作，速度不可抵消，只能自行消失。冲刺是贴图播放完就结束，受击时间也是固定的吗？测试一下，是的，受击时间都是一致的，但是存在多段攻击，像I系的前摇、SU的流沙，都会在持续时间内每次更新给予敌人一次伤害判定。</p><p>如果在技能更新的每一帧都检测碰撞，多段伤害好办，但是单段伤害就会麻烦，因为不能通过敌人的状态来判断是不是已经受到了当前这个技能的单段伤害，敌人处于Hit状态，有可能是当前技能已经造成了单段伤害正在位移，也可能是之前的招式造成的Hit状态还未结束，Hit状态仍可以被击打，但是当前的招式无法得知是否已经造成了伤害和位移效果。</p><p>给敌方写一个命中效果（加速度，打成受击还是击飞，消耗多少chakra条）=》在己方判定与敌方碰撞后，给己方施加这一命中效果=》处理后续的状态转移逻辑，保证受击状态优先</p><p>敌方还得有受击效果定义，是静态的，还能写成文件config。</p><p>攻击状态都排除人物大小就可以了，而人物都位于左下角，取min(人物h，锚框h)，宽度取个平均值写死，排掉做小脚</p><p>还要排除防御状态，还得写chakra机制.</p><h1 id="section-17">11.30</h1><p>碰撞检测的矩形框计算错了，怪不得一直碰撞错误。</p><h1 id="section-18">12.1</h1><p>人物和人物的判定写了80%左右，还有前后摇误判的问题，特效还没出来，然而已经判定被攻击了。</p><p>攻击效果还有很大问题，主要是多重受击的问题。</p><p>原型应该是有一个攻击判定冷却时间，短于任意两个招式的连接时间和单个招式的持续时间，但是长于每帧的时间。在攻击碰撞检测那里加个攻击判定的定时器，限制攻击检测的频率。这样可以实现SU的多段攻击。</p><p>记录上一段伤害来源，hit状态结束后清空来源记录，受到伤害前对比来源，如果相同，则不受重复伤害。但对于SU这样多段伤害，可以不记录来源或者不用来源屏蔽伤害。</p><h1 id="section-19">12.2</h1><p>继续写碰撞检测，与特效的碰撞和与人的差不多，但是获取效果的函数有问题，是依照攻击发出方的即时状态决定给什么效果，但对于U，特效碰到的时候，状态早就不是U了，甚至可以替身攻击（其实作为特性还挺有新意的。。）</p><p>把状态对齐，转成int，统一伤害来源。</p><p>现在还差各种攻击的击飞速度设置，击倒还要细分，落地并弹起就不能再水平位移了，加个帧数限制，这个数值是人物类的静态数值，各个不同。</p><p>kick的击飞并不是按播放时间来的，或者说，不同的招式击飞的距离不同，SJ明显更远，3J适中，U最小。飞的动画只有7帧，很短，速度过大很容易产生突变感。</p><h1 id="section-20">12.3&amp;12.4&amp;12.5</h1><p>把仙鸣加进去了，跟Gaara相同的部分兼容得很好，不同的部分全部失效，等着写就行。</p><p>加了个丐版选人界面，字体没找到，随便上了一个，背景没有。</p><p>周三四没什么进度，备考计网+写作业+安恒星火的答辩+打球</p><blockquote><p>碎碎念：</p><p>答辩被拔尖班的科研大手子用论文K爆了，也许我还应该再去接触下科研，对于科研和后端开发的好恶程度差不多，那显然是科研更优。</p></blockquote><h1 id="section-21">12.6</h1><p>把gaara的大招效果bug修了，顺带解决了视图的平滑过渡问题。</p><p>但是还有大招miss没写，以及大招I和SI碰到S的快速爆条</p><h1 id="section-22">12.7</h1><p>今天把NarutoS的控制写了。后面就写各种动画和可视化。视图平滑带来的初始化问题也需要修一下。</p><p>把NarutoS的所有攻击动画修好了，包括分体攻击KI和特效，命中效果没写完，因为仙鸣的碰撞判定和Gaara很不一样，不能复用。</p><p>由于只写两个角色，所以只得<u>放弃通用性</u>，为两个角色针对性地写对于另一个角色的碰撞判定了。</p><h1 id="section-23">12.8</h1><p>写完了全部的技能效果。测试一下，存在BUG，<strong>在NarutoS的U冲刺时如果起跳，可能会直接飞天</strong>。但是复现不是次次成功，暂时不修。</p><p>至此，战斗部分基本完成。</p><h1 id="section-24">12.9</h1><p>开始写界面。</p><p>加了个开始界面，大概能用，接下来写血条气条之类的。</p><h1 id="section-25">12.10</h1><p>对于UI，有固定元件和动态更新元件，固定的元件只需要在一开始设定好position，之后通过遍历绘制；动态更新的元件每次都需要根据人物状态来选择不同的sprite绘制。也许可以在动态更新的时候就保留更新的sprite，在绘制时直接绘制保存的sprite。</p><h1 id="section-26">12.11</h1><p>加了震屏，有视图机制，实现起来很容易，用了下事件队列，又学到了，好方法。还有打击感的暂停，暂停有：</p><p>全局暂停：</p><ul><li>某方受击</li><li>某方被击倒</li></ul><p>排除性暂停：</p><ul><li>一方释放大招，另一方暂停，特效也暂停</li></ul><p>仍然采用相同的事件队列方式实现。</p><p>大招时停的背景图没找到</p><p>敌方AI规则：</p><ul><li>在同一高度<ul><li>距离远：放U/冲刺过去/跑过去</li><li>距离中：SU/U</li><li>距离近：SJ/J/WJ</li><li>如果是gaara，概率放WI、I，若有SI则立马释放SI</li><li>如果是naruto，概率U和I，若有SI则绝对距离进了立马释放SI</li></ul></li><li>在不同高度<ul><li>根据人物来：gaara<ul><li>敌人低：WU/I/KU，或主动下落</li><li>敌人高：WU/I/WJ，或主动跳跃</li></ul></li><li>naruto<ul><li>敌人高：WU+WUU/SJ/WJ，或SI</li><li>敌人低：KU/KI，或主动下落</li></ul></li></ul></li><li>敌方在墙角：<ul><li>KU连，每两套停顿一下</li></ul></li><li>敌我同时跳跃且位置合适：KU/KI</li><li>检测到敌方攻击：概率灵敏S+SJ/SU反击</li><li>敌方在空中：优先跳跃追击KU，概率使用追身技</li></ul><h1 id="section-27">12.12</h1><p>敌方AI很难写啊，周末没写出来就改数值了。if-else凑不出来就没招了，状态机行为树也就听个乐，写不出来，代码能力太差了。</p><p>用if-else凑出来的很呆，偶尔能够按我的想法打出不错的连招，但是绝大多数时候一动不动，或许可以设置一个固定的行为模式。一套打完再开另一套，有自动转向机制，不至于很呆。</p><p>改成了双人的，效果很好。</p><p>加了一些音效和bgm。</p><p>也许，可以初步完工了！！！！</p><p>后面修改一下飞天的bug，改一下双人的键位，把2p的键位弄好，有时间有闲心可以多写几个地图。</p><p><imgsrc="https://s3.bmp.ovh/imgs/2024/12/12/698013c36a3ce4d7.png" /></p><p>4503行，有效代码3839行，算是迄今为止自己写的最大的工程了。(<del>面向GPT搓的代码统计小工具，函数统计结果是错的</del>)</p><h1 id="section-28">12.14</h1><p>加点地图，做个选地图界面，游戏结束的字体改小一点点。</p><p>把键位bug修了，选人界面改成可以选相同角色，黄框1P选，蓝框2P选，2P的角色渲染粉红一点</p><p>下午三点半，全部完成。收工！</p><p>录视频，粉饰视频，写报告。</p><h1 id="section-29">12.15</h1><p>完工！</p>]]></content>
    
    
    
    <tags>
      
      <tag>SFML</tag>
      
      <tag>游戏开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在hexo fluid主题下以Netlify方式添加twikoo评论插件</title>
    <link href="/2024/11/05/%E5%9C%A8hexo-fluid%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%B7%BB%E5%8A%A0twikoo%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/"/>
    <url>/2024/11/05/%E5%9C%A8hexo-fluid%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%B7%BB%E5%8A%A0twikoo%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>刚开始是用huggingface部署的，但是突然崩了，数据库的数据都在，但是评论失败+无法登录管理面板+历史评论全寄。打开huggingface一看，一直preparingspace，评论发回的响应也是preparingspace，而且huggingface部署方式还不能配置邮件提醒，所以干脆换Netlify了，正好记录一下。</p></blockquote><p><a href="https://twikoo.js.org/">Twikoo官网</a></p><p>本博客记录的步骤在Twikoo官网上都有记录，原文链接为<ahref="https://twikoo.js.org/backend.html#netlify-部署">云函数部署 |Twikoo 文档</a></p><p>步骤总体分为三步：</p><ul><li>在MongoDBAtlas上创建数据库，获取<strong>数据库连接字符串</strong></li><li>使用Netlify部署<ahref="https://github.com/twikoojs/twikoo-netlify">twikoojs/twikoo-netlify:Deploy twikoo to Netlify</a></li><li>修改_config.fluid.yml文件</li></ul><h1 id="获取数据库连接字符串">获取数据库连接字符串</h1><blockquote><p>推荐阅读原文：<ahref="https://twikoo.js.org/mongodb-atlas.html">MongoDB Atlas | Twikoo文档</a>，图文并茂</p><p>第5步的密码就是MongoDB Atlas账号的密码，可通过邮箱重设</p></blockquote><ol type="1"><li>申请 <a href="https://www.mongodb.com/cloud/atlas/register">MongoDBAtLas</a> 账号</li><li>创建免费 MongoDB 数据库，区域推荐选择离 Twikoo 后端（Vercel /Netlify / AWS Lambda /VPS）地理位置较近的数据中心以获得更低的数据库连接延迟。如果不清楚自己的后端在哪个区域，也可选择<code>AWS / Oregon (us-west-2)</code>，该数据中心基建成熟，故障率低，且使用Oregon 州的清洁能源，较为环保</li><li>在 Database Access 页面点击 Add New Database User创建数据库用户，Authentication Method 选 Password，在 PasswordAuthentication 下设置数据库用户名和密码，建议点击 Auto Generate自动生成一个不含特殊符号的强壮密码并妥善保存。点击 Database UserPrivileges 下方的 Add Built In Role，Select Role 选择 AtlasAdmin，最后点击 Add User。</li><li>在 Network Access 页面点击 Add IP Address 添加网络白名单。因为Vercel / Netlify / Lambda 的出口地址不固定，因此 Access List Entry 输入<code>0.0.0.0/0</code>（允许所有 IP 地址的连接）即可。如果 Twikoo部署在自己的服务器上，这里可以填入固定 IP 地址。点击 Confirm 保存</li><li>在 Database 页面点击 Connect，连接方式选择Drivers，并记录数据库连接字符串，请将连接字符串中的<code>&lt;username&gt;:&lt;password&gt;</code> 修改为刚刚创建的数据库<code>用户名:密码</code>。</li><li>默认的连接字符串没有指定数据库名称，Twikoo 会连接到默认的名为<code>test</code> 的数据库。如果需要在同一个 MongoDB里运行其他业务或供多个 Twikoo 实例使用，建立加入数据库名称并配置对应的ACL。</li></ol><h1id="使用netlify部署twikoojstwikoo-netlify-deploy-twikoo-to-netlify">使用Netlify部署<ahref="https://github.com/twikoojs/twikoo-netlify">twikoojs/twikoo-netlify:Deploy twikoo to Netlify</a></h1><blockquote><p>原文链接：<ahref="https://twikoo.js.org/backend.html#netlify-部署">云函数部署 |Twikoo 文档</a>。推荐阅读原文</p></blockquote><p>到原文第9步后，根据自己设置的域名得到环境ID（<code>envId</code>）：<code>https://你设置的site name.netlify.app/.netlify/functions/twikoo</code></p><h1 id="修改_config.fluid.yml文件">修改_config.fluid.yml文件</h1><p>打开本地的_config.fluid.yml文件，Ctrl+F搜索twikoo，找到：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">comments:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>  <span class="hljs-comment"># The specified plugin needs to set the necessary parameters at the same time</span><br>  <span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">twikoo</span><br></code></pre></td></tr></table></figure><p>在<code>type</code>处填写"twikoo"。</p><p>再Ctrl+F搜索twikoo，找到：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Twikoo</span><br><span class="hljs-comment"># 支持腾讯云、Vercel、Railway 等多种平台部署</span><br><span class="hljs-comment"># Based on Tencent CloudBase</span><br><span class="hljs-comment"># See: https://twikoo.js.org</span><br><span class="hljs-attr">twikoo:</span><br>  <span class="hljs-attr">envId:</span> <br></code></pre></td></tr></table></figure><p>在<code>envId</code>处填写上面的<code>https://你设置的site name.netlify.app/.netlify/functions/twikoo</code></p><p>最后，在需要添加评论的页面首部添加<code>comment: 'twikoo'</code>即可为页面添加底部评论区。</p><p>也可以在<code>_config.fluid.yml</code>里面设置，方法为：在对应页下的comments下将enable设为true，type设为twikoo。</p><p>比如，为关于页添加评论，就在<code>/source/about/index.md</code>的首部加一行<code>comments: 'twikoo'</code>，或者在<code>_config.fluid.yml</code>里设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">twikoo</span><br></code></pre></td></tr></table></figure><p>(不建议直接cv，如果不知道啥是yml就先搜搜，然后就懂了)</p><p>至此，部署成功，刷新博客后测试效果吧！</p><h1 id="后续设置及版本更新">后续设置及版本更新</h1><p>部署好之后，打开博客中任意一个带有评论的页面，会看见右下角有一个齿轮图标，如果没有就在昵称栏输入任意字符并回车就会出现。然后进入管理区，先设置密码，然后进去根据指示设置就可以了。</p><blockquote><p>twikoo的指示写得很好👍，应该都看得懂</p></blockquote><p>版本更新方法见：<ahref="https://twikoo.js.org/update.html#针对-netlify-部署的更新方式">版本更新| Twikoo 文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点评的缓存问题</title>
    <link href="/2024/10/10/%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/10/10/%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>目前处于烂尾状态。。。我很抱歉。。</p></blockquote><h1 id="缓存更新">缓存更新</h1><p><imgsrc="https://s3.bmp.ovh/imgs/2024/11/03/53c8371b2d78d0a9.png" /></p><ul><li>等redis内存满了自己淘汰</li><li>超时</li><li>主动更新</li></ul><h6 id="主动更新">主动更新</h6><ul><li>更新数据库时更新缓存</li><li>缓存与数据库整合</li><li>调用者只操作缓存，由其他线程异步将缓存持久化到数据库中，保证最终一致</li></ul><h5 id="先删缓存还是先操作数据库">先删缓存还是先操作数据库？</h5><p>先操作数据库，再更新缓存。</p><blockquote><p>缓存操作比数据库操作快；数据库读比写快：所以先删缓存，在数据库update完成前，可能会导致期间的查询不一致。</p></blockquote><h1 id="缓存穿透">缓存穿透</h1><blockquote><p>客户端的请求在缓存和数据库中<strong>都不存在</strong>，<strong>缓存永远不会生效</strong>，请求都会打到数据库上，次次查询数据库然后返回不存在。</p></blockquote><h3 id="解决方法">解决方法</h3><ul><li>布隆过滤器<ul><li>不存在就一定不存在，存在可能会误判</li><li>快速</li></ul></li><li>缓存空对象<ul><li>实现简单，但是内存消耗且可能不一致</li><li>需要给空对象设置TTL(Time To Live)</li></ul></li></ul><h1 id="缓存雪崩">缓存雪崩</h1><blockquote><p><strong>同一时段，大量缓存的有效期到期失效</strong>，或者redis宕机，导致大量请求短期内集中打到数据库。</p></blockquote><h3 id="解决方法-1">解决方法</h3><ul><li>TTL随机：N+n模式，n随机</li><li>集群</li><li>多级缓存</li></ul><h1 id="缓存击穿">缓存击穿</h1><blockquote><p>热点key问题，一个被<strong>高并发访问</strong>并且<strong>缓存重建复杂</strong>的key突然失效，在瞬间给数据库带来巨大压力。</p></blockquote><h3 id="解决方法-2">解决方法</h3><ul><li>互斥锁</li><li>逻辑过期</li></ul><p><imgsrc="https://s3.bmp.ovh/imgs/2024/11/03/44eddbc61753000c.png" /></p><h4 id="互斥锁业务流程">互斥锁业务流程</h4><p><imgsrc="https://s3.bmp.ovh/imgs/2024/11/03/0aaa594f1bfc8ee7.png" /></p><h4 id="逻辑过期业务流程">逻辑过期业务流程</h4><p><imgsrc="https://s3.bmp.ovh/imgs/2024/11/03/11e420ea7f4b894e.png" /></p><p>逻辑过期需要<strong>缓存预热</strong>：</p><p>注意到逻辑过期如果一开始缓存未命中，就会直接空。</p><p>因为是防止打到数据库，所以也不会因为缓存未命中而去查数据库。</p><p>所以需要<strong>缓存预热</strong>，一开始的缓存中需要存在所需的数据，否则就会一直缓存击穿未遂而返回空对象。</p><h1 id="缓存预热">缓存预热</h1><p>黑马的视频里没有，自己试着加了一个，与逻辑过期一起使用。</p><p>由于缓存预热的数据具有特殊性，所以不写在<code>CacheClient</code>这样的通用工具类中，而是写在<code>ShopServiceImpl</code>类里。</p><p>写好缓存预热方法如下，逻辑很简单，设置一个缓存标记，如果没有标记，证明缓存不存在，则预热：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 缓存预热</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">warmupCache</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询缓存内是否有内容</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_FLAG);<br>    <span class="hljs-comment">// 没有内容则预热缓存</span><br>    <span class="hljs-keyword">if</span>(StrUtil.isBlank(shopJson)) &#123;<br>        <span class="hljs-comment">// 先放flag</span><br>        stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_FLAG, RedisConstants.CACHE_SHOP_EXIST);<br>        List&lt;Shop&gt; shops = list();<br>        <span class="hljs-keyword">for</span>(Shop shop : shops) &#123;<br>            cacheClient.setWithLogicalExpire(CACHE_SHOP_KEY + shop.getId(), shop, <span class="hljs-number">30L</span>, TimeUnit.MINUTES);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后新建一个<code>CacheWarmupRunner</code>类，需要实现<code>ApplicationRunner</code>接口，加上<code>@Component</code>注解，然后注入<code>ShopService</code>，在类里面重写<code>run</code>方法，在<code>run</code>里调用<code>warmupCache</code>。</p><blockquote><p><code>ApplicationRunner</code>和<code>CommendLineRunner</code>：</p><p>CommandLineRunner 和 ApplicationRunner 都是 Spring Boot应用程序启动后要执行的接口，它们都允许我们在应用启动后执行一些自定义的初始化逻辑，例如缓存预热。</p><p><code>CommandLineRunner</code>和 <code>ApplicationRunner</code>区别如下：</p><p>方法签名不同</p><ul><li><code>CommandLineRunner</code>接口有一个<code>run(String... args)</code>方法，它接收命令行参数作为可变长度字符串数组。</li><li><code>ApplicationRunner</code>接口则提供了一个<code>run(ApplicationArguments args)</code>方法，它接收一个<code>ApplicationArguments</code>对象作为参数，这个对象提供了对传入的所有命令行参数（包括选项和非选项参数）的访问。</li></ul><p>参数解析方式不同</p><ul><li><code>CommandLineRunner</code>接口更简单直接，适合处理简单的命令行参数。</li><li><code>ApplicationRunner</code>接口提供了一种更强大的参数解析能力，可以通过<code>ApplicationArguments</code>获取详细的参数信息，比如获取选项参数及其值、非选项参数列表以及查询是否存在特定参数等。</li></ul><p>使用场景不同</p><ul><li>当只需要处理一组简单的命令行参数时，可以使用<code>CommandLineRunner</code>。</li><li>对于需要精细控制和解析命令行参数的复杂场景，推荐使用<code>ApplicationRunner</code>。</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>点评</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fw的碎碎念</title>
    <link href="/2024/10/10/fw%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <url>/2024/10/10/fw%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要看点评你想获得什么">为什么要看点评？你想获得什么？</h1><p>我想学习分布式的开发，想练习更多各种业务是如何实现的，是如何优化的。</p><p>可以记录下你写的过程中的问题，不一定要快，但是要学到学懂学透，能力最重要，得理解。</p><h1id="觉得点评烂大街做完也没什么用还得做另一个冷门的项目遥遥无期让你绝望从而拖延">觉得点评烂大街做完也没什么用，还得做另一个冷门的项目，遥遥无期让你绝望，从而拖延</h1><p>项目要学的都是业务，都是新的工具和技术，你现在学习分布式，学习redis如何使用，到了其他项目，你又得学mysql、mysqlplus、nacos、docker……各种工具和技术，五花八门，都是为业务服务。redis复杂，并且刚接触，所以耗时久。一步一个脚印，多写博客，记录学到的东西。增加动力。</p><h1 id="看不下去不想看">看不下去，不想看？</h1><p>没有认同感，没有价值感。</p><p>写博客有热情，因为觉得自己在输出，总会帮助到别人一点，最不济也能帮到以后的自己，有成就感，自己认为有价值。</p><p>但是看点评、外卖，烂大街，虽然确有其价值，但是自己无法认同，只是逼迫自己去看去学而已。</p><p>程序员是技术无产阶级，生产资料不是自己的。自己的生产资料，那就是自己运营的有偿服务了，代码属于自己，服务器属于自己，收入也属于自己。这很有价值感，开发的服务既利好了别人，同时也为自己创造了收入。还可以放弃收入开源，从而获得更大的价值感。</p><p>但是程序员大多开发内部软件，目的是给企业降低成本提高效率，最终目的呢？为资本家创造了更多的收益，让摸鱼的人变累。</p><p>该如何认同程序员呢？医生对着希波克拉底宣誓的时候，心里必然会有超越自我的无私和仁心，这种认同将帮助他们面对医院的鸡毛蒜皮和辛苦，他们这么累是在救人，是在不分高低贵贱地为人们减轻痛苦，很高尚，很有价值。但程序员呢？我是一个菜鸟，我没办法写出能够便利人们生活的产品，我对代码也没有原生的热情和喜爱，甚至我初始仅仅是闻着高薪的味儿来的。</p><p>我写这个有用吗？有什么价值吗？用搜索引擎搜了下，没有找到让我觉得成为一个程序员是一件有价值的事情的回答。"程序员挣很多钱让家人过得更好"，这当然是很高尚的理由，但我没法接受，这还不够有价值。</p><p>罢，程序员还是很有价值的，我还没理解到而已，让自己别这么菜，就有价值了，菜鸟当然没价值。</p><p>又浪费一个多小时。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github pages自定义域名失效解决</title>
    <link href="/2024/10/07/github-pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3/"/>
    <url>/2024/10/07/github-pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="问题背景">问题背景</h1><p>为GithubPages自定义域名后，总是隔三岔五地失效，其实是每次<code>hexo d</code>之后就会失效。</p><h1 id="原因">原因</h1><p>原因在于，当在<code>YOUR_NAME.github.io</code>这个仓库的设置里<u>手动添加域名</u>的时候，其实是在远程仓库(也就是github)新增了一个CNAME文件，里面装着自定义域名，可以失效后手动添加完去看看commit记录，如下图</p><figure><img src="https://s3.bmp.ovh/imgs/2025/01/09/1278c6d3ac42177f.png"alt="直接在远程仓库中添加的CNAME，如果本地没有，更新就会被覆盖" /><figcaptionaria-hidden="true">直接在远程仓库中添加的CNAME，如果本地没有，更新就会被覆盖</figcaption></figure><p>但是本地的博客源文件是没有这个CNAME文件的，所以每次<code>hexo d</code>都会覆盖掉github上的CNAME，导致域名失效。</p><h1 id="解决">解决</h1><p>所以，只需要在<code>source</code>文件夹下新建一个<code>CNAME</code>文件，往里面写入域名，然后再<code>hexo g -d</code>就好了。</p><figure><img src="https://s3.bmp.ovh/imgs/2025/01/09/b74363818fe6082e.png"alt="在/source下新建CNAME文件" /><figcaption aria-hidden="true">在/source下新建CNAME文件</figcaption></figure><p>注意：是<code>CNAME</code>，而不是<code>CNAME.txt</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不是，哥们</title>
    <link href="/2024/09/25/%E4%B8%8D%E6%98%AF%EF%BC%8C%E5%93%A5%E4%BB%AC/"/>
    <url>/2024/09/25/%E4%B8%8D%E6%98%AF%EF%BC%8C%E5%93%A5%E4%BB%AC/</url>
    
    <content type="html"><![CDATA[<p><span class="math display">\[\begin{split}{}_\lambda\!\subset_\Pi^{:l} ?\\不是，哥们\end{split}\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>娱乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数模答辩小记</title>
    <link href="/2024/09/23/%E6%95%B0%E6%A8%A1%E7%AD%94%E8%BE%A9%E5%B0%8F%E8%AE%B0/"/>
    <url>/2024/09/23/%E6%95%B0%E6%A8%A1%E7%AD%94%E8%BE%A9%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>周六早上收到的答辩通知，是指导老师给负责人邮箱或者电话通知。紧张刺激地复习了一天论文和代码之后上场答辩。愿结果如意，小记一下过程，因为准备过程中看到了某pku✌的答辩记录，我也记一下，方便有缘人。(应该不会涉及泄密吧，泄密我就删了。。)</p><h1 id="时间线">时间线</h1><p>9月4日---9月7日：比赛</p><p>9月21日早晨：收到答辩通知</p><p>9月22日上午：前往西石油答辩</p><p>9月25日上午：问指导老师说会推上去的，但等级不定</p><p>10月5日早上：出省赛区拟推结果，拟推国二</p><p>10月31日：官网公示，拟获得国二</p><p>11月11日：名单确定，国二到手🤓🎉</p><h1 id="细节">细节</h1><ul><li><p>答辩是三个人都要到场，要带学生证和身份证，在进场前核验身份，但是进场后就不能暴露自己的学校，因为有其他学校的队伍也在那里答辩，ABCDE题的队伍都有，粗略估计应该有近百支队伍要参加答辩，可能整个成都甚至四川赛区的队伍都在这里了。</p></li><li><p>虽说3个人都要到齐(队里有几个来几个，不一定3个)，但是答辩可以一个人答，不会随机点某个人回答问题，我们队就是我主要做题，所以我全程答辩，队友站旁边适时补充(鞠躬)就行了。</p></li><li><p>答辩的主要目的是辨别论文是不是独立创作的，有没有抄袭。所以即使论文有错误也可以大方承认，关键要说出自己的思路和想法，毕竟这不是定级答辩而是鉴抄答辩。</p></li><li><p>答辩不需要PPT，会让打印两份论文，一份备案，一份给专家看，自己则看讲台电脑上的论文，会提前备好。</p></li><li><p>答辩是每队首先5分钟内陈述自己的思路，然后15分钟内的专家提问。前5分钟的叙述约等于念摘要吧，自己背着拉通陈述也行，我是自己凭记忆拉通讲了一遍思路。讲完思路之后，我们是评委直接让翻到xx页，然后开始提问</p></li><li><p>既然目的是鉴定抄袭，所以25分钟专家提问会问得比较深入，考察对论文的熟悉程度。我们主要被问了两个问题：</p><ul><li>第一个是评审故意下套说错，看你能不能根据自己的论文来驳倒错误，我成功地说服了评审。</li><li>但是第二个问题我好像失败了，第二个问题非常细，问我代码里面一个变量什么含义、为什么这样命名，我回答出了含义，但是为什么这样命名似乎没能说服评审。评审解释了为什么会问这种奇怪问题，因为我的这个变量名字和之前的一份论文的代码相似的位置变量名是一样的。这很巧合，我结合JAVA的constant变量命名规范、C/C++的常量宏定义规范解释了为什么这样命名，但好像没能说服。。</li></ul></li><li><p>评审应该<strong>只辨真伪，不会定级</strong>，所以主旨就是证明是自己原创的就行了，错了也别怕，解释怎么想的就可以。但是如果问到代码里某个变量什么意思答不出来，好像也有点嫌疑。。所以还是要认真复习复习。</p></li><li><p>着装没有要求，我们队就穿的常服，注意别穿短裤、凉拖鞋、背心等花里胡哨或者过于不整的就可以了</p></li></ul><p>具体细节一共就这么多</p><p>本文根据自己的实际经历和<ahref="https://lyh543.github.io/notes/mcm/cumcm-oral-defenses.html">数模国赛答辩相关| 小灰灰灰灰的博客</a>写作，如果泄密或者有更多问题可以联系我。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo上云记录(华为云)</title>
    <link href="/2024/08/30/hexo%E4%B8%8A%E4%BA%91%E8%AE%B0%E5%BD%95-%E5%8D%8E%E4%B8%BA%E4%BA%91/"/>
    <url>/2024/08/30/hexo%E4%B8%8A%E4%BA%91%E8%AE%B0%E5%BD%95-%E5%8D%8E%E4%B8%BA%E4%BA%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2025.1.31 再次将博客放到腾讯云的服务器上，增加了一些踩坑经验</p></blockquote><p>JAVA学不进去，焦虑无比，于是做点其他的，搞了个华为云的免费服务器Flexus，<del>好抠，只给一个月</del>，想着把githubpage上的这个静态博客放到云上玩玩。开帖记录一下过程，也方便以后再次上云。需要：</p><ul><li>服务器镜像：Ubuntu 20.04</li><li>已配置好的hexo博客</li></ul><h1 id="白嫖华为云">白嫖华为云</h1><p>首先来到<ahref="https://www.huaweicloud.com/special/ecs-xsfwq.html">华为云学生服务器</a>页面，每天9:30后能领个试用，注册华为账号，然后领取。</p><figure><img src="https://s3.bmp.ovh/imgs/2024/08/31/4c57cc38588ee8d8.png"alt="华为云真抠啊……" /><figcaption aria-hidden="true">华为云真抠啊……</figcaption></figure><p>买完一路点默认设置，最后来到Flexus实例控制台。跟着“应用搭建指引”设置好密码，在“配置安全组”那里添加一个规则，添加一个TCP的80端口。</p><h1 id="服务器配置">服务器配置</h1><h2 id="下载工具">下载工具</h2><p>通过cloudShell远程登录服务器，下载必要的工具：git、nginx、ssh</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install git-core<br>sudo apt-<span class="hljs-built_in">get</span> install nginx<br>sudo apt-<span class="hljs-built_in">get</span> install openssh-server<br></code></pre></td></tr></table></figure><blockquote><p>华为云好像初始有git和nginx，但也可以执行一下apt-get，不费事</p></blockquote><p>安装ssh后，查看ssh服务是否启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -e|grep ssh<br></code></pre></td></tr></table></figure><figure><img src="https://s3.bmp.ovh/imgs/2024/08/31/6fe396dcfbb2f1e8.png"alt="ssh服务" /><figcaption aria-hidden="true">ssh服务</figcaption></figure><h2 id="创建用户">创建用户</h2><p>创建一个系统用户，这里以"blog"为例。</p><p>创建一个名为<code>blog</code>的用户。接下来为<code>blog</code>添加文件的写权限：在<code>/etc/sudoers</code>中添加<code>blog    ALL=(ALL:ALL) ALL</code>，具体命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">visudo /etc/sudoers<br></code></pre></td></tr></table></figure><p>然后向下翻，找到</p><figure><img src="https://s3.bmp.ovh/imgs/2024/08/31/712404ad978ede8d.png"alt="用户权限" /><figcaption aria-hidden="true">用户权限</figcaption></figure><p>如上图编辑，在root下面添加一行<code>blog    ALL=(ALL:ALL) ALL</code>。<code>visudo</code>命令使用的是nano编辑器，使用Ctrl+X、y、Enter退出。</p><p>然后切换至<code>blog</code>用户，回退至根路径，在<code>/var/repo</code>下创建名为<code>hexo_static</code>的裸仓库(仓库名可自定义)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">su blog<br>cd /<br><br>sudo mkdir /var/repo/<br>sudo chown -R $USER:$USER /var/repo/<br>sudo chmod -R 755 /var/repo/<br><br>cd /var/repo/<br>git init --bare hexo_static.git<br></code></pre></td></tr></table></figure><p>创建完成后可进入<code>/var/repo</code>查看，应该有branches、config、HEAD、hooks等</p><p>创建<code>/var/www/hexo</code>目录，用于nginx托管，修改目录所有权和权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /var/www/hexo<br><br>sudo chown -R $USER:$USER /var/www/hexo<br>sudo chmod -R 755 /var/www/hexo<br></code></pre></td></tr></table></figure><h2 id="配置nginx服务默认路径">配置nginx服务默认路径</h2><p><strong>如果</strong><code>/etc/nginx</code>下有<code>sites-enabled</code>文件夹，则编辑其下的<code>default</code>文件</p><p><strong>如果没有</strong>，则编辑<code>conf.d</code>文件夹下的<code>default.conf</code>，添加<code>root /var/www/hexo</code>，位置如下，再删掉location里的proxy的第一行<code>proxy_pass  http://127.0.0.1:9001</code>;，取消转发到9001端口。</p><blockquote><p>因为华为云默认安装一个wordpress的应用镜像，用dockerps就能看见，如果放着不管，直接访问ip会看见wordpress而不是自己的博客。可以禁掉docker，也可以取消掉这里的转发。</p></blockquote><p><imgsrc="https://s3.bmp.ovh/imgs/2024/08/31/6e31c0e536710814.png" /></p><p><strong>如果有</strong><code>sites-enabled</code>文件夹，在<code>default</code>中如下位置添加<code>root    /var/www/hexo</code></p><p><imgsrc="https://s3.bmp.ovh/imgs/2024/08/31/2827648b2496da59.png" /></p><blockquote><p>注意：nginx.conf里面得包含你写的default，写了就得include进去，如下：</p><p><imgsrc="https://s3.bmp.ovh/imgs/2024/08/31/21367481ad0f2bc1.png" /></p><p>Vhost就是VirtualHost，可能在这个文件内是其他名字。include后面必须要包含之前修改的文件的路径</p></blockquote><p>然后重启nginx服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl reload nginx<br></code></pre></td></tr></table></figure><blockquote><p>重启后可以用<code>sudo systemctl status nginx</code>检查nginx状态，如果是active证明启动成功，如果是failed，阅读报错信息。</p><p>我第二次是默认路径写多了，提示duplicated，删掉原有的<code>root /var/www/html</code>就行</p></blockquote><h2 id="创建git钩子">创建Git钩子</h2><p>在之前的仓库的hooks文件夹下创建一个<code>post-receive</code>钩子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /var/repo/hexo_static.git/hooks/post-receive<br></code></pre></td></tr></table></figure><p>写入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>git --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f<br></code></pre></td></tr></table></figure><p>然后为该文件添加可执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x /var/repo/hexo_static.git/hooks/post-receive<br></code></pre></td></tr></table></figure><h2 id="拷贝密钥">拷贝密钥</h2><p>回到根路径创建<code>.ssh</code>目录，进入，创建<code>authorized_keys</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /<br>sudo mkdir .ssh<br>cd /.ssh<br><br>vim authorized_keys<br></code></pre></td></tr></table></figure><p>找到<strong>本地的</strong><code>id_rsa.pub</code>文件，复制到这里，如果没权限可以进root再操作</p><blockquote><p>本地的id_rsa.pub文件通常在<code>C:\用户\你的账户\.ssh</code>这个路径里面</p><p>如果给腾讯云添加了ssh密钥，可能会导致deploy失败，我刚开始失败了，猜测是这个原因，于是在云服务器控制台解绑了ssh密钥，再次deploy，成功。</p></blockquote><h2 id="部署hexo项目">部署hexo项目</h2><p>编辑本地hexo的<code>_config.yml</code>文件，修改两处</p><ul><li>url改为服务器的公网ip</li><li>deploy的repo改为{用户名}<span class="citation"data-cites="公网ip">@公网ip</span>:/var/repo/hexo_static.git，branch改成实际的名字，main或者master</li></ul><blockquote><p>如果不知道main还是master，可以不在_config.yml里写branch字段，会自动选择HEAD指向的分支的，或者去<code>/var/repo/hexo_static.git/HEAD</code>里看下是啥</p></blockquote><p>然后<code>hexo g -d</code>上传，首次会要一个yes，然后输密码</p><p>上传后进入<code>/var/www/hexo</code>下查看，可以看到静态文件已经全部上传，就是本地的public文件夹里的内容。</p><p>然后在浏览器输入ip就可以访问啦！</p><h1 id="后续问题">后续问题</h1><p>第一次上传成功，第二次上传出现</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-comment">remote: error: cannot update the ref &#x27;HEAD&#x27;: unable to append to &#x27;./logs/HEAD&#x27;: Permission denied</span><br></code></pre></td></tr></table></figure><p>通常是由于远程仓库中的分支或引用被锁定、权限问题，或者由于在远程仓库中有一些与本地仓库冲突的提交。但是这是个人博客，所以不会出现分支冲突，那就是权限问题，无脑加一轮权限即可简单解决：(无脑勿喷＞︿＜)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span> -un  <span class="hljs-comment"># 获取当前用户名</span><br><span class="hljs-built_in">id</span> -gn  <span class="hljs-comment"># 获取当前用户组</span><br><br>sudo <span class="hljs-built_in">chown</span> -R YOUR_USER:YOUR_GROUP /var/repo/hexo_static.git <span class="hljs-comment">#增加权限</span><br><span class="hljs-built_in">rm</span> -f /var/repo/hexo_static.git/.git/refs/heads/main.lock <span class="hljs-comment">#删除仓库的锁</span><br><span class="hljs-comment"># 设置目录权限为755，允许所有者读写，组和其他用户只读</span><br>sudo <span class="hljs-built_in">chmod</span> -R 755 /var/www/hexo<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重命名项目</title>
    <link href="/2024/08/30/%E9%87%8D%E5%91%BD%E5%90%8D%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/08/30/%E9%87%8D%E5%91%BD%E5%90%8D%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>出于将苍穹外卖化为己有的阴暗目的，我决定将项目中的sky-take-out、sky、itcast、heima等字样统统修改，去除黑马元素和苍穹元素。此举可能造成一系列路径问题，故开帖记录</p><p>重命名基于黑马官方资料day01的后端初始代码，在跟完教程开发完成后开始重构。</p><h1 id="模块名">模块名</h1><p>首先，修改模块名，主模块sky-take-out改为my-take-out，idea显示的是模块所在文件夹的名称，所以还要修改文件夹名，修改之后就需要重新用IDEA打开项目。</p><p>然后，下面三个子模块的sky都改为my，此时refactor出现了重构选项，可以一键重构模块及其文件夹名，还能将所有位置的名字都修改了(先查找，然后修改全部)，子模块名主要存在于父模块的pom文件聚合工程中，以<code>&lt;module&gt;</code>包括。</p><p>至此模块名修改完成，注意<strong>重新加载maven</strong>，更新子模块的pom文件</p><h1 id="包名">包名</h1><p>双击shift搜索“sky”字样，注意到项目所有com包下级包名都是sky，都改成my</p><blockquote><p>为什么java项目的包要像域名翻转一样？</p><p>java诞生时，互联网域名系统已经很成熟，开发者使用所属组织域名可以防止重复，同时标识项目来源</p><p>com：commercial 商业组织、org：organization非盈利组织、gov、edu……</p><p>由含义来看，大包名下的小包名依次表示：所属组织、用途。所以com下的sky改为my可表示由自己开发，意义正确，符合规范</p></blockquote><p>重命名包时也会有全局重命名选项，此时不能勾选"在注释和字符串中搜索"，因为会有只读文件已经获取旧包名sky，类似于缓存，无法对其写。而不勾选"在注释和字符串中搜索"，意味着后续还需要全局搜索来修改残余的"sky"。</p><h1 id="groupid">groupId</h1><p>然后，修改pom文件中的groupId，由于groupId可以不与实际包名一致，所以不会报错。先修改父工程的pom其中的groupId，然后刷新maven时就会报三个子模块的错<code>&lt;parent&gt;</code>下的父工程指定出了问题，一个一个修改好。还需注意，server模块依赖了common和pojo模块，还需要改server的<code>&lt;dependency&gt;</code>中的groupId。</p><h1 id="其他">其他</h1><p>然后，<code>ctrl+shift+f</code>全局搜索，再接<code>ctrl+shift+r</code>全局替换，直接把所有sky全变成my。</p><blockquote><p>为什么不直接全局搜索替换？</p><p>得先改文件夹名，然后才能全局搜索替换，不然会出现三个my-xxx的空子模块，原来的模块还是用文件夹名，只是多了个my-xxx的别名，父工程的pom是找不到这三个子工程的。</p><p>包名也没办法全局替换，根本不会被搜索到，只能一个一个重命名，还得注意连带文件夹。</p><p>groupId部分可以跳过，直接全局替换</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八股集录</title>
    <link href="/2024/08/21/%E5%85%AB%E8%82%A1%E9%9B%86%E5%BD%95/"/>
    <url>/2024/08/21/%E5%85%AB%E8%82%A1%E9%9B%86%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>目前处于烂尾状态。。。我很抱歉</p></blockquote><h1 id="day1">day1</h1><h2 id="osi模型">OSI模型</h2><p>Open SystemInterconnect，OSI将计算机网络通信协议分为7层，分别是应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><h2 id="tcpip模型">TCP/IP模型</h2><p>应用层——应用、表示、会话：HTTP、SSH、FTP</p><p>传输层——传输：TCP、UDP</p><p>网络层——网络：IP</p><p>网络接口层——数据链路层、物理层：以太网、WIFI、MAC地址</p><blockquote><p>理解：TCP/IP更早，更实际、实用；OSI更偏向于理论研究，更细化，更通用</p></blockquote><h2 id="从输入url到页面展示的过程">从输入URL到页面展示的过程</h2><ol type="1"><li>输入URL，解析URL，准备发送HTTP请求</li><li>检查浏览器缓存，如果有则直接返回，如果没有则准备发送网络请求</li><li>发送网络请求前要进行DNS解析，获取域名的IP地址。如果请求协议是HTTPS，还要建立TLS连接。DNS解析从本地缓存、本地Host文件、路由器缓存、DNS服务器，一直查询域名直到根DNS服务器，直到找到为止。</li><li>TCP三次握手建立浏览器和服务器之间的TCP连接</li><li>连接建立后，客户端构建请求信息，发送HTTP请求，如果是HTTPS，还要加解密</li><li>服务器收到请求之后根据请求响应数据</li><li>TCP四次挥手断开连接</li><li>浏览器解析响应数据，展示出相应的页面</li></ol><blockquote><p>理解：刚开始检查用不用发请求，如果需要发请求，就先解析，然后三次握手，后端响应，四次挥手断开，最后前端展示</p></blockquote><h1 id="day2">day2</h1><h2id="http请求响应报文是怎样的有哪些常见的字段">HTTP请求、响应报文是怎样的，有哪些常见的字段</h2><p>请求报文： 由请求行、请求头、空行、请求体构成。请求行包括：</p><ul><li>方法：GET、POST、PUT、DELETE等</li><li>资源路径，也就是url</li><li>HTTP版本，使用的http协议，比如1.1、2.0</li></ul><p>请求头的字段比较多，常用的有：</p><ul><li>Host：请求的服务器的域名</li><li>Accept：客户端能够处理的媒体类型</li><li>Accept-Encoding：客户端能够解码的内容编码</li><li>Authorization：用于认证的凭证信息，比如token</li><li>Content-Length：请求体的长度</li><li>Content-Type：请求体的媒体类型</li><li>Cookie：存储在客户端的cookie数据</li><li>If-None-Match：资源的ETag值，用于缓存控制</li><li>Connection：管理连接的选项，如keep-alive</li></ul><p>空行是分隔请求头和请求体的空行</p><p>响应报文：服务器向客户端返回的数据格式，通常包含状态行、响应头、空行、响应体</p><p>状态行包含HTTP版本、状态码、状态信息，比如http/2.0 404 notFound</p><p>响应头的常见字段有：</p><ul><li>Content-Type：响应主体的媒介类型</li><li>Content-Length：响应主体的长度</li><li>Server：指定服务器的信息</li><li><strong>Expires</strong>：响应的过期时间</li><li><strong>ETag</strong>：响应体的实体标签，用于缓存和条件请求</li><li><strong>Last-Modified</strong>：资源最后被修改的日期和时间</li><li>Location：在重定向时指定新的资源位置</li><li>Set-Cookie：在重定向时指定新的资源位置</li></ul><blockquote><p>理解：行+头+空行分隔+体</p><p>行里基本配置信息，头里一堆字段，体里是数据</p></blockquote><h2 id="http有哪些请求方式">HTTP有哪些请求方式</h2><p>Get：<strong>请求</strong>指定的资源</p><p>Post：向指定资源<strong>提交</strong>数据进行处理</p><p>Put：<strong>更新</strong>资源</p><p>DELETE：<strong>删除</strong>资源</p><p>HEAD：获取报文首部，不返回报文主题(判断资源是否存在)</p><p>OPTIONS：查询服务器支持的请求方法(通过Allow头来判断)</p><p>PATCH：对资源进行部分更新</p><blockquote><p>理解：望文生意即可</p></blockquote><h2 id="get请求和post请求的区别">GET请求和POST请求的区别</h2><ul><li>get一般用来获取数据，post如其名用来提交数据</li><li>get参数放在路径里，而post的在请求体里</li><li>由于参数的位置，post相比get更安全，参数量也更大</li><li>get请求不会改变资源的状态，而post会改变，称为幂等性</li><li>get可以被缓存，而post默认不缓存</li></ul><blockquote><p>理解：仍然望文生义，注意最后一点</p></blockquote><h1 id="day3">day3</h1><h2 id="http中常见的状态码有哪些">HTTP中常见的状态码有哪些</h2><ul><li>200：客户端请求成功</li><li>201：创建了新资源</li><li>204：无内容，服务器成功处理了请求，但未返回内容</li></ul><hr /><ul><li>301：永久重定向</li><li>302：临时重定向</li><li>304：请求的内容未修改，浏览器使用缓存返回</li></ul><hr /><ul><li>401：需要身份验证</li><li>403：禁止访问</li><li>404：资源未找到</li></ul><hr /><ul><li>500：服务器内部错误</li><li>503：服务器刚启动，未准备好</li></ul><blockquote><p>理解：大体分四类，2开头为成功，3开头表示资源变化，4开头请求错误，5开头服务错误</p><p>整百读整百，其他单个读：500-伍佰、404-四零四</p></blockquote><h2 id="什么是强缓存和协商缓存">什么是强缓存和协商缓存</h2><p>强缓存：浏览器对之前请求过的资源进行缓存，下一次请求时不发送请求，而直接返回本地缓存的资源。</p><ul><li><p>在Http1.0版本中，通过<code>Expire</code>响应头来实现强制缓存，是一个时间点，表示资源过期时间。</p></li><li><p>在1.1版本中，引入了<code>Cache-Control</code>响应头，可以通过<code>max-age</code>设置最大生存时间</p></li><li><p>如果响应头中没有任何和缓存相关的字段，浏览器会采用启发式算法决定是否缓存资源。通常基于<code>Date</code>和<code>Last-modified</code>值计算</p></li></ul><blockquote><p>强缓存可能导致资源更新时的不一致，需要合理设置更新频率。</p></blockquote><hr /><p>协商缓存：浏览器和服务器通信以确认缓存资源是否有效。</p><p>主要涉及两组响应头字段</p><ul><li><code>ETag</code>/<code>If-None-Match</code>：浏览器第一次请求时，服务器会返回ETag，是该资源的唯一标识符，后续再请求，请求头中的<code>If-None_Match</code>就会携带<code>ETag</code>，服务器来判断该资源是否更新，如果未更新，则返回<code>304 Not Modified</code>，如果更新了则返回新的资源和ETag。</li><li><code>Last-Modified</code>/<code>If-Modified-Since</code>：服务器会返回资源和其最后修改时间<code>Last-Modified</code>，后续请求的请求头会携带<code>If-Modified-Since</code>，服务端检查是否过期。返回同上。</li></ul><blockquote><p>协商缓存确保获取最新资源，避免不必要的资源传输。</p></blockquote><hr /><blockquote><p>理解：强缓存应用于不常变动的静态资源，如图片，css，js等</p><p>协商缓存适用于变动频繁的资源</p></blockquote><h1 id="day4">day4</h1><h2 id="http-1.0和http-1.1的区别">HTTP 1.0和HTTP 1.1的区别</h2><ul><li><strong>持久连接</strong>：HTTP1.1默认持久连接，也就是一个TCP连接可以发送多个HTTP请求响应，减少了连接和关闭的开销。而HTTP1.0默认短连接，每次请求都需要建立一个TCP连接，通过Connection：keep-alive头来实现持久连接(可被拒绝)</li><li><strong>管道化</strong>：HTTP1.1支持管道化，允许客户端再第一个请求的响应到达前发送多个请求，减少等待时间。HTTP1.0不支持管道化。<u>管道化的前提是使用长连接</u></li><li><strong>缓存控制</strong>：HTTP1.0主要使用<code>If-Modified-Since</code>和<code>Expires</code>来缓存控制。HTTP1.1引入了<code>ETag/If-None-Match</code>等更多的缓存头来控制缓存</li><li>错误码：HTTP 1.1有更多错误响应码，如<code>426 Upgrade Required</code></li><li>Host字段：HTTP1.1加入了Host头，让客户端指定请求的主机名，可以在同一台服务器上托管多个域名。HTTP1.0没有这个字段</li><li>请求方法：HTTP1.1有更多请求方法，如OPTIONS、PUT、DELETE、HEAD、PATCH</li><li>带宽优化：HTTP1.1中可以部分请求资源，使用range头设定范围，返回码是206 PartialContent</li></ul><blockquote><p>理解：降低了原子性：持久、管道；加入了更多的功能</p></blockquote><h2 id="http-1.1和http-2.0的区别">HTTP 1.1和HTTP 2.0的区别</h2><ul><li><strong>二进制协议vs文本协议</strong>：HTTP 2.0采用二进制格式传输数据，解析高效还不容易出错。而HTTP1.1使用可读的文本格式，解析和处理都较慢</li><li><strong>多路复用</strong>：HTTP2.0支持多路复用，允许单个TCP连接上并行交错发送多个请求和响应，缓解了HTTP1.1中的队头阻塞问题。<strong>在丢包场景下还是会出现队头阻塞问题</strong></li><li><strong>头部压缩</strong>：HTTP2.0引入了HPACK压缩算法，对请求响应头压缩，减少了冗余头部信息的传输</li><li><strong>服务器推送</strong>：HTTP2.0允许服务器主动推送资源给客户端</li><li><strong>优先级和依赖</strong>：HTTP2.0允许客户端为请求设置优先级，并表达请求之间的依赖关系，让资源加载更有序。</li></ul><blockquote><p>理解：改进传输，实现双向，优先级</p></blockquote><h2 id="http-3.0">HTTP 3.0</h2><p>HTTP 3是HTTP的最新版本，基于QUIC协议，特点有：</p><ul><li>无队头阻塞：QUIC使用UDP来传输数据，一个连接上多个stream之间没有依赖，如果一个stream丢了一个UDP包，不会影响后面的stream，不存在队头阻塞的问题。</li><li><strong>零RTT连接建立</strong>：QUIC允许首次连接时进行零往返时间连接建立，QUIC协议通过将握手过程（包括加密握手）减少到一次往返（甚至为0-RTT），大大缩短了连接建立的时间。这意味着第一次与服务器连接时延迟显著降低，用户体验更加流畅。</li><li><strong>连接迁移</strong>：QUIC允许在网络切换(如从WIFI切到移动网络)，将连接迁移到新的IP地址，从而减少连接的中断时间。</li><li>向前纠错机制：每个数据包除了它本身的内容之外，还有其他包的数据，所以少量丢包可以用其他包的数据而不需要重新传。虽然降低了每个包的有效信息，但是减少了丢包数据重传。</li><li>安全性：HTTP 3.0默认TLS加密，确保了数据传输的安全</li></ul><blockquote><p>理解：从TCP变成了UDP，基于QUIC，所以少了一些TCP的问题：建立连接开销大、队头阻塞。</p><p>需要结合 层 来理解，看图</p></blockquote><h1 id="day-5">day 5</h1><h2 id="https-和-http-有什么区别">HTTPS 和 HTTP 有什么区别</h2><p>区别主要在于安全性和数据加密：</p><ul><li>加密层：HTTPS在HTTP的基础上增加了SSL/TLS(<strong>现代只使用TLS</strong>)协议作为加密层。HTTP是明文的</li><li>HTTP在TCP三次握手后开始报文传输，HTTPS在三次握手后还要SSL/TLS的握手才能进入加密报文传输。</li><li>端口：HTTPS通常使用443端口，HTTP使用80端口</li><li>HTTPS需要CA证书，来保证服务器身份可信</li></ul><blockquote><p>HTTPS的S就是Secure，所以主要区别在于安全性：多了TLS -&gt;多了TLS的握手;多了CA证书</p></blockquote><h2id="https的工作原理https建立连接的过程">HTTPS的工作原理(HTTPS建立连接的过程)</h2><p>过程如下：</p><ol type="1"><li>密钥交换：客户端发起HTTPS请求后，服务器会发送其公钥证书给客户端</li><li>证书验证：客户端会验证服务器的证书是否由CA签发，检查有效性</li><li>加密通信：证书验证通过，客户端生成一个随机的对称加密密钥，使用服务器的公钥加密该密钥，发送给服务器</li><li>建立安全连接：服务器使用自己的私钥解密得到对称加密密钥，此时客户端与服务端都有了相同的密钥，可加解密</li><li>数据传输：将所有数据对称加密传输</li><li>完整性校验：SSL/TLS协议还包括消息完整性校验，如消息认证码，确保数据在传输过程中未被篡改</li><li>结束连接：数据传输完成后，通信双方销毁密钥。</li></ol><blockquote><p>理解：公钥用于加密，私钥用于解密，只有对应的公私钥才能彼此加解密，通过非对称加密传递对称加密的密钥，实现对称加密。</p></blockquote><h2 id="tcp和udp的区别">TCP和UDP的区别</h2><ol type="1"><li>TCP需要在传输前建立可靠连接，UDP不需要建立连接</li><li>TCP保证数据包的顺序和完整，UDP不保证</li><li>TCP可根据网络状况调整传输速率，UDP传输速率固定</li><li>TCP通过滑动窗口进行流量控制，UDP没有流量控制</li><li>TCP能检测重传丢包，UDP没有</li><li>TCP报文头复杂，UDP报文头简单</li><li>TCP建立连接开销大，UDP简单开销小</li><li>TCP适用于可靠传输，UDP适用于实时性高的传输</li></ol><blockquote><p>理解：TCP稳定可靠，代价就是事儿多；UDP事儿不多，但是不稳定不可靠</p></blockquote><h1 id="day-6">day 6</h1><h2 id="tcp连接如何确保可靠性">TCP连接如何确保可靠性</h2><p>TCP通过这些机制来保证可靠性：</p><ul><li>序列号：每个TCP都有一个序列号，确保数据包的顺序正确</li><li>数据校验：TCP使用校验和来检测数据在传输过程中是否出现错误，如果错误，就会丢弃该包并等待重传</li><li>确认应答：接收方会发送ACK确认收到数据。</li><li>超时重传：如果发送方的定时器超时了还未收到ACK，会触发超时重传</li><li>流量控制：TCP通过滑动窗口进行流量控制，确保接收方能够处理发送方的数据量</li><li>拥塞控制：TCP通过慢启动、快重传、快恢复、拥塞避免等控制数据的发送速率，防止网络拥塞</li></ul><h2 id="拥塞控制如何实现的">拥塞控制如何实现的</h2><ul><li>慢启动：初始阶段，TCP发送方从小发送窗口开始，越成功窗口越大，指数级增长，称为慢启动。在开始时逐步增加速率，避免引起拥塞</li><li>拥塞避免：一旦达到一定的阈值，TCP发送方就会进入拥塞避免阶段：发送方以线性增加的方式增加发送窗口的大小。</li><li>快速重传：如果发送方连续收到相同的确认，会认为丢包，并快速重传未确认的包，而不等待超时。</li><li>快速恢复：发生快速重传后，发送方不会重新慢启动，而将慢启动阈值设置为当前窗口的一半，将拥塞窗口的大小设置为慢启动阈值加上已确认但未快速重传的包的数量。</li></ul><blockquote><p>理解：先慢后快，然后试探上限，过线就减半重来，目的就是在靠近上限的地方波动，保持总体较高的传输速率而不导致拥塞</p></blockquote><h2 id="tcp流量控制是怎么实现的">TCP流量控制是怎么实现的</h2><p>主要目的就是发送方不能太快，接收方来得及接受。这就需要动态地根据网络情况来调整传输速率。</p><ul><li>滑动窗口大小：每个TCP报文段都有一个窗口字段，提示发送方可以发送多少字节的数据而不等待确认。</li><li>接收方窗口大小：接收方通过该字段告诉发送方目前可接受的窗口大小，主要依据接收方缓冲区大小，如果接收方缓冲区快满，会减小窗口，或通知发送方暂停发送</li><li>发送方根据窗口的大小动态调整发送速率，根据ACK中的窗口字段获取最新的窗口大小</li></ul><blockquote><p>理解：每次ACK都是接收方告诉发送方当前速率是否合适</p></blockquote><h2 id="udp如何实现可靠传输">UDP如何实现可靠传输</h2><p>UDP（User DatagramProtocol）本身是一种无连接、不可靠的传输协议，不提供像 TCP那样的可靠性机制，如数据重传、数据包顺序控制、流量控制和拥塞控制。因此，UDP在设计上更适合需要低延迟或能够容忍一定数据丢失的应用，比如实时视频流、在线游戏和语音通信。</p><p>然而，在一些需要可靠传输的应用场景中，可以通过在应用层（即在 UDP之上）自行实现额外的可靠性机制来弥补 UDP 的不足。</p><ul><li>添加序列号</li><li>超时重传</li><li>向前纠错</li><li>错误校验</li><li>流量控制</li></ul><blockquote><p>理解：貌似TCP的特性加在UDP上就好了</p></blockquote><h1 id="day7">day7</h1><h2id="tcp三次握手的过程为什么是三次可以少或者多吗">TCP三次握手的过程，为什么是三次，可以少或者多吗</h2><p>三次握手的过程：</p><ul><li>第一次握手：客户端向服务端发送一个<code>SYN</code>(同步序列编号)报文，请求建立连接，客户端进入<code>SYN_SENT</code>状态</li><li>第二次握手：服务端收到SYN报文后，如果同意，则发送一个SYN_ACK(同步确认)报文作为响应，同时进入SYN_RCVD状态</li><li>第三次握手：客户端收到服务器的SYN_ACK报文后，会发送一个ACK确认报文作为最终响应，之后客户端和服务端都进入ESTABLISHED状态，连接建立成功。</li></ul><blockquote><p>三次正好可以确认双方的收发功能正常。多了冗余，少了不行。</p></blockquote><h2id="tcp四次挥手的过程为什么是四次">TCP四次挥手的过程，为什么是四次</h2><p>四次挥手的过程：</p><ul><li>第一次挥手：客户端发送<code>FIN</code>报文给服务端，表示要断开数据传送，报文中会指定一个序列号<code>(seq=x)</code>。然后，客户端进入<code>FIN-WAIT-1</code>状态。</li><li>第二次挥手：服务端收到<code>FIN</code>报文后，回复<code>ACK</code>报文给客户端，且把客户端的序列号+1，作为ACK报文的序列号<code>(seq=x+1)</code>。然后，服务端进入<code>CLOSE-WAIT(seq=x+1)</code>状态，客户端进入<code>FIN-WAIT-2</code>状态。</li><li>第三次挥手：服务端也要断开连接时，发送<code>FIN</code>给客户端，且指定序列号<code>(seq=y+1)</code>，随后服务端进入<code>LAST-ACK</code>状态。</li><li>第四次挥手：客户端收到<code>FIN</code>报文后，发出<code>ACK</code>应答，把服务端的序列号+1作为ACK序列号<code>(seq=y+2)</code>。此时，客户端进入<code>TIME-WAIT</code>状态。服务端收到客户端的<code>ACK</code>后进入<code>CLOSE</code>状态，如果客户端等待<code>2MSL</code>没有收到服务端的回复，则关闭连接。</li></ul><p>为什么四次：</p><p>TCP是全双工通信，双向传输数据，双方都可以提出释放连接的通知，让对方进入半关闭状态，待对方传输完毕后，发回连接释放通知，己方确认后才会完全关闭TCP连接。前两次让发起方发出通知和对方发出确认；后两次让对方做完最后的传输，发出同意，让己方收到确认，最终关闭。</p><blockquote><p>发起方提前预警，接收方开始准备断开，接收方准备完成，发起方收到确认放心断开</p></blockquote><h2id="http的keep-alive是什么tcp的keepalive是和http的keep-alive是一个东西吗">HTTP的Keep-Alive是什么？TCP的Keepalive是和HTTP的Keep-Alive是一个东西吗</h2><ul><li>HTTP的Keep-Alive，是由应用层实现的，称为HTTP长连接。HTTP短连接为：建立TCP连接-&gt; HTTP请求资源 -&gt; 响应资源 -&gt;释放连接。但是每次连接只能请求一次资源，所以HTTP的Keep-Alive实现了使用同一个TCP连接来发送接受多个HTTP的请求应答，减少多次连接建立和释放的开销。</li><li>TCP的Keepalive，由TCP层(内核态)实现的，称为TCP保活机制，是一种用在TCP连接上检测空闲状态的机制。当TCP连接建立后，如果一段时间没有数据传输，TCP的Keepalive会发送探测包来检查连接是否还有效。</li></ul><blockquote><p>HTTP的是长连接，TCP的是检测连接是否还有效。一个高层一个底层</p></blockquote><h1 id="day8">day8</h1><h2 id="dns查询过程">DNS查询过程</h2><p>DNS称为域名服务器(Domain NameSystem)，用于将主机名和域名转换为IP地址，一般查询过程为：</p><ul><li><strong>本地DNS缓存检查</strong>：首先查询本地的DNS缓存，如果缓存里有对应的IP，则直接返回结果</li><li><strong>本地的DNS服务器</strong>：通常是当地的ISP提供，向其发送DNS查询请求</li><li><strong>根DNS服务器</strong>：如果本地DNS服务器没有，则其会向根DNS服务器查询。根DNS服务器不负责具体的域名解析，但能够告诉本地NDS服务器应该向哪个顶级域的DNS服务器继续查询</li><li><strong>顶级域名DNS服务器</strong>：本地DNS服务器接着向顶级域名DNS服务器发出查询请求。顶级域名DNS服务器也不负责具体的域名解析，但会告诉本地DNS服务器应该前往哪个权威DNS服务器查询下一步信息。</li><li><strong>权威DNS服务器</strong>：本地DNS服务器最后向权威DNS服务器发送查询，权威DNS服务器会返回对应的IP地址</li><li>本地DNS解析器收到IP后返回给浏览器，并且缓存该解析结果。</li><li>浏览器获得IP后，与目标服务器建立连接。</li></ul><blockquote><p>本地-&gt;本地ISP的DNS-&gt;根-&gt;顶级域名-&gt;权威</p></blockquote><h2 id="cdn是啥有什么用">CDN是啥，有什么用</h2><p>CDN是内容分发网络(Content DeliveryNetwork)，通过将内容存储在分布式服务器上，使用户可以从距离较近的服务器获得所需的内容，加速互联网的内容传输。</p><ul><li>就近访问：CDN在服务范围内会部署多个服务器节点，用户的请求会送到最近的CDN节点，加速访问。</li><li>内容缓存：CDN会缓存静态资源(图片、CSS、Script)。当用户访问时，CDN会使用缓存，没有才去源服务器获取资源并缓存。这减少了源服务器的负载</li><li>可用性：一个节点出了问题，还可以被重定向到其他的节点</li></ul><blockquote><p>对于博客，这可太熟悉了，当分布式说吧</p></blockquote><h2 id="cookie和session是什么">Cookie和Session是什么</h2><p>Cookie和Session都用于管理用户的状态和身份，Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。</p><ul><li>cookie由服务器发给浏览器，浏览器保存cookie并在将来的请求中包含cookie，服务器收到后续请求后可以分析cookie从而确定身份。</li><li>Session时服务器把客户端信息处理后记录在本地，主要用于维护登陆状态、存储临时数据等。服务器为每个用户分配SessonID，通常存在cookie中发给客户端</li></ul><p>Cookie和Session的区别：</p><ul><li>存储位置：Cookie存在浏览器，Session存在服务器</li><li>数据容量：Cookie较小，Session较大</li><li>安全性：Cookie存在浏览器内，可以被篡改，而Session不会</li><li>生命周期：Cookie可设置过期时间，Session依赖于会话的持续时间或用户活动</li><li>传输方式：Cookie在每次HTTP请求中都会被自动发送给服务器，而SessionID由Cookie或URL传递参数给客户端</li></ul><blockquote><p>cookie浏览器拿着，有信息；session防止被改，自己拿着，但容易拿不下</p></blockquote><h1 id="day9">day9</h1><h2 id="进程和线程的区别">进程和线程的区别</h2><p><strong>进程是资源分配和调度的最小单位</strong></p><p><strong>线程是程序执行的最小单位</strong></p><ul><li><p>线程是进程内的子任务，一个进程中的多个线程共享内存空间，进程之间内存空间独立。进程切换、创建、销毁的开销都大于线程。</p></li><li><p>进程之间通信需要一些机制：管道、消息队列、共享内存等。但线程可以直接访问共享数据。</p></li><li><p>进程相互隔离，而线程的错误可能会影响其他线程，影响整个进程的稳定性。</p></li></ul><blockquote><p>今天都是操作系统的基础，老考点了</p></blockquote><h2 id="并行和并发的区别">并行和并发的区别</h2><p>并行是真正意义上的同时进行，同一时刻有多个在执行。而并发是在短时间内相继执行大量任务，在宏观上看起来像同时发生，实际上仍然是交替执行的。</p><blockquote><p>老考点了，可以结合实例讲</p></blockquote><h2id="解释用户态和内核态什么情况下会发生切换">解释用户态和内核态，什么情况下会发生切换</h2><p>用户态和内核态是操作系统为了保护系统资源和权限控制而设计的两种不同的CPU运行级别，可以<strong>控制进程或程序对计算机硬件资源的访问权限和操作范围</strong>。</p><ul><li>用户态：进程和程序只能访问受限的资源和执行受限的指令集，不能直接访问OS的核心部分，也不能直接访问硬件资源。</li><li>核心态：OS的特权级别，允许进程或程序执行特权指令和访问操作系统的核心部分。在核心态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。</li></ul><p>发生切换的场景：</p><ul><li>系统调用</li><li>异常</li><li>中断</li></ul><blockquote><p>也是经典知识点，看看就行了，已经知道了</p></blockquote><h1 id="day10">day10</h1><h2 id="什么是死锁如何避免">什么是死锁，如何避免</h2><p>死锁就是系统中两个或多个进程在执行过程中，因争夺资源而造成的一种僵局。当每个进程都持有一定的资源并等待其他进程释放他们的所需的资源时，这些资源都被其他进程占据却不释放，就导致了死锁。</p><p>死锁的条件有四个：</p><ul><li>互斥</li><li>请求保持</li><li>不可剥夺</li><li>循环等待</li></ul><p>所以可以通过破坏除互斥之外的三个条件之一来预防死锁。也可以通过银行家算法等检测死锁，可以通过挂起或终止某些进程来解除死锁。</p><blockquote><p>老知识点，思路就是：预防(破坏条件)-检测(银行家)-解除(挂起，暴力终止)</p></blockquote><h2 id="介绍一下几种典型的锁">介绍一下几种典型的锁</h2><ul><li><strong>互斥锁</strong>：最常见的锁类型。任何时刻只允许一个线程持有，其他线程必须等待。</li><li>自旋锁：基于忙等待的锁，线程在尝试获取锁时会不断轮询，直到锁被释放。</li></ul><p>其他的锁都是基于这两个锁的：</p><ul><li>读写锁：允许多个线程同时读写和共享资源，只允许一个线程进行写操作。分为读(共享)和写(排他)两种状态。</li><li>悲观锁：认为多线程同时修改资源的可能性比较高，所以访问共享资源时要上锁。</li><li>乐观锁：多线程能够同时访问和修改，但是如果修改前后原资源发生变化，证明出现同时修改，则放弃本次操作。</li></ul><h2 id="讲一讲你理解的虚拟内存">讲一讲你理解的虚拟内存</h2><p>虚拟内存不是真实存在，而通过映射与实际物理地址空间对应。使每个进程看起来有连续的地址空间。</p><p>需要虚拟内存的原因：</p><ul><li>内存扩展：虚拟内存使得程序能够使用比实际内存更大的存储空间</li><li>内存隔离：虚拟地址空间让进程之间的地址空间相隔离</li><li>物理内存管理：虚拟内存允许操作系统动态地将数据和程序离散地加载到物理内存中，并且可以将不常用的数据或程序移到硬盘上，从而释放内存供其他进程使用。</li><li>页面交换：物理内存不足时，可以通过页面交换将外存作为虚拟内存使用，虚拟地扩大了内存空间。</li></ul><h1 id="day11">day11</h1><h2 id="线程同步的方式有哪些">线程同步的方式有哪些</h2><p>线程同步是多线程编程中，保证线程间互不干扰的一种机制，常见的线程同步机制有以下几种：</p><ul><li>互斥锁</li><li>条件变量：用于线程间通信，允许一个线程等待某个条件满足，其他线程可以发出信号通知等待线程，通常与互斥锁一起使用。</li><li>读写锁：允许多个读，只允许一个写</li><li>信号量</li></ul><h2 id="有哪些页面置换算法">有哪些页面置换算法</h2><ul><li>OPT最佳置换算法</li><li>FIFO先进先出</li><li>LRU最近最久未使用</li><li>LFU最不经常使用</li><li>CLOCK轮转</li></ul><blockquote><p>比较基础，很八股</p></blockquote><h1 id="day12">day12</h1><h2 id="熟悉哪些linux命令">熟悉哪些linux命令</h2><p><code>ls</code>、<code>cd</code>、<code>pwd</code>、<code>rm</code>、<code>touch</code>、<code>cat</code>、<code>vi/vim</code>、<code>chmod</code>、<code>chown</code>、<code>ping</code>、<code>ssh</code>、<code>ps</code>、<code>kill</code>、<code>apt-get</code>、<code>netstart</code>、<code>grep、awk、sed</code></p><blockquote><p>作用就不写了，太基础了，除了最后的三剑客，其他不会就搜搜吧</p></blockquote><h2id="linux如何查看进程杀进程看端口">Linux如何查看进程、杀进程、看端口</h2><ul><li>看进程：ps aux：列出所有进程和信息</li><li>杀进程：kill -9 pid：强制杀死这个pid</li><li>看端口：<code>lsof -i:端口号</code>查看特定端口占用。或者用<code>netstat -tulnp | grep 端口号</code>显示监听在该端口的服务及其进程ID。</li></ul><h2 id="说一下selectpollepoll">说一下select、poll、epoll</h2><p>I/O多路复用通常通过select、poll、epoll等系统调用实现</p><ul><li>select：最古老的I/O多路复用机制，可以监视多个文件描述符的可读、可写和错误状态。然而select的效率可能随着监视的文件描述符数量的增加而降低。</li><li>poll：poll是select的一种改进，使用轮询检查多个文件描述符</li><li>epoll：Linux特有的IO多路复用机制，相较于select和poll，在处理大量文件描述符时更高效。使用事件通知的方式，只有在文件描述符就绪时才会通知应用程序，而不使用轮询。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day9(补)</title>
    <link href="/2024/08/18/leetcode-day9/"/>
    <url>/2024/08/18/leetcode-day9/</url>
    
    <content type="html"><![CDATA[<h1 id="找出字符串中第一个匹配项的下标"><ahref="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">找出字符串中第一个匹配项的下标</a></h1><blockquote><p>文章视频讲解：<ahref="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">代码随想录| 实现strStr()</a></p></blockquote><p>在母串中寻找子串，最优的算法就是KMP算法，十分经典，也很复杂，笔者从大一程序设计课上初接触到KMP到今天，已经写过4次KMP了，而这一次尝试纯手撕，仍然花了两个小时，最后还是倒在next数组求法上。功不唐捐，希望下一次再见KMP，能直接手撕出来。<strong>以下是个人偏感性理解，仅作参考</strong></p><h2 id="kmp更快的原因">KMP更快的原因</h2><p>暴力匹配就是把子串的头从0号一个一个往前加到m -n号，不匹配就加一。</p><p>而KMP不是无脑加一，会像动态规划那样记录，从而实现最优的最远的后移，最大程度减少匹配次数。</p><p>KMP像会记住之前已经匹配到了什么作为基业，在遇到挫折之后就不必从头开始，而是吃老本从基业再开始，直到把基业亏光再从头开始或者成功匹配。## KMP怎样记住哪些已经匹配过呢KMP用到了最长公共前后缀来记录哪些已经匹配过了。代码随想录里的说法是前缀表next[]### 什么是最长公共前后缀一个string的前缀就是除开最后一个元素的所有子串</p><p>后缀就是除开第一个元素的所有子串</p><p>比如对于<code>aacaab</code>来说：</p><p>前缀从长到短有：<code>aacaa</code>,<code>aaca</code>,<code>aac</code>,<code>aa</code>,<code>a</code></p><p>后缀从长到短有：<code>acaab</code>,<code>caab</code>,<code>aab</code>,<code>ab</code>,<code>b</code></p><p>最长公共前后缀就是前后缀里面相同的里面最长那一个</p><h3 id="什么是前缀表">什么是前缀表</h3><p>个人理解：</p><p>对于string来说，它的前缀表肯定和它的长度相同，前缀表的每一个值代表<strong>以当前位置结束的子串的最长公共前后缀长度</strong>。</p><p>比如对于串<code>aabaac</code>来说，其前缀表第一位就代表子串<code>a</code>的最长公共前后缀长度，即为0，因为只有一个，去掉第一个或者最后一个之后就没了；</p><p>其前缀表第二位就是1，代表子串<code>aa</code>的最长公共前后缀长度，因为去掉头尾之后都是<code>a</code>，而长度为1</p><p>所以<code>aabaac</code>的前缀表就为0 1 0 1 2 0</p><p><strong>一个特点</strong></p><p>如果子串的头尾都不相同，那么其最长公共前后缀长度肯定是0，因为其所有的前缀都有"头"，所有的后缀都有"尾"，肯定不会相同。</p><h3 id="前缀表怎么用呢">前缀表怎么用呢</h3><p>之前说到KMP记住之前匹配过哪些，失败之后不用从头开始，而是从"基业"开始，这里的"基业"就是公共前后缀。</p><p>如果匹配失败，失败这一位之前都是成功的，将视野缩小到已经匹配上的子串上面，这个子串的后缀是可以匹配上的，那么如果存在相同的前缀，则可以把相同的前缀往前移到后缀的位置，必定仍然匹配，这样就一下子提前了很多位，实现了"保底"</p><p>以上是抽象感性说法，下面上严谨代码：</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(haystack.<span class="hljs-built_in">size</span>() &lt; needle.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; prefix = <span class="hljs-built_in">next</span>(needle);<br>        <span class="hljs-type">int</span> m = haystack.<span class="hljs-built_in">size</span>(), n = needle.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= m;) &#123;<br>            <span class="hljs-keyword">if</span>(j == n) &#123;<br>                ans = i - n;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(haystack[i] == needle[j]) &#123;<br>                j++;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>)&#123;<br>                j = prefix[j - <span class="hljs-number">1</span>];<span class="hljs-comment">//回退吃老本</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>                j = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(s.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br><span class="hljs-comment">/*这一行可太妙了*/</span><span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) j = next[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(s[i] == s[j]) j++;<br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="重复的子字符串"><ahref="https://leetcode.cn/problems/repeated-substring-pattern/description/">重复的子字符串</a></h1><blockquote><p>文章视频讲解：<ahref="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">代码随想录| 重复的子字符串</a></p></blockquote><p>对于前缀表的深入理解和应用，建议打印出测试用例的前缀表，一看便知：重复子串第一次出现地方全是0，后面单调递增1、2、3、4……</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; pre = <span class="hljs-built_in">next</span>(s);<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(pre[len - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span> &amp;&amp; len % (len - pre[len - <span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(s.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++ )&#123;<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) j = ans[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(s[i] == s[j]) j++;<br>            ans[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深悼首次数模</title>
    <link href="/2024/08/07/%E6%B7%B1%E6%82%BC%E9%A6%96%E6%AC%A1%E6%95%B0%E6%A8%A1/"/>
    <url>/2024/08/07/%E6%B7%B1%E6%82%BC%E9%A6%96%E6%AC%A1%E6%95%B0%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="问题总结">问题总结</h1><p>首先总结此次数模的问题：</p><ol type="1"><li>Matlab语法文盲，包括但不限于：<ul><li>不关注数据类型，无意中把行向量当列向量计算</li><li>盲从GPT不自己看代码和参数，让GPT调整不合理参数，越调越不合理</li><li>粒子群的参数拿去跑遗传算法</li><li>不知道matlab文件后缀名含义</li><li>不知道figure可以直接选中调整，去一点一点调语句里的参数😅</li></ul></li><li>数学建模基础薄弱，包括但不限于：<ul><li>听不懂啥是多目标分析，以及其他各种名词</li><li>不知道啥是数学模型，只知道套算法模板和调库</li></ul></li><li>题目没看明白就走了很远，做完了发现初始参数都错了</li><li>跟队友交接混乱，一股脑把文件往群里丢，没有打包和说明文件结构</li><li>算法掌握模糊，忘记普通的Floyd是返回路径长度，需要的却是路径本身，浪费时间修改代码</li><li>思考不足，逻辑不顺，过于依赖网上的思路</li><li>数据不及时保存，文件结构混乱</li></ol><h1 id="踩过的坑">踩过的坑</h1><ol type="1"><li>行向量转列向量是：<code>vector = vector(:);</code>或者<code>v = v';</code>，</li></ol><p>注意：单引号可以将列向量再转为行向量的；冒号不管是行向量还是列向量，最终转换的结果都将是列向量</p><ol start="2" type="1"><li>matlab定义矩阵的方法：<code>matrix = zeros(row, col);</code>，初始化一个<spanclass="math inline">\(row\)</span>行<spanclass="math inline">\(col\)</span>列的零矩阵</li><li>存放不等长向量的方法：用单元数组来求，<code>a = cell(i, j);</code>初始化一个<spanclass="math inline">\(i\)</span>行，每行<spanclass="math inline">\(j\)</span>个元素的单元数组，单元里可以是任何变量</li><li>行向量为某个值赋值方法：<code>a(i) = y;</code>将<spanclass="math inline">\(y\)</span> 赋给行向量<spanclass="math inline">\(a\)</span> 的第<spanclass="math inline">\(i\)</span> 列</li></ol><ul><li><p>使用<code>a(1,:)=[1 1 1]</code>方式对矩阵一行进行赋值</p></li><li><p>各种赋值方法见：<ahref="http://t.csdnimg.cn/FoVl3">csdn博客</a></p></li></ul><ol start="5" type="1"><li>matlab各种括号访问规则：<ahref="http://t.csdnimg.cn/DF1Gx">csdn博客</a></li><li>matlab的rand()返回的是0到1之间的一个数</li><li>多去mathworks搜方法重载和参数含义😭</li></ol><h1 id="下次要做">下次要做</h1><ol type="1"><li>预备在python上重演被语法暴捶</li><li>准备好方便的手册，方便脱离GPT翻阅</li><li>保存所有的图表和数据，丰富附件</li><li>做好文件结构管理，和队友交接的时候打包整个环境</li><li>也许可以冲一个chatGPT Plus。。</li></ol><blockquote><p>补个后续，虽然犯了很多蠢无底线的错误，但是结果不错，拿了国一，可能是华数杯比较水的缘故</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)</title>
    <link href="/2024/08/02/org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found/"/>
    <url>/2024/08/02/org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found/</url>
    
    <content type="html"><![CDATA[<h1id="org.apache.ibatis.binding.bindingexception-invalid-bound-statement-not-found">org.apache.ibatis.binding.BindingException:Invalid bound statement (not found)</h1><h2 id="种可能的原因">10种可能的原因</h2><ol type="1"><li>namespace与实际接口的全限定名不一致</li><li>XML文件头出错，一般是复制错或者打错字</li><li>SQL语句id出错，id与实际的接口方法名不一致</li><li>没写对resultType中实体类的全限定名</li><li>resources文件夹下的包实际上没有分层次，只是加了点</li><li>target里面没有XML，没有构造进去</li><li>用成了mybatis-plus，配置的却是mybatis</li><li>XML文件和接口的所在的包名路径以及名称不一致，而mybatis-location又没有配置好。比如XML和接口都放在了java文件夹下，而又没有配置@MapperScan或者mybatis-location</li><li>启动类没有加@MapperScan或接口没有加<span class="citation"data-cites="Mapper注解">@Mapper注解</span></li><li><del>mybatis.type-aliases-type没有配置或配置错误</del>(实证没配置也行)</li><li>你以为的XML文件实际没有后缀名</li></ol><h2 id="问题展示">问题展示</h2><p><strong>XML文件</strong></p><figure><img src="https://s3.bmp.ovh/imgs/2024/08/01/0ca92b962e2eb7f7.png"alt="xml文件" /><figcaption aria-hidden="true">xml文件</figcaption></figure><p><strong>项目结构</strong></p><figure><img src="https://s3.bmp.ovh/imgs/2024/08/01/6593aa3aa346b24f.png"alt="目录树" /><figcaption aria-hidden="true">目录树</figcaption></figure><p><strong>target目录</strong></p><figure><img src="https://s3.bmp.ovh/imgs/2024/08/01/cf97150d678f2c27.png"alt="target目录树" /><figcaption aria-hidden="true">target目录树</figcaption></figure><p><strong>application.properties文件</strong></p><p><img src = 'https://s3.bmp.ovh/imgs/2024/08/02/2f72df281337396e.png' ></p><p><strong>Mapper接口</strong></p><p><img src = 'https://s3.bmp.ovh/imgs/2024/08/01/29ab84bc2404350f.png' ></p><p><strong>启动类</strong></p><p><img src = 'https://s3.bmp.ovh/imgs/2024/08/01/18df1d05ea3ca0f1.png' ></p><p><strong>报错信息</strong></p><p><img src = 'https://s3.bmp.ovh/imgs/2024/08/01/dd32ece0648c3d1f.png' ></p><h2 id="问题描述">问题描述</h2><p>问题在于XML没有跟Mapper接口关联上，通过注解开发是有效的，但换成XML映射就报错。</p><p>已经检查过id、namespace、resultType、XML文件头等是否出现打错。</p><p>配置了mybatis的实体类位置、xml位置、添加了@Mapper注解、为启动类添加了@MapperScan注解、检查了target中有没有XML、检查了是否用成了mybatis-plus。</p><p>MybatisX插件已经匹配上了，出现红蓝鸟标识。</p><p>最终仍然没用，增删改查接口没一个能用。</p><h2 id="解决过程">解决过程</h2><p>尝试了能搜到的所有方法仍无效后。</p><p>我在项目中新建了一个模块：</p><ul><li>创建了mapper包和一个pojo包</li><li>复制了一个实体类和一个select * 的查询接口过来</li><li>复制了application.properties的连接数据库的配置</li><li>在resources下新建包，又创建了一个XML，填好内容后编写了一个简单测试方法来调用这个select*接口。</li></ul><p>成功了，xml成功与接口关联并且select *了。证明是可以实现XML与接口关联的。</p><p>加上controller层、service层，仍然可以映射，访问成功。</p><p>于是开两个窗口与新建的模块仔细对比，发现除了模块名完全没区别，那么区别就只能在IDE上看不到的位置。</p><p>最后发现了，就是原因5，实际文件夹没有按点dot分层设置，实际文件结构是这样的:com--newyear--goovermanege<strong>.</strong>mapper</p><p>前两级目录分开了，但是最后一层目录名却是<code>goovermanage.mapper</code>，于是手动拆分，再次测试，成功。</p><p>原来是这么小一个BUG。。真是菜啊，查了两天下午才查出来😅</p><h2 id="预防措施">预防措施</h2><p>在resourses下创建分级目录时，不要打点，打"/"。比如com.ABC.mapper就打成com/ABC/mapper。</p><p>这样实际的文件就会分层，而不是简单地在文件名里加点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些算法小记录</title>
    <link href="/2024/07/30/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/07/30/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>目前处于烂尾状态。。。我很抱歉。。</p></blockquote><h1 id="同余定理">同余定理</h1><p>给定一个正整数<span class="math inline">\(m\)</span>，如果两个整数<span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 满足 <spanclass="math inline">\((a-b)\)</span> 能够被m整除，即 <spanclass="math inline">\((a-b)/m\)</span> 得到一个整数，那么就称整数 <spanclass="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 对模 <spanclass="math inline">\(m\)</span> 同余，记作 <spanclass="math inline">\(a≡b(mod\ m)\)</span>。</p><p>两个整数<spanclass="math inline">\(a、b\)</span>，若它们除以整数<spanclass="math inline">\(m\)</span>的余数相等，则称整数 <spanclass="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 对模 <spanclass="math inline">\(m\)</span> 同余，记作 <spanclass="math inline">\(a≡b(mod\ m)\)</span>。</p><p>即 <span class="math display">\[(a-b)\ mod\ m = 0\ ⇔\ a\ mod\ m\ =\ b\ mod\ m\]</span> 定理适用于对一个表达式取模时拆括号。</p><h1 id="费马小定理">费马小定理</h1><p>整数 <span class="math inline">\(a\)</span> 和素数 <spanclass="math inline">\(p\)</span>，有： <span class="math display">\[a^{p-1}\ \equiv 1\ (mod\ p)\]</span> ps. latex恒等于符号使用<code>\equiv</code>，这部分latex代码没写过，可以看源码复习复习</p><p>定理适用于对幂取模时快速计算，如取<spanclass="math inline">\(2^{100}\)</span>模<spanclass="math inline">\(13\)</span>： <span class="math display">\[\begin{aligned}2^{100}&amp; \equiv 2^{12\times8+4} \\&amp; \equiv (2^{12})^8\cdot2^4 \\&amp; \equiv 1^8\cdot16 \\&amp; \equiv 16 \\&amp; \equiv 3 \pmod{13}\end{aligned}\]</span> 余数就是<span class="math inline">\(3\)</span>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>完结撒花</title>
    <link href="/2024/07/27/%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1/"/>
    <url>/2024/07/27/%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1/</url>
    
    <content type="html"><![CDATA[<p>🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉</p><p>五月末在b站评论抽奖，意外抽中了随想录的名额。之前也偶尔跟着随想录刷过题，觉得随想录的题解写得很易懂，而且难度对于我这种算法小菜来说也比较合适。</p><p>虽然算法群的热度只持续了不到一个月，但是这种集体感比一个人写题要好得多🤗，每天有任务，也可以假想其他录友在监督自己，到后期打卡人数越来越少，自己能跟上进度也有一点小骄傲😎。自律不行就靠他律，比起之前断断续续的刷题，这次能够坚持两个月刷题已是巨大进步。为了打卡还搞了一个个人博客玩。中间也落下过几次，期末考试更是落下一周，让我知道原来只是坚持每天3道题都是如此艰难，但是最后还是跟上来了。这两个月对我的影响不仅是更会写力扣题，也让我知道了规律地坚持做一件事就是改变的方法💪。</p><p>刷题的最大障碍是偷懒和遗忘：遇到难题不去思考，哪怕看答案都不想去看，这是不行的；刷过题后不去复习重刷，时间一久等于没刷，再一次遇到，倒是知道自己做过，但是写不出来了。两数之和在一个月后再写都写得磕磕绊绊，一刷还是远远不够的，毕竟dp刷100题才算入门，总量刷到500题才能够说算法入门。今后继续刷题，也会二刷三刷随想录来巩固。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day64</title>
    <link href="/2024/07/25/leetcode-day64/"/>
    <url>/2024/07/25/leetcode-day64/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0097.小明逛公园.html">Floyd</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0126.骑士的攻击astar.html">A*</a></li></ul><h1 id="floyd">Floyd</h1><h3 id="题目"><strong>题目</strong></h3><p>一个公司在全国有 <code>n</code>个分部，它们之间有的有道路连接。一开始，所有分部通过这些道路两两之间互相可以到达。</p><p>公司意识到在分部之间旅行花费了太多时间，所以它们决定关闭一些分部（<strong>也可能不关闭任何分部</strong>），同时保证剩下的分部之间两两互相可以到达且最远距离不超过<code>maxDistance</code> 。</p><p>两个分部之间的 <strong>距离</strong> 是通过道路长度之和的<strong>最小值</strong> 。</p><p>给你整数 <code>n</code> ，<code>maxDistance</code> 和下标从<strong>0</strong> 开始的二维整数数组 <code>roads</code> ，其中<code>roads[i] = [ui, vi, wi]</code> 表示一条从 <code>ui</code> 到<code>vi</code> 长度为 <code>wi</code>的 <strong>无向</strong>道路。</p><p>请你返回关闭分部的可行方案数目，满足每个方案里剩余分部之间的最远距离不超过<code>maxDistance</code>。</p><p><strong>注意</strong>，关闭一个分部后，与之相连的所有道路不可通行。</p><p><strong>注意</strong>，两个分部之间可能会有多条道路。</p><h3 id="思路"><strong>思路</strong></h3><p>枚举每种关闭方案，使用Floyd求最短路，然后判断是否合法。</p><p>详见代码注释</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//跟敲学习，行行注释</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberOfSets</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> maxDistance, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrix</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, INT_MAX / <span class="hljs-number">2</span>));<span class="hljs-comment">//floyd需要的邻接矩阵</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; road : roads) &#123;<span class="hljs-comment">//根据roads，初始化邻接矩阵</span><br>            <span class="hljs-type">int</span> x = road[<span class="hljs-number">0</span>], y = road[<span class="hljs-number">1</span>], weight = road[<span class="hljs-number">2</span>];<span class="hljs-comment">//路径两端xy，weight为路的权重</span><br>            matrix[x][y] = <span class="hljs-built_in">min</span>(matrix[x][y], weight);<br>            matrix[y][x] = <span class="hljs-built_in">min</span>(matrix[y][x], weight);<span class="hljs-comment">//无向图，视作两条有向边</span><br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n);<span class="hljs-comment">//去掉一些节点后的邻接矩阵</span><br>        <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> s) -&gt; <span class="hljs-type">bool</span> &#123;<span class="hljs-comment">//lambda表达式，相当于bool check(int s)&#123;&#125;，同时外部变量都可访问</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<span class="hljs-comment">//参数s的前n位代表是否取这一个节点</span><br>                <span class="hljs-keyword">if</span>((s &gt;&gt; i) &amp; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//若s的i位为1，则取</span><br>                    f[i] = matrix[i];<span class="hljs-comment">//只将保留的节点信息保存，去掉的都变成了无穷</span><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k &lt; n;k++) &#123;<span class="hljs-comment">//遍历n个节点，进行插值</span><br>                <span class="hljs-keyword">if</span>(((s &gt;&gt; k) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//若s的k位为0，不选</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<span class="hljs-comment">//k位为1，选择该节点，下一步遍历整个图，检查最优值是否发生变化</span><br>                    <span class="hljs-keyword">if</span>(((s &gt;&gt; i) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//若s的i位为0，不选</span><br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<span class="hljs-comment">//检查从i到其他所有节点的最短路是否变化</span><br>                        f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][k] + f[k][j]);<span class="hljs-comment">//维护</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//检查s对应的选择情况，是否满足条件</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>                <span class="hljs-keyword">if</span>(((s &gt;&gt; i) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//没选，跳过</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; i;j++) &#123;<span class="hljs-comment">//无向图，靠后的节点覆盖靠前的节点，邻接矩阵变三角矩阵</span><br>                    <span class="hljs-keyword">if</span>((s &gt;&gt; j) &amp; <span class="hljs-number">1</span> &amp;&amp; f[i][j] &gt; maxDistance) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;s &lt; (<span class="hljs-number">1</span> &lt;&lt; n);s++) &#123;<span class="hljs-comment">//枚举子集</span><br>            ans += <span class="hljs-built_in">check</span>(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="a-star">A-star</h1><h3 id="题目-1"><strong>题目</strong></h3><p>在象棋中，马和象的移动规则分别是“马走日”和“象走田”。现给定骑士的起始坐标和目标坐标，要求根据骑士的移动规则，计算从起点到达目标点所需的最短步数。</p><p>棋盘大小 1000 x 1000（棋盘的 x 和 y 坐标均在 [1, 1000]区间内，包含边界）</p><h6 id="输入描述">输入描述</h6><p>第一行包含一个整数 n，表示测试用例的数量，1 &lt;= n &lt;= 100。</p><p>接下来的 n 行，每行包含四个整数 a1, a2, b1,b2，分别表示骑士的起始位置 (a1, a2) 和目标位置 (b1, b2)。</p><h6 id="输出描述">输出描述</h6><p>输出共 n行，每行输出一个整数，表示骑士从起点到目标点的最短路径长度。</p><h6 id="提示信息">提示信息</h6><p>骑士移动规则如图，红色是起始位置，黄色是骑士可以走的地方。</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20240626104833.png"alt="盗链随想录" /><figcaption aria-hidden="true">盗链随想录</figcaption></figure><h3 id="思路-1"><strong>思路</strong></h3><p>推荐看随想录的图： <ahref="https://www.programmercarl.com/kamacoder/0126.骑士的攻击astar.html#思路">代码随想录| A-star</a></p><p>A*是启发式搜索，一开始知道要去的地方在哪里，所以根据终点位置，和具体的题目情景，选择合适的距离计算方式(曼哈顿、欧拉、切比雪夫、信息熵……)，根据距离来选择下一步怎么走。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> moves[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> dir[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>&#125;;<br><span class="hljs-type">int</span> b1, b2;<br><span class="hljs-comment">// F = G + H</span><br><span class="hljs-comment">// G = 从起点到该节点路径消耗</span><br><span class="hljs-comment">// H = 该节点到终点的预估消耗</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Knight</span>&#123;<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-type">int</span> g,h,f;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Knight &amp; k) <span class="hljs-type">const</span>&#123;  <span class="hljs-comment">// 重载运算符， 从小到大排序</span><br>     <span class="hljs-keyword">return</span> k.f &lt; f;<br>    &#125;<br>&#125;;<br><br>priority_queue&lt;Knight&gt; que;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Heuristic</span><span class="hljs-params">(<span class="hljs-type">const</span> Knight&amp; k)</span> </span>&#123; <span class="hljs-comment">// 欧拉距离</span><br>    <span class="hljs-keyword">return</span> (k.x - b1) * (k.x - b1) + (k.y - b2) * (k.y - b2); <span class="hljs-comment">// 统一不开根号，这样可以提高精度</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">astar</span><span class="hljs-params">(<span class="hljs-type">const</span> Knight&amp; k)</span></span><br><span class="hljs-function"></span>&#123;<br>    Knight cur, next;<br>que.<span class="hljs-built_in">push</span>(k);<br><span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cur=que.<span class="hljs-built_in">top</span>(); que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(cur.x == b1 &amp;&amp; cur.y == b2)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>&#123;<br>next.x = cur.x + dir[i][<span class="hljs-number">0</span>];<br>next.y = cur.y + dir[i][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span>(next.x &lt; <span class="hljs-number">1</span> || next.x &gt; <span class="hljs-number">1000</span> || next.y &lt; <span class="hljs-number">1</span> || next.y &gt; <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(!moves[next.x][next.y])<br>&#123;<br>moves[next.x][next.y] = moves[cur.x][cur.y] + <span class="hljs-number">1</span>;<br><br>                <span class="hljs-comment">// 开始计算F</span><br>next.g = cur.g + <span class="hljs-number">5</span>; <span class="hljs-comment">// 统一不开根号，这样可以提高精度，马走日，1 * 1 + 2 * 2 = 5</span><br>                next.h = <span class="hljs-built_in">Heuristic</span>(next);<br>                next.f = next.g + next.h;<br>                que.<span class="hljs-built_in">push</span>(next);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, a1, a2;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; b1 &gt;&gt; b2;<br>        <span class="hljs-built_in">memset</span>(moves,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(moves));<br>        Knight start;<br>        start.x = a1;<br>        start.y = a2;<br>        start.g = <span class="hljs-number">0</span>;<br>        start.h = <span class="hljs-built_in">Heuristic</span>(start);<br>        start.f = start.g + start.h;<br><span class="hljs-built_in">astar</span>(start);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) que.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 队列清空</span><br>cout &lt;&lt; moves[b1][b2] &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day63</title>
    <link href="/2024/07/25/leetcode-day63/"/>
    <url>/2024/07/25/leetcode-day63/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li>SPFA<ul><li><ahref="https://www.programmercarl.com/kamacoder/0094.城市间货物运输I-SPFA.html#背景">无负权回路SPFA</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0095.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93II.html">负权回路SPFA</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0096.城市间货物运输III.html#思路">单源有限最短路SPFA</a></li></ul></li></ul><h1 id="无负权回路spfa">无负权回路SPFA</h1><h3 id="题目"><strong>题目</strong></h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1到 n的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本-政府补贴</strong>。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>请找出从城市 1 到城市 n的所有可能路径中，综合政府补贴后的最低运输成本。如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。</p><p><strong>城市 1 到城市 n之间可能会出现没有路径的情况，同时保证道路网络中不存在任何负权回路。</strong></p><h6 id="输入描述">输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达t 号城市，道路权值为 v （单向图）。</p><h6 id="输出描述">输出描述</h6><p>如果能够从城市 1 到连通到城市 n，请输出一个整数，表示运输成本。如果该整数是负数，则表示实现了盈利。如果从城市1 没有路径可达城市 n，请输出 "unconnected"。</p><h3 id="思路"><strong>思路</strong></h3><p>昨天使用Bellman_ford求解了该问题，SPFA为Bellman_ford的队列优化版。</p><p>上集提到，对全部边松弛一次，相当于对起点出发一条边的距离求了一次最短路。</p><p>那么在第二次全边松弛的时候，就可以不用再对起点出发一条边松弛了，直接拿结果即可。</p><p>所以，<strong>只需要对上一次松弛时更新过的节点作为出发点所连接的边进行松弛</strong>（carl说法）</p><p>就是继承上一次已经确定下来的点，再出发一条边。</p><p>优化的点在于，如果不使用队列优化，就按顺序去松弛，很容易松弛到未计算过节点延申出的边。而使用队列，则保证了在队列(是个数据结构能存就行，没有顺序要求)中的一定是计算过的节点，避免了无用的"松弛"</p><p>事实上，在未计算过的节点的延申边做的松弛无效，以初始的minDist举例比较好理解，如果节点未计算过，则其minDist为INT_MAX，如果对该点的边计算，结果肯定是有问题的。</p><p>所以，松弛n次得到距离n的点的最短路，已经不适用这里了，因为松弛已经不针对全图，次数的标准变得模糊。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, val;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; val;<br>        grid[x].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(y, val));<br>    &#125;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>    minDist[start] = <span class="hljs-number">0</span>;<br>    <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;e : grid[cur]) &#123;<br>            <span class="hljs-type">int</span> x = cur, y = e.first, wt = e.second;<br>            <span class="hljs-keyword">if</span>(minDist[y] &gt; minDist[x] + wt) &#123;<br>                minDist[y] = minDist[x] + wt;<span class="hljs-comment">//更新更短的路径</span><br>                q.<span class="hljs-built_in">push</span>(y);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">&quot;unconnected&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="负权回路spfa">负权回路SPFA</h1><h3 id="题目-1"><strong>题目</strong></h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1到 n的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本-政府补贴</strong>。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>然而，在评估从城市 1 到城市 n的所有可能路径中综合政府补贴后的最低运输成本时，存在一种情况：<strong>图中可能出现负权回路。</strong>负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。为了避免货物运输商采用负权回路这种情况无限的赚取政府补贴，算法还需检测这种特殊情况。</p><p>请找出从城市 1 到城市 n的所有可能路径中，综合政府补贴后的最低运输成本。同时能够检测并适当处理负权回路的存在。</p><p><strong>城市 1 到城市 n 之间可能会出现没有路径的情况</strong></p><h6 id="输入描述-1">输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达t 号城市，道路权值为 v。</p><h6 id="输出描述-1">输出描述</h6><p>如果没有发现负权回路，则输出一个整数，表示从城市 <code>1</code>到城市 <code>n</code>的最低运输成本（包括政府补贴）。如果该整数是负数，则表示实现了盈利。如果发现了负权回路的存在，则输出"circle"。如果从城市 1 无法到达城市 n，则输出 "unconnected"。</p><h3 id="思路-1"><strong>思路</strong></h3><p>n-1次松弛就能找到所有点的最短路径，存在负权回路，当且仅当第n次松弛得到更短的路径。</p><p>所以只需要多松弛一次，如果出现更短，则有回路，如果没有，则没有负权回路。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, val;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; val;<br>        grid[x].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(y, val));<br>    &#125;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>    minDist[start] = <span class="hljs-number">0</span>;<br>    <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//新增代码，记录节点加入队列几次</span><br>    count[start]++;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;e : grid[cur]) &#123;<br>            <span class="hljs-type">int</span> x = cur, y = e.first, wt = e.second;<br>            <span class="hljs-keyword">if</span>(minDist[y] &gt; minDist[x] + wt) &#123;<br>                minDist[y] = minDist[x] + wt;<span class="hljs-comment">//更新更短的路径</span><br>                q.<span class="hljs-built_in">push</span>(y);<br>                count[y]++;<span class="hljs-comment">//新增代码</span><br>                <span class="hljs-keyword">if</span>(count[y] == n) &#123;<span class="hljs-comment">//如果有节点加入队列超过n-1次，说明有负权回路</span><br>                    flag = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//清空队列</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag) cout &lt;&lt; <span class="hljs-string">&quot;circle&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">&quot;unconnected&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单源有限最短路spfa">单源有限最短路SPFA</h1><h3 id="题目-2"><strong>题目</strong></h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1到 n的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本-政府补贴。</strong>权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>请计算在最多经过 k 个城市的条件下，从城市 src 到城市 dst的最低运输成本。</p><h6 id="输入描述-2">输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达t 号城市，道路权值为 v。</p><p>最后一行包含三个正整数，src、dst、和 k，src 和 dst 为城市编号，从 src到 dst 经过的城市数量限制。</p><h6 id="输出描述-2">输出描述</h6><p>输出一个整数，表示从城市 src 到城市 dst的最低运输成本，如果无法在给定经过城市数量限制下找到从 src 到 dst的路径，则输出 "unreachable"，表示不存在符合条件的运输方案。</p><h3 id="思路-2"><strong>思路</strong></h3><p>题目的不同点在于，有了途径城市数量限制。也就是从一个点出发几条边有限制，也就是松弛次数有限制，那么针对次数过少，就得找到n-1次松弛前多种可能中最短的一条；次数过多，就得多走负权回路降本。</p><p>控制次数，可以使用层序的思想(或者叫写法)，而且还需要控制minDist的更新，由于SPFA的原写法可能在一个循环内更新了多次同一个值，这就无法控制中间节点数量了，得每一次都完全依赖前一轮循环的计算结果，避免超限；而选择更短的路，可以直接使用SPFA的原写法逻辑。</p><p>优化：对于同一层的节点，可能会有相互通的道路，这条路可以走，但是对于已经处理过的同一层节点就不需要重复入队了。开一个boolused数组记录本层哪些节点已经处理过，但是松弛仍需进行，只是不再入队。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, wt;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; wt;<br>        grid[x].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(y, wt));<br>    &#125;<br>    <span class="hljs-type">int</span> start, end, limit;<br>    cin &gt;&gt; start &gt;&gt; end &gt;&gt; limit;<br>    limit++;<span class="hljs-comment">//经过限制-&gt;步数限制</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">copy</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    minDist[start] = <span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">while</span>(limit-- &amp;&amp; !q.<span class="hljs-built_in">empty</span>()) &#123;<br>        copy = minDist;<br>        size = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">while</span>(size--) &#123;<br>            <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp; e : grid[cur]) &#123;<br>                <span class="hljs-type">int</span> y = e.first;<br>                <span class="hljs-type">int</span> wt = r.second;<br>                <span class="hljs-keyword">if</span>(minDist[y] &gt; minDist[cur] + wt) &#123;<br>                    minDist[y] = minDist[cur] + wt;<br>                    <span class="hljs-keyword">if</span>(used[y]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//跳过同层已处理节点</span><br>                    used[y] = <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(y);<br>                &#125;<br>                <br>&#125;<br>&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">&quot;unconnctable&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day62</title>
    <link href="/2024/07/23/leetcode-day62/"/>
    <url>/2024/07/23/leetcode-day62/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0047.%E5%8F%82%E4%BC%9Adijkstra%E5%A0%86.html">Dijkstra堆优化版</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I.html">Bellman_ford</a></li></ul><h1 id="dijkstra堆优化版">Dijkstra堆优化版</h1><h3 id="题目"><strong>题目</strong></h3><p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p><p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p><p>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个正整数，第一个正整数 N 表示一共有 N个公共汽车站，第二个正整数 M 表示有 M 条公路。</p><p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p><h6 id="输出描述">输出描述</h6><p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p><h3 id="思路"><strong>思路</strong></h3><p>朴素版dijkstra两次遍历寻找当前点的最近点，以点为中心。堆优化以边的角度出发，直接排序边，然后从边的小顶堆中取出最短边，即是距离源点最近的点所需的边，点和边权都拿到了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmp</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.second &lt; b.second;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">g</span>(N + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; M;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, wt;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; wt;<br>        g[x].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(y, wt));<br>    &#125;<br>    <br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, cmp&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, INT_MAX / <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <br>    minDist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">if</span>(used[cur.first]) <span class="hljs-keyword">continue</span>;<br>        <br>        <span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; e : g[cur.first]) &#123;<br>            <span class="hljs-keyword">if</span>(minDist[e.first] &gt; cur.second + e.second) &#123;<br>                minDist[e.first] = cur.second + e.second;<br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(e.first, minDist[e.first]));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(minDist.<span class="hljs-built_in">back</span>() != INT_MAX / <span class="hljs-number">2</span>)cout &lt;&lt; minDist.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="bellman_ford">Bellman_ford</h1><h3 id="题目-1"><strong>题目</strong></h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1到 n的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本-政府补贴</strong>。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>请找出从城市 1 到城市 n的所有可能路径中，综合政府补贴后的最低运输成本。如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。</p><p><strong>城市 1 到城市 n之间可能会出现没有路径的情况，同时保证道路网络中不存在任何负权回路。</strong></p><h6 id="输入描述-1">输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达t 号城市，道路权值为 v （单向图）。</p><h6 id="输出描述-1">输出描述</h6><p>如果能够从城市 1 到连通到城市 n，请输出一个整数，表示运输成本。如果该整数是负数，则表示实现了盈利。如果从城市1 没有路径可达城市 n，请输出 "unconnected"。</p><h3 id="思路-1"><strong>思路</strong></h3><p>初次接触单源负权图最短路，跟敲学习。</p><p>由于有负权道路，所以不能dijkstra，需要采取“松弛”操作。</p><p>“松弛”理解为：如果通过 A 到 B这条边可以获得更短的到达B节点的路径，就更新<code>minDist[B] = minDist[A] + value</code>的过程。要点在于：</p><ul><li>松弛是对边的操作，对边进行“松弛”</li><li>对所有边松弛一次，相当于计算起点出发走一条边的节点的最短距离</li><li>由于n个点的图，起点终点最多n-1条边，所以松弛n-1次绝对可求出最短距离，所有点到起点的最短距离都能求。</li></ul><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, wt;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; wt;<br>        grid.<span class="hljs-built_in">emplace_back</span>(std::initializer_list&lt;<span class="hljs-type">int</span>&gt;&#123;x, y, wt&#125;);<br>    &#125;<span class="hljs-comment">//用push_back就可以直接大括号，但是emplace_back就必须传初始化器</span><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX / <span class="hljs-number">2</span>)</span></span>;<br>    minDist[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;<br>        <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp; e : grid) &#123;<br>            <span class="hljs-type">int</span> from = e[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> to = e[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> wt = e[<span class="hljs-number">2</span>];<br>            <br>            <span class="hljs-keyword">if</span>(minDist[from] != INT_MAX / <span class="hljs-number">2</span> &amp;&amp; minDist[to] &gt; minDist[from] + wt)<br>                minDist[to] = minDist[from] + wt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(minDist.<span class="hljs-built_in">back</span>() == INT_MAX / <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;unconnected&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist.<span class="hljs-built_in">back</span>();<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day61</title>
    <link href="/2024/07/22/leetcode-day61/"/>
    <url>/2024/07/22/leetcode-day61/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://kamacoder.com/problempage.php?pid=1191">软件构建 |拓扑排序</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0117.软件构建.html">参加科学大会| dij</a></li></ul><h1 id="软件构建-拓扑排序">软件构建 | 拓扑排序</h1><h3 id="题目"><strong>题目</strong></h3><p>某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N -1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 &lt;= A, B &lt;= N -1）。请编写一个算法，用于确定文件处理的顺序。</p><h6 id="输入描述">输入描述</h6><p>第一行输入两个正整数 N, M。表示 N 个文件之间拥有 M 条依赖关系。</p><p>后续 M 行，每行两个正整数 S 和 T，表示 T 文件依赖于 S 文件。</p><h6 id="输出描述">输出描述</h6><p>输出共一行，如果能处理成功，则输出文件顺序，用空格隔开。</p><p>如果不能成功处理（相互依赖），则输出 -1。</p><h3 id="思路"><strong>思路</strong></h3><p>拓扑排序不是关键路径，别学混了。拓扑排序很简单，每次找入度为0的点就行。实现的时候注意代码细节。<del>竟然WA了4发，丢人啊</del></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    <span class="hljs-keyword">if</span>(N == <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(N == <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">rely</span>(N);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(N, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; M;i++) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        inDegree[b]++;<br>        rely[a].<span class="hljs-built_in">emplace_back</span>(b);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(N, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(;ans.<span class="hljs-built_in">size</span>() &lt; N;) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; N;j++) &#123;<br>            <span class="hljs-keyword">if</span>(inDegree[j] == <span class="hljs-number">0</span> &amp;&amp; !used[j]) &#123;<br>                ans.<span class="hljs-built_in">emplace_back</span>(j);<br>                used[j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">while</span>(!rely[j].<span class="hljs-built_in">empty</span>()) &#123;<br>                    inDegree[rely[j].<span class="hljs-built_in">back</span>()]--;<br>                    rely[j].<span class="hljs-built_in">pop_back</span>();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<span class="hljs-comment">//这里就是细节，如果想一次完全遍历找到所有入度0</span><br>                <span class="hljs-comment">//有点不好实现，没想出来，一直试，都是在这个地方错，最后摆烂了</span><br>                <span class="hljs-comment">//放弃一轮找多个，见好就收。</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == N - <span class="hljs-number">1</span>) &#123;<br>                cout &lt;&lt; <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i++) &#123;<br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>    cout &lt;&lt; ans.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参加科学大会-dij">参加科学大会 | dij</h1><h3 id="题目-1"><strong>题目</strong></h3><p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p><p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p><p>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</p><h6 id="输入描述-1">输入描述</h6><p>第一行包含两个正整数，第一个正整数 N 表示一共有 N个公共汽车站，第二个正整数 M 表示有 M 条公路。</p><p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p><h6 id="输出描述-1">输出描述</h6><p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p><h3 id="思路-1"><strong>思路</strong></h3><p>dijkstra算法的思想就是，维护一个最近距离表，dijkstra算法应用于单源最短路场景，所以只需要一行，记录源点到其他点的最短距离，最后一个点就是终点。一个一个点标记访问，一开始无法到达的点距离设为<spanclass="math inline">\(\infty\)</span>，能够到达的点就更新距离。每次选取最近的点标记访问，同时依据这个点更新源点到其他点的最近距离。</p><p>参照carl的三部曲：</p><ul><li>第一步，选源点到哪个节点近且该节点未被访问过</li><li>第二步，该最近节点被标记访问过</li><li>第三步，更新非访问节点到源点的距离（即更新minDist数组）</li></ul><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(N + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N + <span class="hljs-number">1</span>, INT_MAX / <span class="hljs-number">2</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; M;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, wt;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; wt;<br>        g[x][y] = wt;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(N, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, INT_MAX / <span class="hljs-number">2</span>)</span></span>;<br>    minDist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> minVal = INT_MAX / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= N;j++) &#123;<br>            <span class="hljs-keyword">if</span>(minDist[j] &lt; minVal &amp;&amp; !used[j]) &#123;<br>                minVal = minDist[j];<br>                cur = j;<br>            &#125;<br>        &#125;<br>        used[cur] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= N;j++) &#123;<br>            <span class="hljs-keyword">if</span>(!used[j] &amp;&amp; g[cur][j] != INT_MAX / <span class="hljs-number">2</span> &amp;&amp;minVal + g[cur][j] &lt; minDist[j]) &#123;<br>                minDist[j] = minVal + g[cur][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(minDist.<span class="hljs-built_in">back</span>() != INT_MAX / <span class="hljs-number">2</span>)cout &lt;&lt; minDist.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>前几天有一道题也是dij，可以回去看看。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day59</title>
    <link href="/2024/07/20/leetcode-day59/"/>
    <url>/2024/07/20/leetcode-day59/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://kamacoder.com/problempage.php?pid=1053">寻宝</a></li><li><ahref="https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/description/">将石头分散到网格的最少移动次数</a><span class="label label-warning">medium</span></li></ul><h1 id="寻宝">寻宝</h1><h2 id="题目"><strong>题目</strong></h2><p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p><p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将所有岛屿联通起来（注意：这是一个无向图）。</p><p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个整数V 和 E，V代表顶点数，E代表边数。顶点编号是从1到V。例如：V=2，一个有两个顶点，分别是1和2。</p><p>接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2为边的起点和终点，val代表边的权值。</p><h6 id="输出描述">输出描述</h6><p>输出联通所有岛屿的最小路径总距离。</p><h2 id="思路"><strong>思路</strong></h2><p>Prim和Kruskal都是求最小生成树的算法。</p><h3 id="prim算法">Prim算法</h3><p>Prim是每次往树中加节点，第一个节点随便选，然后：</p><ol type="1"><li>获取其他点距离树的最短距离</li><li>选取距离树最近的点加入树中</li><li>更新其他点距离树的最近距离</li></ol><p>使用used数组判断点是否加入，只需选取 <spanclass="math inline">\(n-1\)</span> 次点即可构成最小生成树。</p><h2 id="kruskal算法">Kruskal算法</h2><p>Kruskal是每次往树中加边，只要不是树内的边，都可以往里加，从小到大：</p><ol type="1"><li>获取图内最短边</li><li>若该边不在树内，则加入树内，否则跳过</li></ol><p>具体代码实现要注意，不能像Prim那样直接使用used数组判断是否将所有点加入树，Kruskal中途是不连通的，需要使用并查集来判断是否连通，否则会缺边。</p><h2 id="代码">代码</h2><h3 id="prim">Prim</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> V, E;<br>    cin &gt;&gt; V &gt;&gt; E;<br>    vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(V + <span class="hljs-number">1</span>, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; E;i++) &#123;<br>        <span class="hljs-type">int</span> x, y, wt;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; wt;<br>        grid[x].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(y, wt));<br>        grid[y].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(x, wt));<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(V + <span class="hljs-number">1</span>, INT_MAX / <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(V + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    visited[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    minDist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; V;i++)&#123;<br>        <span class="hljs-comment">//更新minDist</span><br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= V;j++) &#123;<br>            <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; minDist[j] &lt; minVal) &#123;<br>                cur = j;<br>                minVal = minDist[j];<br>            &#125;<br>        &#125;<br>         <br>        visited[cur] = <span class="hljs-literal">true</span>;<br>         <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= V;j++) &#123;<br>            <span class="hljs-keyword">if</span>(!visited[j]) &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; [y, wt] : grid[cur]) &#123;<br>                    <span class="hljs-keyword">if</span>(y == j &amp;&amp; minDist[j] &gt; wt) minDist[j] = wt;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= V; i++) &#123; <span class="hljs-comment">// 不计第一个顶点，因为统计的是边的权值，v个节点有 v-1条边</span><br>        result += minDist[i];<br>    &#125;<br>    cout &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kruskal">Kruskal</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>  <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; f;<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) &#123;<br>        f.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) f[i] = i;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(u != f[u]) &#123;<br>            f[u] = <span class="hljs-built_in">find</span>(f[u]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[u];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        f[<span class="hljs-built_in">find</span>(u)] = <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(u) == <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> V, E;<br>    cin &gt;&gt; V &gt;&gt; E;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(E, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; E;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>;j++)<br>        cin &gt;&gt; grid[i][j];<br>    &#125;<br>    <span class="hljs-keyword">auto</span> cmp = [&amp;](vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, vector&lt;<span class="hljs-type">int</span>&gt; &amp; b) -&gt; <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>] &lt; b[<span class="hljs-number">2</span>];<br>    &#125;;<br>    <span class="hljs-built_in">sort</span>(grid.<span class="hljs-built_in">begin</span>(), grid.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(V + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= V;i++) &#123;<br>        <span class="hljs-comment">//find the shortest and not in the tree</span><br>        <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp; e : grid) &#123;<br>            <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isSame</span>(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>])) <span class="hljs-keyword">continue</span>;<br>            result += e[<span class="hljs-number">2</span>];<br>            uf.<span class="hljs-built_in">join</span>(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; result;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1id="将石头分散到网格的最少移动次数">将石头分散到网格的最少移动次数</h1><blockquote><p>题比较少，所以记录一下每日一题，半小时纯自主AC🎉</p></blockquote><h2 id="题目-1"><strong>题目</strong></h2><p>给你一个大小为 <code>3 * 3</code> ，下标从 <strong>0</strong>开始的二维整数矩阵 <code>grid</code>，分别表示每一个格子里石头的数目。网格图中总共恰好有 <code>9</code>个石头，一个格子里可能会有 <strong>多个</strong> 石头。</p><p>每一次操作中，你可以将一个石头从它当前所在格子移动到一个至少有一条公共边的相邻格子。</p><p>请你返回每个格子恰好有一个石头的 <strong>最少移动次数</strong> 。</p><p><strong>示例 1：</strong></p><figure><img src="https://assets.leetcode.com/uploads/2023/08/23/example1-3.svg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>输入：grid = [[1,1,0],[1,1,1],[1,2,1]]<br />输出：3<br />解释：让每个格子都有一个石头的一个操作序列为：<br />1 - 将一个石头从格子 (2,1) 移动到 (2,2) 。<br />2 - 将一个石头从格子 (2,2) 移动到 (1,2) 。<br />3 - 将一个石头从格子 (1,2) 移动到 (0,2) 。<br />总共需要 3 次操作让每个格子都有一个石头。<br />让每个格子都有一个石头的最少操作次数为 3 。</p></blockquote><h2 id="思路-1"><strong>思路</strong></h2><p>1不用动，只需知道0的位置和大于1的位置。之后不能简单地为每个0寻找最近的大于1，或者为每个最近的大于1寻找0。可轻易地举出反例，比如：</p><figure><img src="https://s3.bmp.ovh/imgs/2024/07/20/1fe8ae87392a8b8c.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>若先遍历到了居中的0，那么[0,1]位的2会被分给居中0，左下2就会分给右上0。局部最优不能得到整体最优。可抽象为：</p><blockquote><p>第一个大于1到所有0的距离为：[1, 1]</p><p>第二个大于1到所有0的距离为：[2, 4]</p><p>要从[[1,1],[2,4]]中每个数组取一个数字，且每个数组取的地方不能相同，最后总和最小。</p></blockquote><p>这就变成了全排列问题，可制定流程为：</p><ol type="1"><li>获得全部0和大于1的位置，注意大于1的位置需要多次加入保证总数</li><li>计算上述矩阵，即每个多余的1到0的距离</li><li>枚举所有排列，取最小总和</li></ol><p>流程没错，代码有点慢。只能击败不到10%...，也许是暴力回溯比不上next_permutation的缘故，读者可以帮忙测试一下👍</p><blockquote><p><ahref="%5B2850.%20将石头分散到网格图的最少移动次数%20-%20力扣（LeetCode）%5D(https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/solutions/2844232/jiang-shi-tou-fen-san-dao-wang-ge-tu-de-b4xos/?envType=daily-question&amp;envId=2024-07-20)">官方题解</a></p></blockquote><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> dis(x, y, i, j) (abs(x - i) + abs(y - j))</span><br><span class="hljs-comment">//曼哈顿距离</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> res = INT_MAX;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumMoves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; zero;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; more;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">3</span>;j++) &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>;k &lt;= grid[i][j];k++) more.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(i, j));<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[i][j] &lt; <span class="hljs-number">1</span>) zero.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(i, j));<br>            &#125;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dist</span>(more.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(zero.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; more.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; zero.<span class="hljs-built_in">size</span>();j++) &#123;<br>                dist[i][j] = <span class="hljs-built_in">dis</span>(more[i].first, more[i].second, zero[j].first, zero[j].second);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(dist.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtrack</span>(used, dist, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">bool</span>&gt; &amp; used, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp; dist, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> step)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(step == dist.<span class="hljs-built_in">size</span>()) res = <span class="hljs-built_in">min</span>(res, sum);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; dist.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(used[i]) <span class="hljs-keyword">continue</span>;<br>            sum += dist[step][i];<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtrack</span>(used, dist, sum, step + <span class="hljs-number">1</span>);<br>            sum -= dist[step][i];<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day58</title>
    <link href="/2024/07/19/leetcode-day58/"/>
    <url>/2024/07/19/leetcode-day58/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0108.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html">冗余连接</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0109.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.html">冗余连接II</a></li></ul><h1 id="冗余连接">冗余连接</h1><h3 id="题目"><strong>题目</strong>：</h3><p>树可以看成是一个图（拥有 n 个节点和 n - 1条边的连通无环无向图）。</p><p>现给定一个拥有 n 个节点（节点标号是从 1 到 n）和 n条边的连通无向图，请找出一条可以删除的边，删除后图可以变成一棵树。</p><h6 id="输入描述">输入描述</h6><p>第一行包含一个整数 N，表示图的节点个数和边的个数。</p><p>后续 N 行，每行包含两个整数 s 和 t，表示图中 s 和 t之间有一条边。</p><h6 id="输出描述">输出描述</h6><p>输出一条可以删除的边。如果有多个答案，请删除标准输入中最后出现的那条边。</p><h3 id="思路"><strong>思路</strong>：</h3><p>并查集模板，直接套</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; f;<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) &#123;<br>        f.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            f[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(u != f[u]) &#123;<br>            f[u] = <span class="hljs-built_in">find</span>(f[u]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[u];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        f[<span class="hljs-built_in">find</span>(u)] = <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(u) == <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isSame</span>(a, b)) &#123;<br>            cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> uf.<span class="hljs-built_in">join</span>(a, b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="冗余连接ii">冗余连接II</h1><h3 id="题目-1"><strong>题目</strong>：</h3><p>有向树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。有根树拥有n 个节点和 n - 1 条边。</p><p>输入一个有向图，该图由一个有着 n 个节点(节点编号 从 1 到 n)，n条边，请返回一条可以删除的边，使得删除该条边之后该有向图可以被当作一颗有向树。</p><h6 id="输入描述-1">输入描述</h6><p>第一行输入一个整数 N，表示有向图中节点和边的个数。</p><p>后续 N 行，每行输入两个整数 s 和 t，代表 s 节点有一条连接 t节点的单向边</p><h6 id="输出描述-1">输出描述</h6><p>输出一条可以删除的边，若有多条边可以删除，请输出标准输入中<strong>最后出现的一条边</strong>。</p><h3 id="思路-1"><strong>思路</strong>：</h3><h5 id="个人错误思路">个人错误思路</h5><p>并查集本身也是有向的，可直接按顺序加入边来模拟建树，需要考虑以下两种非法情况：</p><ol type="1"><li>含圈：检查新加入的边两端是否同根<code>find(u) == find(v)</code>，若相同，则删除该边</li><li>入度大于1：检查新加入的边两端是否已经加入树中<code>u != find(u)</code>，若不等，说明u已经在树中作为子，不可再作为子。</li></ol><p>需要注意并查集加入边的顺序，输入<code>2 1</code>，则使<code>f[1] = 2</code>。</p><blockquote><p>问题描述：</p><p>思路是错的，代码能过因为用例太弱。对于用例：</p><p>4<br />2 1<br />3 1<br />1 4<br />4 2</p><p>正解是删去2 1，若采用上面的思路，则遇到3 1时就会输出31，因为1已经被用过了，3 1和2 1肯定有一个会被删掉，删除靠后的3 1。</p><p>但整体来看，满足了入度条件却忽略了后面的圈条件，所以并不能按顺序模拟建树。</p><p>于是，我将入度非法的输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isSame</span>(a,b)) &#123;<span class="hljs-comment">//如果a -&gt; b的b已经被占用</span><br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b;<span class="hljs-comment">//按照题意，直接删去这条</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>改为输出已被占用的子和对应的父：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isVisited</span>(b)) &#123;<span class="hljs-comment">//如果a -&gt; b的b已经被占用</span><br>cout &lt;&lt; uf.<span class="hljs-built_in">find</span>(b) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b;<span class="hljs-comment">//输出之前输入的 占用b的边</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>即当遇到3 1时，输出21，这显然违背了题意(输出靠后的边)，<strong>但是能AC</strong>，说明用例中只有这一个能够反按顺序建树的思路。</p><p>同类型用例可概括为"一个圈加圈外的一条指向圈的边"：</p><figure><img src="https://s3.bmp.ovh/imgs/2024/07/19/721fb7b01d80c426.png"alt="带尾巴的圈" /><figcaption aria-hidden="true">带尾巴的圈</figcaption></figure><p>输入时只需将圈外边先于整个圈输入即可越过检查，如：</p><p>5 | 1 2 | 2 3 | 5 3 | 4 1 | 3 4 |</p><figure><img src="https://s3.bmp.ovh/imgs/2024/07/19/73a20d7842640d56.png"alt="图例" /><figcaption aria-hidden="true">图例</figcaption></figure><p>正解应该删去2 3，但我的代码输出3 1。将1 2和2 3交换顺序，则会输出13。(甚至路径压缩的错误都出来了……)</p><p>具体错误应该在于判断非法后默认输出当前边。自以为满足了靠后输出的要求，实际上却忽视了整体。应该像Carl那样判断应该删那一条边。</p></blockquote><h5 id="正确思路">正确思路</h5><p><ahref="%5B代码随想录%20(programmercarl.com)%5D(https://www.programmercarl.com/kamacoder/0109.冗余连接II.html#思路)">代码随想录| 冗余连接II</a></p><h2 id="代码-1">代码</h2><p>错误代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<span class="hljs-comment">//并查集类</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; f;<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) &#123;<br>        f.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            f[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(u != f[u]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(f[u]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[u];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<span class="hljs-comment">//u做根</span><br>        f[<span class="hljs-built_in">find</span>(v)] = <span class="hljs-built_in">find</span>(u);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isVisited</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> v != <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(u) == <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isSame</span>(a,b)) &#123;<span class="hljs-comment">//判圈</span><br>            cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b;<span class="hljs-comment">//有圈，直接删当前</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isVisited</span>(b)) &#123;<span class="hljs-comment">//判入度</span><br>            cout &lt;&lt; uf.<span class="hljs-built_in">find</span>(b) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b;<span class="hljs-comment">//有重，直接删当前的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> uf.<span class="hljs-built_in">join</span>(a, b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>carl哥的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span> <span class="hljs-params">(<span class="hljs-number">1001</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ;<br>    father[v] = u;<br>&#125;<br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-comment">// 在有向图里找到删除的那条边，使其变成树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getRemoveEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>(); <span class="hljs-comment">// 初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 遍历所有的边</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">same</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) &#123; <span class="hljs-comment">// 构成有向环了，就是要删除的边</span><br>            cout &lt;&lt; edges[i][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; edges[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 删一条边之后判断是不是树</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTreeAfterRemoveEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, <span class="hljs-type">int</span> deleteEdge)</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>(); <span class="hljs-comment">// 初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == deleteEdge) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">same</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) &#123; <span class="hljs-comment">// 构成有向环了，一定不是树</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> s, t;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edges;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录节点入度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        inDegree[t]++;<br>        edges.<span class="hljs-built_in">push_back</span>(&#123;s, t&#125;);<br>    &#125;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; vec; <span class="hljs-comment">// 记录入度为2的边（如果有的话就两条边）</span><br>    <span class="hljs-comment">// 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[edges[i][<span class="hljs-number">1</span>]] == <span class="hljs-number">2</span>) &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isTreeAfterRemoveEdge</span>(edges, vec[<span class="hljs-number">0</span>])) &#123;<br>            cout &lt;&lt; edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理情况三</span><br>    <span class="hljs-comment">// 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了</span><br>    <span class="hljs-built_in">getRemoveEdge</span>(edges);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day57</title>
    <link href="/2024/07/18/leetcode-day57/"/>
    <url>/2024/07/18/leetcode-day57/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0107.%E5%AF%BB%E6%89%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E8%B7%AF%E5%BE%84.html">寻找存在的路径</a></li><li><ahref="https://leetcode.cn/problems/accounts-merge/description/">721.账户合并</a> <span class="label label-warning">medium</span></li></ul><h1 id="寻找存在的路径">寻找存在的路径</h1><h4 id="题目"><strong>题目：</strong></h4><p>给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n）。</p><p>你的任务是判断是否有一条从节点 source 出发到节点 destination的路径存在。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个正整数 N 和 M，N 代表节点的个数，M 代表边的个数。</p><p>后续 M 行，每行两个正整数 s 和 t，代表从节点 s 与节点 t之间有一条边。</p><p>最后一行包含两个正整数，代表起始节点 source 和目标节点destination。</p><h6 id="输出描述">输出描述</h6><p>输出一个整数，代表是否存在从节点 source 到节点 destination的路径。如果存在，输出 1；否则，输出 0。</p><h4 id="思路"><strong>思路：</strong></h4><p>并查集模板题，只需要建一个并查集，然后判断source和destination是不是同源。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Union</span>&#123;<span class="hljs-comment">//并查集</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; f;<br>    <span class="hljs-built_in">Union</span>(<span class="hljs-type">int</span> n) &#123;<br>        f.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            f[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(f[u] != u) &#123;<br>            <span class="hljs-keyword">return</span> f[u] = <span class="hljs-built_in">find</span>(f[u]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[u];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        f[<span class="hljs-built_in">find</span>(u)] = <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(u) == <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    <span class="hljs-function">Union <span class="hljs-title">uf</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; M;i++) &#123;<span class="hljs-comment">//建立并查集</span><br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        uf.<span class="hljs-built_in">join</span>(a, b);<br>    &#125;<br>    <span class="hljs-type">int</span> s, d;<br>    cin &gt;&gt; s &gt;&gt; d;<br>    cout &lt;&lt; uf.<span class="hljs-built_in">isSame</span>(s, d);<span class="hljs-comment">//判断</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="账户合并">721. 账户合并</h1><h4 id="题目-1"><strong>题目：</strong></h4><p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code>是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code> 是 <em>名称(name)</em>，其余元素是 <strong><em>emails</em></strong>表示该账户的邮箱地址。</p><p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p><p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是<strong>按字符 ASCII 顺序排列</strong> 的邮箱地址。账户本身可以以<strong>任意顺序</strong> 返回。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：accounts = [[<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;johnsmith@mail.com&quot;</span>, <span class="hljs-string">&quot;john00@mail.com&quot;</span>], [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;johnnybravo@mail.com&quot;</span>], [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;johnsmith@mail.com&quot;</span>, <span class="hljs-string">&quot;john_newyork@mail.com&quot;</span>], [<span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-string">&quot;mary@mail.com&quot;</span>]]<br>输出：[[<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&#x27;john00@mail.com&#x27;</span>, <span class="hljs-string">&#x27;john_newyork@mail.com&#x27;</span>, <span class="hljs-string">&#x27;johnsmith@mail.com&#x27;</span>],  [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;johnnybravo@mail.com&quot;</span>], [<span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-string">&quot;mary@mail.com&quot;</span>]]<br>解释：<br>第一个和第三个 <span class="hljs-symbol">John</span> 是同一个人，因为他们有共同的邮箱地址 <span class="hljs-string">&quot;johnsmith@mail.com&quot;</span>。 <br>第二个 <span class="hljs-symbol">John</span> 和 <span class="hljs-symbol">Mary</span> 是不同的人，因为他们的邮箱地址没有被其他帐户使用。<br>可以以任何顺序返回这些列表，例如答案 [[<span class="hljs-string">&#x27;Mary&#x27;</span>，<span class="hljs-string">&#x27;mary@mail.com&#x27;</span>]，[<span class="hljs-string">&#x27;John&#x27;</span>，<span class="hljs-string">&#x27;johnnybravo@mail.com&#x27;</span>]，<br>[<span class="hljs-string">&#x27;John&#x27;</span>，<span class="hljs-string">&#x27;john00@mail.com&#x27;</span>，<span class="hljs-string">&#x27;john_newyork@mail.com&#x27;</span>，<span class="hljs-string">&#x27;johnsmith@mail.com&#x27;</span>]] 也是正确的。<br></code></pre></td></tr></table></figure><h4 id="思路-1"><strong>思路：</strong></h4><blockquote><p>由于今天并查集专题开始，只有一道模板题，所以将前天的力扣每日一题记录，正好也是并查集，提前学过就是快。</p></blockquote><ul><li>给所有的邮箱名编号，方便加入并查集，同时将邮件和名字关联，建立map&lt;email,name&gt;</li><li>根据每个账户的邮箱的编号，为每个账户建立并查集，以每个账户的第一个邮箱作为root</li><li>遍历所有的邮箱，建立"邮箱-&gt;编号"的映射，实现：能够根据一个邮箱得到邮箱所有者的全部邮箱<ul><li>得到该邮箱的root编号，建立map&lt;index,email<strong>s</strong>&gt;，将该邮箱放入root编号对应的邮箱集中</li></ul></li><li>遍历所有邮箱集，此时邮箱集已经完成合并，排序，通过第一步的邮箱-&gt;名字映射得到姓名，合并成一个数组加入答案，并返回。</li></ul><p>详见代码注释，可学习其中对于map的遍历简洁写法:<code>auto [e,_] : map</code></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<br><br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) &#123;<br>        parent.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> index1, <span class="hljs-type">int</span> index2)</span> </span>&#123;<br>        parent[<span class="hljs-built_in">find</span>(index1)] = <span class="hljs-built_in">find</span>(index2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (parent[index] != index) &#123;<br>            parent[index] = <span class="hljs-built_in">find</span>(parent[index]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[index];<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">accountsMerge</span>(vector&lt;vector&lt;string&gt;&gt;&amp; accounts) &#123;<br>        <span class="hljs-comment">//原来是并查集，没学过，现在学了</span><br>        <span class="hljs-comment">//首先给邮件编号方便加入并查集</span><br>        map&lt;string, <span class="hljs-type">int</span>&gt; emailToIndex;<br>        <span class="hljs-comment">//把邮件和名字关联起来</span><br>        map&lt;string, string&gt; emailToName;<br>        <span class="hljs-type">int</span> emailIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; account : accounts) &#123;<br>            string &amp; name = account[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> size = account.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; size;i++) &#123;<br>                string &amp; email = account[i];<br>                <span class="hljs-keyword">if</span>(!emailToIndex.<span class="hljs-built_in">count</span>(email)) &#123;<br>                    emailToIndex[email] = emailIndex++;<br>                    emailToName[email] = name;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//构建并查集</span><br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(emailIndex)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; account : accounts) &#123;<br>            string &amp; first = account[<span class="hljs-number">1</span>];<span class="hljs-comment">//第一个email作根</span><br>            <span class="hljs-type">int</span> root = emailToIndex[first];<br>            <span class="hljs-type">int</span> size = account.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt; size;i++) &#123;<br>                string &amp; email = account[i];<br>                <span class="hljs-type">int</span> index = emailToIndex[email];<br>                uf.<span class="hljs-built_in">join</span>(index, root);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将同一个人的emails统一起来</span><br>        map&lt;<span class="hljs-type">int</span>, vector&lt;string&gt;&gt; indexToEmails;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; [email, _] : emailToIndex) &#123;<br>            <span class="hljs-type">int</span> index = uf.<span class="hljs-built_in">find</span>(emailToIndex[email]);<span class="hljs-comment">//得到该email的根</span><br>            vector&lt;string&gt;&amp; emails = indexToEmails[index];<span class="hljs-comment">//得到这个根下已经有的emails</span><br>            emails.<span class="hljs-built_in">emplace_back</span>(email);<span class="hljs-comment">//将当前email加入这个根下的emails</span><br>            indexToEmails[index] = emails;<span class="hljs-comment">//放回去</span><br>        &#125;<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; [_, emails] : indexToEmails) &#123;<br>            <span class="hljs-built_in">sort</span>(emails.<span class="hljs-built_in">begin</span>(), emails.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//按ASCII排序</span><br>            string &amp; name = emailToName[emails[<span class="hljs-number">0</span>]];<br>            vector&lt;string&gt; account;<br>            account.<span class="hljs-built_in">emplace_back</span>(name);<span class="hljs-comment">//名字打头</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; email : emails) &#123;<br>                account.<span class="hljs-built_in">emplace_back</span>(email);<span class="hljs-comment">//后跟email</span><br>            &#125;<br>            ans.<span class="hljs-built_in">emplace_back</span>(account);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day56</title>
    <link href="/2024/07/17/leetcode-day56/"/>
    <url>/2024/07/17/leetcode-day56/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0110.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%A5%E9%BE%99.html">字符串接龙</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0105.%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%AE%8C%E5%85%A8%E5%8F%AF%E8%BE%BE%E6%80%A7.html">有向图的完全可达性</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0106.%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF.html">岛屿的周长</a></li></ul><h1 id="字符串接龙">字符串接龙</h1><h5 id="题目"><strong>题目：</strong></h5><p>字典 strList 中从字符串 beginStr 和 endStr的转换序列是一个按下述规格形成的序列：</p><ol type="1"><li>序列中第一个字符串是 beginStr。</li><li>序列中最后一个字符串是 endStr。</li><li>每次转换只能改变一个字符。</li><li>转换过程中的中间字符串必须是字典 strList中的字符串，且strList里的每个字符串只用使用一次。</li></ol><p>给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr到 endStr 的最短转换序列中的字符串数目。如果不存在这样的转换序列，返回0。</p><h6 id="输入描述">输入描述</h6><p>第一行包含一个整数 N，表示字典 strList 中的字符串数量。第二行包含两个字符串，用空格隔开，分别代表 beginStr 和 endStr。 后续 N行，每行一个字符串，代表 strList 中的字符串。</p><h6 id="输出描述">输出描述</h6><p>输出一个整数，代表从 beginStr 转换到 endStr需要的最短转换序列中的字符串数量。如果不存在这样的转换序列，则输出0。</p><h5 id="思路"><strong>思路：</strong></h5><p><strong>注意</strong>：无向图搜索，最好用BFS</p><p>beginStr和endStr作为起始点，字典中的作为中间点，求最短路，即无向图求最短路。</p><p>但是这里并不是具体的点，而是字符串，路也需要判断</p><p>如果直接遍历所有字符串，根据差异直接建图，首先就会有<spanclass="math inline">\(O(n^2)\)</span>的复杂度（<em>还没算比较字符串差异的复杂度</em>），然后还需要BFS，容易超时</p><p>carl利用字符串中只有小写字母的特点(题目并未提及只有小写字母，难以想到)，可以手动模拟所有的路，然后在已有的路中匹配，降低复杂度为常数26和在set、map中查找数据复杂度之积，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; <span class="hljs-number">26</span>; j++) &#123;<span class="hljs-comment">//遍历26个字母</span><br>    newWord[i] = j + <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (newWord == endStr) &#123; <span class="hljs-comment">// 发现替换字母后，字符串与终点字符串相同</span><br>        cout &lt;&lt;  path + <span class="hljs-number">1</span> &lt;&lt; endl; <span class="hljs-comment">// 找到了路径 </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 字符串集合里出现了newWord，并且newWord没有被访问过</span><br>    <span class="hljs-keyword">if</span> (strSet.<span class="hljs-built_in">find</span>(newWord) != strSet.<span class="hljs-built_in">end</span>()<br>            &amp;&amp; visitMap.<span class="hljs-built_in">find</span>(newWord) == visitMap.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-comment">// 添加访问信息，并将新字符串放到队列中</span><br>        visitMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(newWord, path + <span class="hljs-number">1</span>));<br>        que.<span class="hljs-built_in">push</span>(newWord);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br>    string beginStr, endStr;<br>    cin &gt;&gt; beginStr &gt;&gt; endStr;<br>    unordered_set&lt;string&gt; set;<br>    string temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        cin &gt;&gt; temp;<br>        set.<span class="hljs-built_in">insert</span>(temp);<br>    &#125;<br>    queue&lt;string&gt; q;<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; map;<br>    q.<span class="hljs-built_in">push</span>(beginStr);<br>    map[beginStr] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        string word = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> path = map[word];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; word.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">26</span>;j++) &#123;<br>                string newWord = word;<br>                newWord[i] = j + <span class="hljs-string">&#x27;a&#x27;</span>;<br> <br>                <span class="hljs-keyword">if</span>(newWord == endStr) &#123;<br>                    cout &lt;&lt; path + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(newWord) != set.<span class="hljs-built_in">end</span>() &amp;&amp; map.<span class="hljs-built_in">find</span>(newWord) == map.<span class="hljs-built_in">end</span>()) &#123;<br>                        map[newWord] = path + <span class="hljs-number">1</span>;<br>                        q.<span class="hljs-built_in">push</span>(newWord);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="有向图的完全可达性">有向图的完全可达性</h1><h5 id="题目-1"><strong>题目：</strong></h5><p>给定一个有向图，包含 N 个节点，节点编号分别为 1，2，...，N。现从 1号节点开始，如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出-1。</p><h6 id="输入描述-1">输入描述</h6><p>第一行包含两个正整数，表示节点数量 N 和边的数量 K。 后续 K行，每行两个正整数 s 和 t，表示从 s 节点有一条边单向连接到 t 节点。</p><h6 id="输出描述-1">输出描述</h6><p>如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p><h5 id="思路-1"><strong>思路：</strong></h5><p>不用传统dfs或bfs，既然是有向图可达，联想并查集路径压缩的思想，不断将路径压缩，随后如果还存在起点不是1号的路径，则输出-1。具体过程如下：</p><ol type="1"><li>统计所有直接与1相通的点，<spanclass="math inline">\(s[i]\)</span>代表1号节点能否到达节点i</li><li>其他边另成集，起点不断与s比较，若s[起点]=true，则删除这条边，同时更新s[终点]为true</li><li>循环删除“其他边”，以冒泡排序思想检测本轮遍历是否有删除，若没有删除操作，则检查"其他边"，若仍存在，输出-1，若空，输出1</li></ol><p>这种写法类似于BFS，每次只走一步。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//统计所有1出发的边，其他边另成集</span><br><span class="hljs-comment">//不断将其他边融合进1出发，如1，2  2，4 融合为1，4</span><br><span class="hljs-comment">//最后如果剩余有不可融合的边，则-1</span><br><span class="hljs-comment">//1出发边构建为s[101]表示从1到101的边是否存在</span><br><span class="hljs-comment">//其他边统计为vec&lt;pair&lt;int,int&gt;&gt; 如果起点与s重合则删除，并更新s</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, K;<br>    cin &gt;&gt; N &gt;&gt; K;<br>    <span class="hljs-type">bool</span> s[<span class="hljs-number">110</span>] = &#123;<span class="hljs-literal">false</span>&#125;;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; edge;<br>    <span class="hljs-type">int</span> a, b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; K;i++) &#123;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span>) s[b] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> edge.<span class="hljs-built_in">push_back</span>(&#123;a, b&#125;);<br>    &#125;<br>    <span class="hljs-type">bool</span> changed = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span>(!edge.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; edge.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[edge[i].first]) &#123;<br>                s[edge[i].second] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">swap</span>(edge[i], edge[edge.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]);<br>                edge.<span class="hljs-built_in">pop_back</span>();<br>                changed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(changed == <span class="hljs-literal">false</span> &amp;&amp; !edge.<span class="hljs-built_in">empty</span>()) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        changed = <span class="hljs-literal">false</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="岛屿的周长">岛屿的周长</h1><h5 id="题目-2"><strong>题目：</strong></h5><p>给定一个由 1（陆地）和0（水）组成的矩阵，岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。</p><p>你可以假设矩阵外均被水包围。在矩阵中恰好拥有一个岛屿，假设组成岛屿的陆地边长都为1，请计算岛屿的周长。岛屿内部没有水域。</p><h6 id="输入描述-2">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-2">输出描述</h6><p>输出一个整数，表示岛屿的周长。</p><h5 id="思路-2"><strong>思路：</strong></h5><p>由于地块都是方块，所以问题转化为小学生的数周长问题，公式为：</p><p><span class="math inline">\(周长=块数*4-重合边数\)</span></p><p>那么可以统计块数和重合边数，最后求解答案即可。</p><p>也可以遍历所有地块，统计所有海岸长度。</p><p>还需注意岛屿问题的经典坑——全是陆地没有水。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//每块四面，重合最少1最多4，遍历所有块计算每个的重合</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; M;j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; M;j++) &#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-literal">false</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k &lt; <span class="hljs-number">4</span>;k++) &#123;<br>                <span class="hljs-type">int</span> x = i + dir[k][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> y = j + dir[k][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= N || y &lt; <span class="hljs-number">0</span> || y &gt;= M || grid[x][y] == <span class="hljs-literal">false</span>) ans++;<br>            &#125;<br>        &#125;   <br>    &#125;<br>    <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">2</span>*(N+M);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day55</title>
    <link href="/2024/07/16/leetcode-day55/"/>
    <url>/2024/07/16/leetcode-day55/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0101.%E5%AD%A4%E5%B2%9B%E7%9A%84%E6%80%BB%E9%9D%A2%E7%A7%AF.html">孤岛的总面积</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0102.%E6%B2%89%E6%B2%A1%E5%AD%A4%E5%B2%9B.html">沉没孤岛</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0103.%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98.html">水流问题</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0104.%E5%BB%BA%E9%80%A0%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF.html">建造最大岛屿</a></li></ul><h1 id="孤岛的总面积">孤岛的总面积</h1><p><strong>题目：</strong></p><p>给定一个由 1（陆地）和0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p><p>现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M个数字，数字为 1 或者 0。</p><h6 id="输出描述">输出描述</h6><p>输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。</p><p><strong>思路：</strong></p><p>先绕地图边缘遍历，遇到陆地就搜索，把整块地都变成水，然后再遍历地图，得到的就全是孤岛，计算总面积。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">55</span>;<span class="hljs-comment">//题目限制最大50，开个55</span><br> <br><span class="hljs-type">int</span> n, m;<span class="hljs-comment">//长宽</span><br><span class="hljs-type">int</span> cnt;<span class="hljs-comment">//计数器</span><br><span class="hljs-type">int</span> g[N][N];<span class="hljs-comment">//地图</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//方向</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span></span><br><span class="hljs-function"></span>&#123;<br>    g[sx][sy] = <span class="hljs-number">0</span>;<span class="hljs-comment">//直接变水</span><br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<span class="hljs-comment">//四个方向</span><br>    &#123;<br>        <span class="hljs-type">int</span> a = sx + dx[i], b = sy + dy[i];<br>        <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (g[a][b] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        g[a][b] = <span class="hljs-number">0</span>;<span class="hljs-comment">//变水</span><br>        cnt++;<span class="hljs-comment">//计数孤岛</span><br>        <span class="hljs-built_in">dfs</span>(a, b);<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>            cin &gt;&gt; g[i][j];<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (g[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>);  <span class="hljs-comment">//左边</span><br>        <span class="hljs-keyword">if</span> (g[i][m - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(i, m - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 右边</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (g[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, i); <span class="hljs-comment">// 上边</span><br>        <span class="hljs-keyword">if</span> (g[n - <span class="hljs-number">1</span>][i] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(n - <span class="hljs-number">1</span>, i); <span class="hljs-comment">// 下边</span><br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-number">1</span>)<br>            &#123;<br>                cnt = <span class="hljs-number">1</span>;<span class="hljs-comment">//记录当前</span><br>                <span class="hljs-built_in">dfs</span>(i, j);<br>                res += cnt;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="沉默孤岛">沉默孤岛</h1><p><strong>题目：</strong></p><p>给定一个由 1（陆地）和0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p><p>现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。</p><h6 id="输入描述-1">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p><p>之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-1">输出描述</h6><p>输出将孤岛“沉没”之后的岛屿矩阵。 注意：每个元素后面都有一个空格</p><p><strong>思路：</strong></p><p>溜边遍历，把靠边的陆地全变成2，再遍历一次，把不是2的都变水，就能够沉掉孤岛。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = a;i &lt; b;i++)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    grid[x][y] *= <span class="hljs-number">2</span>;<span class="hljs-comment">//0就0，1就2</span><br>    <span class="hljs-keyword">if</span>(!grid[x][y]) <span class="hljs-keyword">return</span> ;<span class="hljs-comment">//已经遇到水了，不用继续走了</span><br>    <span class="hljs-built_in">rep</span>(k, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-type">int</span> i = x + dir[k][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> j = y + dir[k][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= grid.<span class="hljs-built_in">size</span>() || j &lt; <span class="hljs-number">0</span> || j &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>            grid[i][j] = <span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">dfs</span>(grid, i, j);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; M;j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N) &#123;<span class="hljs-comment">//溜左右</span><br>        <span class="hljs-built_in">dfs</span>(grid, i, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">dfs</span>(grid, i, M<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, M) &#123;<span class="hljs-comment">//溜上下</span><br>        <span class="hljs-built_in">dfs</span>(grid, <span class="hljs-number">0</span>, i);<br>        <span class="hljs-built_in">dfs</span>(grid, N<span class="hljs-number">-1</span>, i);<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N) &#123;<span class="hljs-comment">//溜全图</span><br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">0</span>, M) &#123;<br>            cout &lt;&lt; (<span class="hljs-type">int</span>)(grid[i][j] &gt; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">//是2才输出</span><br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="水流问题">水流问题</h1><p><strong>题目：</strong></p><p>现有一个 N × M的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。</p><p>矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。</p><h6 id="输入描述-2">输入描述</h6><p>第一行包含两个整数 N 和 M，分别表示矩阵的行数和列数。</p><p>后续 N 行，每行包含 M 个整数，表示矩阵中的每个单元格的高度。</p><h6 id="输出描述-2">输出描述</h6><p>输出共有多行，每行输出两个整数，用一个空格隔开，表示可达第一组边界和第二组边界的单元格的坐标，输出顺序任意。</p><p><strong>思路：</strong></p><p>不能暴力，要优化，仍然溜边，分别记录一组边界和二组边界上每个边点能够去到的地方，即一组边界和二组边界都有着一张图，上面true的地方能作上游，false的地方不能。</p><p>最后再遍历全图，如果一组边界和二组边界都能将其作为上游，那么就是目标点，输出。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (visited[x][y]) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//走过，不用再走</span><br><br>    visited[x][y] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= n || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= m) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (grid[x][y] &gt; grid[nextx][nexty]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 注意：这里是从低向高遍历，逆流而上</span><br><br>        <span class="hljs-built_in">dfs</span> (grid, visited, nextx, nexty);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 标记从第一组边界上的节点出发，可以遍历的节点</span><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">firstBorder</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-comment">// 标记从第一组边界上的节点出发，可以遍历的节点</span><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">secondBorder</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-comment">// 从最上和最下行的节点出发，向高处遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">dfs</span> (grid, firstBorder, i, <span class="hljs-number">0</span>); <span class="hljs-comment">// 遍历最左列，接触第一组边界</span><br>        <span class="hljs-built_in">dfs</span> (grid, secondBorder, i, m - <span class="hljs-number">1</span>); <span class="hljs-comment">// 遍历最右列，接触第二组边界</span><br>    &#125;<br><br>    <span class="hljs-comment">// 从最左和最右列的节点出发，向高处遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-built_in">dfs</span> (grid, firstBorder, <span class="hljs-number">0</span>, j); <span class="hljs-comment">// 遍历最上行，接触第一组边界</span><br>        <span class="hljs-built_in">dfs</span> (grid, secondBorder, n - <span class="hljs-number">1</span>, j); <span class="hljs-comment">// 遍历最下行，接触第二组边界</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-comment">// 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果</span><br>            <span class="hljs-keyword">if</span> (firstBorder[i][j] &amp;&amp; secondBorder[i][j]) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="建造最大岛屿">建造最大岛屿</h1><p><strong>题目：</strong></p><p>给定一个由 1（陆地）和0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。</p><p>岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。</p><h6 id="输入描述-3">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-3">输出描述</h6><p>输出一个整数，表示最大的岛屿面积。如果矩阵中不存在岛屿，则输出0。</p><p><strong>思路：</strong></p><p>不能暴力，先遍历全图，用不同的mark标记不同的岛屿，开个map记录标号mark-面积count的序对[mark,count]，最后再遍历全图，对每个水地块计算其周围四格邻接的不同岛屿的面积总和，取最大值。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = a;i &lt; b;i++)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> N,M;<br><span class="hljs-type">int</span> cnt;<span class="hljs-comment">//单个岛屿计数器</span><br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> mark)</span> </span>&#123;<br>    grid[x][y] = mark;<span class="hljs-comment">//用mark覆盖，相当于着色</span><br>    cnt++;<br>    <span class="hljs-built_in">rep</span>(m, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-type">int</span> i = x + dir[m][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> j = y + dir[m][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= N || j &lt; <span class="hljs-number">0</span> || j &gt;= M || grid[i][j] != <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(grid, i, j, mark);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N) &#123;<br>        <span class="hljs-built_in">rep</span>(j ,<span class="hljs-number">0</span>, M) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//先遍历地图记录岛屿-面积</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>    <span class="hljs-type">int</span> mark = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N) &#123;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">0</span>, M) &#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                cnt = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">dfs</span>(grid, i, j, mark);<br>                map[mark] = cnt;<br>                mark++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//遍历海洋，计算相邻岛屿面积之和，取最大值</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N) &#123;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">0</span>, M) &#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//将相邻的不同岛屿面积相加,unordered_set去重岛屿</span><br>            unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>            temp = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">rep</span>(m, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-type">int</span> x = i + dir[m][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> y = j + dir[m][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= N || y &lt; <span class="hljs-number">0</span> || y &gt;= M || grid[x][y] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(grid[x][y]) != set.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    temp += map[grid[x][y]];<br>                    set.<span class="hljs-built_in">insert</span>(grid[x][y]);<br>                &#125;<br>            &#125;<br>            ans = ans &gt; temp ? ans : temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>) cout&lt;&lt; N * M;<span class="hljs-comment">//没水全是地，直接返回地图大小</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day54</title>
    <link href="/2024/07/15/leetcode-day54/"/>
    <url>/2024/07/15/leetcode-day54/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E6%B7%B1%E6%90%9C.html">99.岛屿数量</a></li><li><ahref="https://www.programmercarl.com/kamacoder/0100.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.html">100.岛屿的最大面积</a></li></ul><h1 id="岛屿数量">岛屿数量</h1><p><strong>题目：</strong></p><p>给定一个由 1（陆地）和0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p><p>后续 N 行，每行包含 M 个数字，数字为 1 或者 0。</p><h6 id="输出描述">输出描述</h6><p>输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。</p><p><strong>思路：</strong></p><p>遍历整个图，如果遇到没走过的1，就计数，并把其相邻的所有1都走一遍，如果遇到走过的1或0就跳过，最后返回计数。</p><h2 id="代码">代码</h2><p>dfs版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = a;i &lt; b;i++)</span><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; map, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= (<span class="hljs-type">int</span>)map.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= (<span class="hljs-type">int</span>)map[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || visited[nextx][nexty] || map[nextx][nexty] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            visited[nextx][nexty] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(map, visited, nextx, nexty);<br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, M;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">map</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M));<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N) &#123;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">0</span>, M) &#123;<br>            cin &gt;&gt; map[i][j];<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">visited</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-literal">false</span>));<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, N)&#123;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">0</span>, M) &#123;<br>            <span class="hljs-keyword">if</span>(map[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[i][j]) &#123;<br>                visited[i][j] = <span class="hljs-literal">true</span>;<br>                ans ++;<br>                <span class="hljs-built_in">dfs</span>(map, visited, i, j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>bfs版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    que.<span class="hljs-built_in">push</span>(&#123;x, y&#125;);<br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列，立刻标记</span><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        pair&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span>) &#123;<br>                que.<span class="hljs-built_in">push</span>(&#123;nextx, nexty&#125;);<br>                visited[nextx][nexty] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列立刻标记</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br> <br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br> <br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                result++; <span class="hljs-comment">// 遇到没访问过的陆地，+1</span><br>                <span class="hljs-built_in">bfs</span>(grid, visited, i, j); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>            &#125;<br>        &#125;<br>    &#125;<br> <br> <br>    cout &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="岛屿的最大面积">岛屿的最大面积</h1><p><strong>题目：</strong></p><p>给定一个由 1（陆地）和0（水）组成的矩阵，计算岛屿的最大面积。岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p><h6 id="输入描述-1">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。后续 N 行，每行包含 M个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-1">输出描述</h6><p>输出一个整数，表示岛屿的最大面积。如果不存在岛屿，则输出 0。</p><p><strong>思路：</strong></p><p>采用和上一道题相同的思路，只是不计数岛屿数量，改为在遍历岛屿时计数面积(格子数)，从中选出一个最大的面积返回。</p><h2 id="代码-1">代码</h2><p>dfs版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">// 四个方向</span><br><br><span class="hljs-type">int</span> island = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++) &#123;<br>        <span class="hljs-type">int</span> _x = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> _y = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(_x &lt; <span class="hljs-number">0</span> || _x &gt;= grid.<span class="hljs-built_in">size</span>() || _y &lt; <span class="hljs-number">0</span> || _y &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || grid[_x][_y] == <span class="hljs-number">0</span> || visited[_x][_y] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            visited[_x][_y] = <span class="hljs-literal">true</span>;<br>            island++;<br>            <span class="hljs-built_in">dfs</span>(grid, visited, _x, _y);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; visited[i][j] == <span class="hljs-literal">false</span>) &#123;<br>                island = <span class="hljs-number">1</span>;<br>                visited[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j);<br>                max = max &gt;= island ? max : island;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; max;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="小结注意">小结&amp;注意</h1><p>在bfs时，入队即为走过，需要立即将其状态visited置位，否则会重复遍历超时。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day52</title>
    <link href="/2024/07/13/leetcode-day52/"/>
    <url>/2024/07/13/leetcode-day52/</url>
    
    <content type="html"><![CDATA[<p>今日内容：图论首日，内容较简单，离散数学和数据结构课上都学完了</p><ul><li><ahref="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">797.所有可达路径</a></li></ul><h1 id="所有可达路径">797. 所有可达路径</h1><p><strong>题目：</strong></p><p>给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点n-1 的路径并输出（不要求按特定顺序）</p><p>graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点graph[i][j]存在一条有向边）。</p><figure><img src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg"alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>输入：graph = [[1,2],[3],[3],[]]<br />输出：[[0,1,3],[0,2,3]]<br />解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</p><p><strong>思路：</strong></p><p>简单的回溯dfs，实践一下邻接表和邻接矩阵的存法。首次写没有用这两种，直接把edge存一起了，由于每次都要从头找出度，所以会慢一点</p><h2 id="代码">代码</h2><p>carl的邻接表写法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 1节点到终点的路径</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (x == n) &#123; <span class="hljs-comment">// 找到符合条件的一条路径</span><br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : graph[x]) &#123; <span class="hljs-comment">// 找到 x指向的节点</span><br>        path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>        <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span><br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br><br>    &#125;<br><br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 无论什么路径已经是从0节点出发</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, n); <span class="hljs-comment">// 开始遍历</span><br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;pa : result) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            cout &lt;&lt; pa[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; pa[pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]  &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> carl的邻接矩阵 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 1节点到终点的路径</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 当前遍历的节点x 到达节点n </span><br>    <span class="hljs-keyword">if</span> (x == n) &#123; <span class="hljs-comment">// 找到符合条件的一条路径</span><br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 遍历节点x链接的所有节点</span><br>        <span class="hljs-keyword">if</span> (graph[x][i] == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 找到 x链接的节点</span><br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>            <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br> <br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br> <br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的</span><br>        graph[s][t] = <span class="hljs-number">1</span>;<br>    &#125;<br> <br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 无论什么路径已经是从0节点出发</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, n); <span class="hljs-comment">// 开始遍历</span><br> <br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;pa : result) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            cout &lt;&lt; pa[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; pa[pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]  &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>直接存边：慢50%左右 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-type">int</span> N, M;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; edge, <span class="hljs-type">int</span> cur)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(cur == N) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; (<span class="hljs-type">int</span>)edge.<span class="hljs-built_in">size</span>();i++) &#123;<br>        <span class="hljs-keyword">if</span>(edge[i].first != cur) <span class="hljs-keyword">continue</span>;<br>        path.<span class="hljs-built_in">push_back</span>(edge[i].second);<br>        <span class="hljs-built_in">backtrack</span>(edge, edge[i].second);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.first &lt; b.first;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">edge</span>(M);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; M;i++) &#123;<br>        cin &gt;&gt; edge[i].first &gt;&gt; edge[i].second;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(edge.<span class="hljs-built_in">begin</span>(), edge.<span class="hljs-built_in">end</span>(), cmp);<br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">backtrack</span>(edge, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">empty</span>()) cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; (<span class="hljs-type">int</span>)ans.<span class="hljs-built_in">size</span>();i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; ans[i].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;j++) &#123;<br>            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; ans[i].<span class="hljs-built_in">back</span>();<br>        <span class="hljs-keyword">if</span>(i != ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day51</title>
    <link href="/2024/07/12/leetcode-day51/"/>
    <url>/2024/07/12/leetcode-day51/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/trapping-rain-water/description/">42.接雨水</a> <span class="label label-danger">hard</span></li><li><a href="">84. 柱状图中最大的矩形</a> <span class="label label-danger">hard</span></li></ul><h1 id="接雨水">42. 接雨水</h1><p><strong>题目：</strong></p><p>给定 n 个非负整数表示每个宽度为 1的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure><imgsrc="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png"alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br />输出：6<br />解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1]表示的高度图，在这种情况下，可以接 6个单位的雨水（蓝色部分表示雨水）。</p><p><strong>思路：</strong></p><p>由木桶效应，水量由最短板决定，所以这里每一格的水量由左右两边最低的柱子决定，同时还要减去自己的高度。</p><p>那么就需要知道每一格左右两边的最高柱子，取其小作为水面高度，减去自身高度即为水深。</p><p><strong>求左右两边的某最值，且为一维数组，就尝试用单调栈。</strong></p><p><strong>个人版</strong>：设左右两个栈，底到顶递增，由于左右两柱子不接水，从左到右遍历就左栈只入栈最左柱，右栈入栈[2:size- 1]，然后取两个栈顶中较小的。</p><p>计算完当前柱，要把当前柱入栈左栈，注意维护大小关系，若当前高度等于右栈的栈底最大值，则要移除右栈的栈底。故数据结构用deque</p><p><strong>carl版</strong>：一个栈就够了，栈规则相同递增，如果遇到比栈顶大的，就逐个出栈计算值，直到栈空或遇到左高柱。一次取当前柱(右柱)，栈顶柱(凹陷)，栈次顶柱(左柱)，算中间凹陷的水量。</p><ul><li>另有双指针版，两个数组left、right分别表示heights[i]对应的左边最大值left[i]和右边最大值right[i]，初始先从左到右遍历得到left，从右到左遍历得到right，再遍历整个计算水量。需要注意维护和初始化</li></ul><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(height.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        deque&lt;<span class="hljs-type">int</span>&gt; left, right;<br>        left.<span class="hljs-built_in">push_front</span>(height[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt; height.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">while</span>(!right.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; right.<span class="hljs-built_in">back</span>()) &#123;<br>                right.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            right.<span class="hljs-built_in">push_back</span>(height[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i++) &#123;<br>            <span class="hljs-type">int</span> l = left.<span class="hljs-built_in">front</span>(), r = right.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">min</span>(l, r) - height[i] &gt; <span class="hljs-number">0</span>) ans += <span class="hljs-built_in">min</span>(l, r) - height[i];<br>            <span class="hljs-keyword">while</span>(!left.<span class="hljs-built_in">empty</span>() &amp;&amp; left.<span class="hljs-built_in">back</span>() &lt; height[i]) &#123;<br>                left.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            left.<span class="hljs-built_in">push_back</span>(height[i]);<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">1</span> &amp;&amp; right.<span class="hljs-built_in">front</span>() == height[i]) right.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>carl版： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (height.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 可以不加</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">// 存着下标，计算的时候用下标对应的柱子高度</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (height[i] &lt; height[st.<span class="hljs-built_in">top</span>()]) &#123;     <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">if</span> (height[i] == height[st.<span class="hljs-built_in">top</span>()]) &#123;  <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 注意这里是while</span><br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[st.<span class="hljs-built_in">top</span>()], height[i]) - height[mid];<br>                        <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意减一，只求中间宽度</span><br>                        sum += h * w;<br>                    &#125;<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure> # 84. 柱状图中最大的矩形</p><p><strong>题目：</strong></p><p>给定 n个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><figure><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>输入：heights = [2,1,5,6,2,3]<br />输出：10<br />解释：最大的矩形为图中红色区域，面积为 10</p><p><strong>思路：</strong></p><p>要么追求高度，要么追求宽度，都得兼顾，每次计算都算包含当前柱的矩形面积，需要知道<strong>左边不小于自己的最远的柱子，右边不小于自己的最远的柱子</strong>。</p><p><strong>单调栈</strong>：不小于自己的最远柱，那么入栈不小于的，<strong>碰到比栈顶小的就说明不能再贪宽度了</strong>，否则就损失高度了，此时逐个出栈计算面积，刚开始高窄，后面矮宽，总有一个最大，直到栈空或比栈顶大。</p><p><strong>双指针</strong>：</p><p>左右都遍历，与上面相同的顺序，只是每次循环内要再循环一次往找过的地方针对当前柱找<strong>不小于的最远柱</strong>，可以利用已经计算的left和right数组跳跃寻找。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(heights.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> heights[<span class="hljs-number">0</span>];<br>        &#125;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        heights.<span class="hljs-built_in">insert</span>(heights.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);<br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; heights.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[st.<span class="hljs-built_in">top</span>()] &gt; heights[i]) &#123;<br>                <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                    <span class="hljs-type">int</span> right = i;<br>                    <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">top</span>();<br>                    ans = <span class="hljs-built_in">max</span>(ans, heights[mid] * (right - left - <span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>双指针： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-comment">//左边大于自己的最远的，右边大于自己的最远的</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(heights.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(heights.size(), heights.size())</span></span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; heights.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-type">int</span> t = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(t &gt;= <span class="hljs-number">0</span> &amp;&amp; heights[t] &gt;= heights[i]) t = left[t];<br>            left[i] = t;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = heights.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-type">int</span> t = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(t &lt; heights.<span class="hljs-built_in">size</span>() &amp;&amp; heights[t] &gt;= heights[i]) t = right[t];<br>            right[i] = t;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; heights.<span class="hljs-built_in">size</span>();i++) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, heights[i] * (right[i] - left[i] - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="小结">小结</h1><p>单调栈适用于找一维数组上，每个元素左右最大最小之类的最值。</p><p>设定好规则后，只需入栈符合规则的，遇到违背规则的就逐个出栈处理，直到符合规则，注意初始化以使栈内元素都能得到处理，防止漏解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day50</title>
    <link href="/2024/07/11/leetcode-day50/"/>
    <url>/2024/07/11/leetcode-day50/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/daily-temperatures/description/">739.每日温度</a> <span class="label label-warning">medium</span></li><li><a href="">496.下一个更大元素 I</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/next-greater-element-ii/description/">503.下一个更大元素II</a><span class="label label-warning">medium</span></li></ul><h1 id="每日温度">739. 每日温度</h1><h2 id="题目"><strong>题目：</strong></h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer，其中 answer[i] 是指对于第 i天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用0 来代替。</p><p>示例 1: 输入: temperatures = [73,74,75,71,69,72,76,73]<br />输出: [1,1,4,2,1,1,0,0]<br />示例 2:<br />输入: temperatures = [30,40,50,60]<br />输出: [1,1,1,0]<br />示例 3:<br />输入: temperatures = [30,60,90]<br />输出: [1,1,0]</p><h2 id="思路"><strong>思路：</strong></h2><h3 id="首次思路">首次思路</h3><p>既然是单调栈专题，之前遇到过单调栈，但只有模糊的认识：单调栈就是有一个特殊入栈出栈规则的栈，这个规则构成了单调。</p><p>于是“照虎画猫”，开一个栈，使其从栈底到栈顶非递减，即：<br />- 元素比栈顶小或相等，入栈 - 元素比栈顶大，不断出栈直至比栈顶小或空</p><p>遍历到最后栈内的都是没有升高的，在初始化时就置零，之后就不用管了直接返回。</p><p>写的时候就能悟到，栈里面存下标要方便得多，于是写出下面的<ahref="#自己的-每日温度">代码</a></p><h3 id="carl思路">carl思路</h3><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。</strong></p><ul><li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况:入栈</li><li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况：入栈</li><li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况：不断出栈到不大于或空</li></ul><p>栈内存下标。</p><h2 id="代码">代码</h2><h3 id="自己的-每日温度">自己的-每日温度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; temperatures.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>()) &#123;<br>                st.<span class="hljs-built_in">push</span>(i);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[st.<span class="hljs-built_in">top</span>()] &lt; temperatures[i]) &#123;<br>                    ans[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl的-每日温度">carl的-每日温度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; T)</span> </span>&#123;<br>        <span class="hljs-comment">// 递增栈</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(T.size(), <span class="hljs-number">0</span>)</span></span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; T.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (T[i] &lt; T[st.<span class="hljs-built_in">top</span>()]) &#123;                       <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T[i] == T[st.<span class="hljs-built_in">top</span>()]) &#123;               <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; T[i] &gt; T[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况三</span><br>                    result[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="下一个更大元素-i">496.下一个更大元素 I</h1><p><strong>题目：</strong></p><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的第一个 比 x 大的元素。</p><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0开始计数，其中nums1 是 nums2 的子集。</p><p>对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j]的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</p><p>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i]是如上所述的 下一个更大元素 。</p><p>示例 1：<br />输入：nums1 = [4,1,2], nums2 = [1,3,4,2].<br />输出：[-1,3,-1]<br />解释：nums1 中每个值的下一个更大元素如下所述：<br />- 4 ，用加粗斜体标识，nums2 =[1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br />- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。<br />- 2 ，用加粗斜体标识，nums2 =[1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br />示例 2： 输入：nums1 = [2,4], nums2 = [1,2,3,4].<br />输出：[3,-1]<br />解释：nums1 中每个值的下一个更大元素如下所述：<br />- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。 - 4，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1。<br />提示：<br />- <span class="math inline">\(1 &lt;= nums1.length &lt;= nums2.length&lt;= 1000\)</span><br />- <span class="math inline">\(0 &lt;= nums1[i], nums2[i] &lt;=10^4\)</span><br />- nums1和nums2中所有整数 互不相同<br />- nums1 中的所有整数同样出现在 nums2 中</p><h2 id="思路-1"><strong>思路：</strong></h2><h3 id="首次思路-1">首次思路</h3><p>俩for循环暴力搜索，我自己用单调栈好像也没优化到哪里去……</p><h3 id="carl的思路">carl的思路</h3><p>用map记忆化遍历，再遍历nums2，这样就不用在外面套一层nums1</p><h2 id="代码-1">代码</h2><h3 id="自己的-下一个最大元素i">自己的-下一个最大元素I</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums1.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-type">int</span> next = <span class="hljs-number">-1</span>;<span class="hljs-comment">//还没找到，先设置-1</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; nums2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums2[j] == nums1[i]) &#123;<br>                    next = nums2[j];<span class="hljs-comment">//找到了，开始找大</span><br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(next == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//没找到继续找</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums2[j] &gt; next) &#123;<br>                    ans[i] = nums2[j];<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl的-下一个最大元素i">carl的-下一个最大元素I</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums1.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">// key:下标元素，value：下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            umap[nums1[i]] = i;<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">count</span>(nums2[st.<span class="hljs-built_in">top</span>()]) &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 看map里是否存在这个元素</span><br>                    <span class="hljs-type">int</span> index = umap[nums2[st.<span class="hljs-built_in">top</span>()]]; <span class="hljs-comment">// 根据map找到nums2[st.top()] 在 nums1中的下标</span><br>                    result[index] = nums2[i];<br>                &#125;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="下一个更大元素ii">503.下一个更大元素II</h1><h2 id="题目-1"><strong>题目：</strong></h2><p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0]），返回 nums 中每个元素的 下一个更大元素 。</p><p>数字 x 的 下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出-1 。<br />示例 1:<br />输入: nums = [1,2,1]<br />输出: [2,-1,2]<br />解释: 第一个 1 的下一个更大的数是 2；<br />数字 2 找不到下一个更大的数；<br />第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br />示例 2:<br />输入: nums = [1,2,3,4,3]<br />输出: [2,3,4,-1,4]<br />提示:<br /><span class="math inline">\(1 &lt;= nums.length &lt;=10^4\)</span><br /><span class="math inline">\(-10^9 &lt;= nums[i] &lt;=10^9\)</span><br />## <strong>思路：</strong> ### 我的思路</p><p>循环走就行，栈底的肯定最先被再次访问到，如果再次访问到栈底，那就退出，但是栈底还得用一次来挤出靠后的小元素，所以出循环得放在处理元素的后面。</p><p>既然要访问栈底，那用deque模拟栈。剩下的和之前如出一辙。</p><p>运行下来好像我的更快一点点，吼吼吼。 ### carl的思路</p><p>妙哉，把nums倍增一段，就算循环了，可以物理上直接倍增nums，也可以循环的时候把for的次数改成nums.size()*2，下标取模算法倍增。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[dq.<span class="hljs-built_in">back</span>()] &lt; nums[i]) &#123;<br>                ans[dq.<span class="hljs-built_in">back</span>()] = nums[i];<br>                dq.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; i == dq.<span class="hljs-built_in">front</span>()) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//不能放while开头，会少处理</span><br>            <span class="hljs-keyword">if</span>(ans[i] == <span class="hljs-number">-1</span>) dq.<span class="hljs-built_in">push_back</span>(i);<br>            i = (i+<span class="hljs-number">1</span>) % n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>carl的 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">// 模拟遍历两边nums，注意一下都是用i % nums.size()来操作</span><br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="hljs-built_in">size</span>()] &gt; nums[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                result[st.<span class="hljs-built_in">top</span>()] = nums[i % nums.<span class="hljs-built_in">size</span>()];<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day49</title>
    <link href="/2024/07/10/leetcode-day49/"/>
    <url>/2024/07/10/leetcode-day49/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/palindromic-substrings/description/">647.回文子串</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516.最长回文子序列</a> <span class="label label-warning">medium</span></li></ul><h1 id="回文子串">647. 回文子串</h1><p><strong>题目：</strong></p><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p><strong>思路：</strong></p><ol type="1"><li>确定dp含义<br />dp[i][j]表示区间s[i:j]是不是回文串<br /></li><li>确定状态转移<br /></li></ol><ul><li>s[i] == s[j]<ul><li>j - i &lt;= 1，i和j相同或挨着，dp[i][j] = true;</li><li>else，dp[i][j] = dp[i+1][j-1]，看内部是不是回文串</li></ul></li><li>s[i] != s[j]：对不上，s[i:j]不可能是回文串了，false<br /></li></ul><ol start="3" type="1"><li>初始化<br />全false</li></ol><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; s.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j]) &#123;<br>                    <span class="hljs-keyword">if</span>(i == j || i + <span class="hljs-number">1</span> == j || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                        ans++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="双指针写法">双指针写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">//复习双指针写法</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            ans += <span class="hljs-built_in">count</span>(s, i, i);<br>            ans += <span class="hljs-built_in">count</span>(s, i, i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> mid1, <span class="hljs-type">int</span> mid2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(mid2 &gt;= s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = mid1, right = mid2;<br>        <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(s[left] == s[right]) res++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            left--, right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最长回文子串">516. 最长回文子串</h1><p><strong>题目：</strong></p><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong><br />- 输入：s = "bbbab" - 输出：4 - 解释：一个可能的最长回文子序列为 "bbbb"。</p><p><strong>提示：</strong><br />- 1 &lt;= s.length &lt;= 1000 - s 仅由小写英文字母组成</p><p><strong>思路：</strong></p><ol type="1"><li>确定dp含义：<br />dp[i][j]表示区间s[i:j]内的最长回文子串长度<br /></li><li>确定状态转移：<br /></li></ol><ul><li>s[i] == s[j]<ul><li>i == j，dp[i][j]=1</li><li>dp[i][j] = dp[i-1][j-1]+2</li></ul></li><li>s[i] != s[j]: max(dp[i-1][j], dp[i][j-1])</li></ul><ol start="3" type="1"><li>初始化<br />相等的ij就置1</li></ol><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) dp[i][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;j &lt; s.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j]) &#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="其他">其他</h1><p>动态规划跟着carl刷完了，提亮看起来貌似也有这么多，但其中过半都不是自己独立做出来的，看一半题解再做、看了一半还是不会于是全抄……动态规划仍然有很多要学，仍然要多做题，今天的两道题都没有做出来，找其他的回文题仍然不会。</p><p>在做dp专题时其实有很多题的难点是想到要用dp，而做专题本身就已经告诉你每道题都可以用dp，而且carl的题安排精妙，相邻的题很多都是相同的套路，如果单拿出来做，我大概率是做不出出来的，上周周赛的Q4很像完全背包专题中的一道题，但写出来不是TLE就是WA，看评论才发现不能直接dp，所以刷题之路任重道远，戒骄戒躁，不能太依赖题解，要多自己独立思考，更不能潜移默化地被评论、tag提示。不能3分钟没思路就跑去看题解了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day48</title>
    <link href="/2024/07/09/leetcode-day48/"/>
    <url>/2024/07/09/leetcode-day48/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/distinct-subsequences/description/">115.不同的子序列</a> <span class="label label-danger">hard</span></li><li><a href="">583. 两个字符串的删除操作</a> <span class="label label-warning">medium</span></li><li><a href="">72. 编辑距离</a> <span class="label label-warning">medium</span></li></ul><h1 id="不同的子序列">115. 不同的子序列</h1><p><strong>题目：</strong></p><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在<code>s</code> 的 子序列 中 <code>t</code> 出现的个数，结果需要对 <spanclass="math inline">\(10^9 + 7\)</span> 取模。</p><blockquote><p><strong>示例 1：</strong></p><p><strong>输入：</strong> <code>s</code> = <code>"rabbbit"</code>,<code>t</code> = <code>"rabbit"</code></p><p><strong>输出：</strong> 3</p><p><strong>解释：</strong></p><p>如下所示, 有 3 种可以从 <code>s</code> 中得到 <code>"rabbit"</code>的方案。 - <u>rabb</u>b<u>it</u> - <u>ra</u>b<u>bbit</u> -<u>rab</u>b<u>bit</u></p></blockquote><p><strong>思路：</strong></p><ol type="1"><li><p>明确dp数组含义：两个子序列，仍然按照之前的老办法，二维dp，大小比串长度多1，方便初始化，<spanclass="math inline">\(dp[i][j]\)</span>含义为：在<spanclass="math inline">\(s[0:i-1]\)</span>中，<spanclass="math inline">\(t[0:j-1]\)</span>出现的个数。</p></li><li><p>建立状态转移方程：整体分为两种情况：</p><ul><li><span class="math inline">\(s[i-1] ==t[j-1]\)</span>：此时最新的s[i-1]和t[j-1]相同：<ul><li><p>如果算上<span class="math inline">\(s[i-1]\)</span>，<spanclass="math inline">\(t\)</span>就会被消耗一个，此时子序列个数就为<spanclass="math inline">\(dp[i-1][j-1]\)</span>，表示<code>s[0:i-1]中t[0:j-1]出现次数</code></p></li><li><p>但根据示例可看出：即使<spanclass="math inline">\(s[i-1]==t[j-1]\)</span>，<spanclass="math inline">\(s[i-1]\)</span>也可以不用于匹配，这时子序列个数就为<spanclass="math inline">\(dp[i-1][j]\)</span>，表示<code>s[0:i-2]</code>中<code>t[0:j-1]</code>出现次数</p></li></ul></li><li><span class="math inline">\(s[i-1] ≠t[j-1]\)</span>：此时最新的<spanclass="math inline">\(s[i-1]\)</span>和<spanclass="math inline">\(t[j-1]\)</span>不相同，意味着s中未出现新的t，所以只继承前面的结果<spanclass="math inline">\(dp[i-1][j]\)</span>，表示<code>s[0:i-2]</code>中<code>t[0:j-1]</code>出现的次数</li></ul><p>由此可构建出状态转移方程：</p></li></ol><p><span class="math display">\[dp[i][j]\ =\begin{cases}1, &amp; \text{$j=0,\ i&gt;0$} \\0, &amp; \text{$i=0,\ j&gt;0$} \\dp[i-1][j-1]+dp[i-1][j], &amp; \text{$s[i-1]=t[j-1],\ i,\ j&gt;0$} \\dp[i-1][j], &amp; \text{$s[i-1]=t[j-1],\ i,\ j&gt;0$}\end{cases}\]</span></p><p>根据状态转移方程可知需由左上遍历到右下</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt; (t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= t.<span class="hljs-built_in">size</span>();j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= s.<span class="hljs-built_in">size</span>();i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= t.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<span class="hljs-comment">//</span><br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)dp[s.<span class="hljs-built_in">size</span>()][t.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="两个字符串的删除操作">583. 两个字符串的删除操作</h1><p><strong>题目：</strong></p><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得<code>word1</code> 和 <code>word2</code>相同所需的最小步数。</p><p>每步可以删除任意一个字符串中的一个字符。</p><p><strong>示例 1：</strong></p><ul><li>输入: <code>word1</code> = <code>"sea"</code>, <code>word2</code> =<code>"eat"</code></li><li>输出: 2</li><li>解释: 第一步将 <code>"sea"</code> 变为 <code>"ea"</code> ，第二步将<code>"eat "</code>变为 <code>"ea"</code></li></ul><p><strong>思路：</strong></p><p>二维dp：</p><ol type="1"><li>确定dp数组以及下标含义</li></ol><p><span class="math inline">\(dp[i][j]\)</span>表示<spanclass="math inline">\(word1[0:i-1]\)</span>和<spanclass="math inline">\(word2[0:j-1]\)</span>达到相等需要的最小步数</p><ol start="2" type="1"><li>确定递推公式</li></ol><ul><li><span class="math inline">\(word1[i-1] ==word2[j-1]\)</span>时，无需删除，直接继承之前状态</li><li><span class="math inline">\(word1[i-1] ≠ word2[j-1]\)</span>时：<ul><li>删<span class="math inline">\(word1[i-1]\)</span>，步数为<spanclass="math inline">\(dp[i-1][j]+1\)</span></li><li>删<span class="math inline">\(word2[j-1]\)</span>，步数为<spanclass="math inline">\(dp[i][j-1]+1\)</span></li><li>都删了，步数为<span class="math inline">\(dp[i-1][j-1]+2 =dp[i-1][j] + 1\)</span>，和前两种情况相同</li></ul></li></ul><p>状态转移方程为：</p><p><span class="math display">\[dp[i][j]\ =\begin{cases}i, &amp; \text{$i&gt;0,j=0$} \\j, &amp; \text{$j&gt;0,i=0$} \\min(dp[i-1][j], dp[i][j-1])+1, &amp; \text{$i,\ j&gt;0,\word_1[i]≠word_2[j]$} \\dp[i-1][j-1], &amp; \text{else}\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= word2.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= word2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-built_in">size</span>()][word2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="编辑距离">72. 编辑距离</h1><p><strong>题目：</strong></p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将<code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>思路：</strong></p><p>经过前几题，这题要理解到插入其实相当于删除，在一个串中插入，就相当于在另一个串中删除</p><ol type="1"><li>确定dp数组以及下标含义</li></ol><p><span class="math inline">\(dp[i][j]\)</span>表示<spanclass="math inline">\(word1[0:i-1]\)</span>和<spanclass="math inline">\(word2[0:j-1]\)</span>达到相等需要的最小操作数</p><ol start="2" type="1"><li>确定递推公式</li></ol><ul><li><span class="math inline">\(word1[i-1] ==word2[j-1]\)</span>时，无需操作，直接继承之前状态</li><li><span class="math inline">\(word1[i-1] ≠ word2[j-1]\)</span>时：<ul><li>删<span class="math inline">\(word1[i-1]\)</span>，步数为<spanclass="math inline">\(dp[i-1][j]+1\)</span></li><li>删<span class="math inline">\(word2[j-1]\)</span>，步数为<spanclass="math inline">\(dp[i][j-1]+1\)</span></li><li>替换其中一个，步数为<spanclass="math inline">\(dp[i-1][j-1]+1\)</span></li></ul></li></ul><p>状态转移方程为：</p><p><span class="math display">\[dp[i][j]\ =\begin{cases}i, &amp; \text{$i&gt;0,j=0$} \\j, &amp; \text{$j&gt;0,i=0$} \\min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1, &amp; \text{$i,\ j&gt;0,\word_1[i]≠word_2[j]$} \\dp[i-1][j-1], &amp; \text{else}\end{cases}\]</span></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= word2.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= word2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]&#125;) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-built_in">size</span>()][word2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git提交PR</title>
    <link href="/2024/07/08/%E8%AE%B0%E4%B8%80%E6%AC%A1git%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E7%BB%8F%E5%8E%86/"/>
    <url>/2024/07/08/%E8%AE%B0%E4%B8%80%E6%AC%A1git%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E7%BB%8F%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="本文背景">本文背景</h1><p>期末考完想向学长的资料公开仓库贡献一些资料，顺便帮助建设一下混个contributor当当。但是只在自己的大小号上实践过PR(pullrequest)操作的我头一次向别人的repo(repository)提交PR，遂记录过程中遇到的问题和解决方法，倒逼自己搞清楚其中原因。同时也作为提交PR的教程作参考。</p><p>本文关于git操作的说法偏向浅显易懂，稍有啰嗦，如有原理性错误，烦请批评指正，联系方式见<ahref="https://novelyear.github.io/about/">关于页</a>。</p><h1 id="问题描述">问题描述</h1><ol type="1"><li><p>我在GitHub上fork了别人的仓库，然后将fork的仓库pull到本地进行修改，修改后push到fork的仓库的master分支，然后又在github上直接在main分支上新增了内容，请问我该如何将远程仓库的main上的新内容和远程仓库上master分支的内容融合，两个内容并无重合，都是新内容。如何合并分支并提交PR？</p></li><li><p>我在本地又修改了文件，在main分支上commit了该修改，并push到远程仓库上，但是并未发生改变，我更新了远程仓库，然后在main分支fetch了，随后发现本地修改的文件又回到了原状，于是重新修改，并切换到master分支add和commit，在切换回main分支并fetch和pull之后，merge时提示冲突，应该如何解决？</p></li></ol><h1 id="提交pr前的准备工作">提交PR前的准备工作</h1><blockquote><p>提交PR首先得先改好才能交 ## fork目标repo进入目标repo的首页，即页面栏显示<code>Code</code>字样、域名末尾为repo名称的页。</p></blockquote><p>点击fork，将在自己的名下新建一个同名repo，相当于把对方的repo复制到了自己名下，这样就可以任意修改内容而不至于对原repo的内容造成影响，并且，<strong>只有fork了才能向原仓库提交PR</strong>。## 拿到本地进行修改这时名下已经有了一个同名repo，在本地新建个文件夹用来装这个repo的内容，在这个文件夹里打开gitbash，在fork来的repo里复制链接，<code>git pull</code>到本地。</p><blockquote><p>若读者尚未将git与github绑定，请参见：</p></blockquote><p>此时可用<code>git branch</code>查看当前分支，大概率是<code>master</code>，因为<code>git pull</code>只给远程分支不给本地分支名默认为<code>master</code>。</p><p>用<code>git remote -v</code>查看当前远程分支，如果没有，就<code>git remote add BRANCH_NAME URL</code>添加，url就是repo的链接,BRANCH_NAME就是远程分支的名字，一般设置成<code>origin</code>。</p><p>然后就可以开始在本地修改内容啦！</p><h2 id="修改完提交到远程仓库">修改完提交到远程仓库</h2><p>修改完后，再回到gitbash，<code>git add .</code>和<code>git commit</code>，可用<code>git status</code>查看跟踪(add)和提交(commit)的状态。</p><p><code>git push origin master</code>，就当你的远程分支名字是origin，将分支master提交到origin分支上去，即上传到远程仓库。</p><h1 id="提交pr">提交PR</h1><p>此时回到fork来的repo，点击contribute，会显示当前已经领先原repo多少个commit，直接openpr，描述一下修改内容，点击提交就成功提交了PR。</p><h3 id="问题1解决过程">问题1解决过程</h3><blockquote><p>问题1可对应到实际场景中自己工作完成慢了，别人先交了PR过了，自己还得去迎合别人的分支，解决完冲突才能提交。</p></blockquote><p>我在本地修改完后还未提交前，在远程仓库上直接做了修改，这导致我的远程仓库除了我本地修改的内容外，还有其他内容与本地master分支不一样，所以不能直接push</p><p>先在本地再创建一个main分支<code>git checkout main</code>，然后将最新的远程仓库pull到main分支，在本地合并main和master分支<code>git merge master</code></p><p>由于master和远程分支origin修改的地方不同，所以不会有冲突，直接merge成功，然后在main分支上再add、commit、push。</p><p>其实也可以将main融进master中，使master始终最新，方便进一步修改。</p><h3 id="问题2解决过程">问题2解决过程</h3><blockquote><p>问题2对应到实际场景中提交了PR结果被打回重造，这期间又有人交了PR还过了，不得不再去融合别人的分支，可恨的是这个人和你修改的文件还是同一个，还不能直接merge。</p></blockquote><p>仍然在main中pull最新的远程仓库，如果是fork来的，还要先在github上同步。</p><p>然后gitmerge，会显示冲突的文件，在本地打开文件(推荐使用vscode等支持git的IDE，会高亮显示冲突)，找到冲突的地方，会有明显的标志，类似于：<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>// changes from main branch<br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br>// changes from master branch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; master<br></code></pre></td></tr></table></figure>这时需要选择采用当前的分支、采用另一个分支还是融合内容，融合好后才能merge。之后就一般流程：add、commit、push。</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day47</title>
    <link href="/2024/07/08/leetcode-day47/"/>
    <url>/2024/07/08/leetcode-day47/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/longest-common-subsequence/">1143.最长公共子序列</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/uncrossed-lines/">1035.不相交的线</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/is-subsequence/">392.判断子序列</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/maximum-subarray/description/">53.最大子数组和</a> <span class="label label-warning">medium</span></li></ul><h1 id="最长公共子序列">1143. 最长公共子序列</h1><p><strong>题目：</strong></p><p>给定两个字符串 <code>text1</code> 和<code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong>的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code>。</p><p>一个字符串的 <strong>子序列</strong>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但<code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li></ul><p>两个字符串的 <code>公共子序列</code>是这两个字符串所共同拥有的子序列。</p><p><strong>思路：</strong></p><p>有两个string，公共子序列出现的地方可能不同，需要i和j两个变量来记录公共子序列在两个string里的范围，以范围逐渐扩张来实现状态的不断推进，二维动态规划。</p><p><strong>1. 确定dp数组含义</strong></p><p><span class="math inline">\(dp[i][j]\)</span>表示字符串<spanclass="math inline">\(text_1\)</span>长度为i的前缀，即<spanclass="math inline">\(text1[0:i]\)</span>，和<spanclass="math inline">\(text_2\)</span>长度为j的前缀的最长公共子序列的长度。</p><p><strong>2. 确定状态转移方程</strong></p><p><span class="math display">\[dp[i][j]\ =\begin{cases}dp[i-1][j-1]+1, &amp; \text{$text_1[i-1]=text_2[j-1]$} \\max(dp[i-1][j],\ dp[i][j-1]), &amp; \text{$text_1[i-1]≠text_2[j-1]$}\end{cases}\]</span></p><p>解释：</p><ul><li>当<spanclass="math inline">\(text_1[i-1]=text_2[j-1]\)</span>时，<spanclass="math inline">\(text_1\)</span>长度为<spanclass="math inline">\(i\)</span>的前缀结尾与<spanclass="math inline">\(text_2\)</span>长度为<spanclass="math inline">\(j\)</span>的前缀结尾相同，在长度为<spanclass="math inline">\(i-1\)</span>和<spanclass="math inline">\(j-1\)</span>的最长公共子序列基础上再加一，即<spanclass="math inline">\(dp[i-1][j-1]+1\)</span></li><li>当<spanclass="math inline">\(text_1[i-1]≠text_2[j-1]\)</span>时，相当于末尾没对上，这时不能在之前的基础上加一，需要继承之前的结果，而之前有两个前缀：<ul><li><span class="math inline">\(text_1[0:i-1]\)</span>和<spanclass="math inline">\(text_2[0:j]\)</span>的最长公共子序列</li><li><span class="math inline">\(text_2[0:j-1]\)</span>和<spanclass="math inline">\(text_1[0:i]\)</span>的最长公共子序列</li></ul></li><li>取其中最大值。</li></ul><p><strong>3. 初始化</strong></p><p>为了方便初始化，dp数组的大小设置成了<spanclass="math inline">\((text_1.size()+1)*(text_2.size()+1)\)</span>表示一个左闭右开的区间，同时也以下标表示前缀长度。</p><p>此时<spanclass="math inline">\(dp[0][0]\)</span>实际无意义，所以初始化<spanclass="math inline">\(0\)</span>，遍历都从<spanclass="math inline">\(0\)</span>开始。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= text1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= text2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(text1[i - <span class="hljs-number">1</span>] != text2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.<span class="hljs-built_in">size</span>()][text2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="不相交的线">1035. 不相交的线</h1><p><strong>题目：</strong></p><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和<code>nums2</code> 中的整数。</p><p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和<code>nums2[j]</code> 的直线，这些直线需要同时满足：</p><ul><li><code>nums1[i] == nums2[j]</code></li><li>且绘制的直线不与任何其他连线（非水平线）相交。</li></ul><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p><p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p><figure><img src="https://assets.leetcode.com/uploads/2019/04/26/142.png"alt="盗链lc" /><figcaption aria-hidden="true">盗链lc</figcaption></figure><p><strong>思路：</strong></p><p>看图就会发现，这简直就是上一道题换皮，直接套代码就行。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxUncrossedLines</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-comment">//换皮最长公共子序列</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= nums1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= nums2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums1.<span class="hljs-built_in">size</span>()][nums2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="判断子序列">392. 判断子序列</h1><p><strong>题目：</strong></p><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断<strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>"ace"</code>是<code>"abcde"</code>的一个子序列，而<code>"aec"</code>不是）。</p><p><strong>进阶：</strong></p><p>如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k &gt;=10亿，你需要依次检查它们是否为 T的子序列。在这种情况下，你会怎样改变代码？</p><p><strong>思路：</strong></p><p>双指针，短的匹配到再走，长的一直走，短的走到头则是子序列。</p><p>动态规划：</p><ul><li>参考1143题的初始化方法，dp数组初始化为<spanclass="math inline">\((s.size()+1)*(t.size()+1)\)</span>，使<spanclass="math inline">\(dp[0][0]\)</span>无意义。遍历都从1开始。</li><li><span class="math inline">\(dp[i][j]\)</span>代表<spanclass="math inline">\(s[0:i-1]\)</span>和<spanclass="math inline">\(t[0:j-1]\)</span>公共子序列长度</li><li>状态转移方程为：</li></ul><p><span class="math display">\[dp[i][j]\ =\begin{cases}dp[i-1][j-1]+1, &amp; \text{$s[i-1]=t[j-1], i,j&gt;0$} \\dp[i][j-1], &amp; \text{$else$}\end{cases}\]</span></p><ul><li>匹配到则推进状态，公共子序列长度加一</li><li>未匹配则继承状态，注意<spanclass="math inline">\(s\)</span>不前进而<spanclass="math inline">\(t\)</span>前进，代表继续在<spanclass="math inline">\(t\)</span>中寻找<spanclass="math inline">\(s[i]\)</span></li></ul><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &gt; t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//开大一个，方便处理0情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= t.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<span class="hljs-comment">//匹配，i和j都往前走</span><br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<span class="hljs-comment">//未匹配，s不能动，t往前走</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()][t.<span class="hljs-built_in">size</span>()] == s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//如果s走到最后，则是</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最大子数组和">53. 最大子数组和</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><p><strong>思路：</strong></p><p>依据贪心的思路，可以迁移到动态规划来，贪心就是和为负之后，就对之后没有贡献了，直接抛弃，将下一个作为新起点重新计算子数组和，动态规划也可以这样：</p><ul><li><span class="math inline">\(dp[i]\)</span>代表以<spanclass="math inline">\(nums[i]\)</span>结尾的最大子数组和</li><li>若<spanclass="math inline">\(dp[i-1]&lt;0\)</span>，则抛弃，以当前<spanclass="math inline">\(nums[i]\)</span>作为新起点：<spanclass="math inline">\(dp[i] = nums[i]\)</span></li><li>若<spanclass="math inline">\(dp[i-1]&gt;=0\)</span>，则继承结果：<spanclass="math inline">\(dp[i] = dp[i-1]+nums[i]\)</span></li><li><span class="math inline">\(dp[0]\)</span>按意义该初始化为<spanclass="math inline">\(nums[0]\)</span></li><li>用一个变量记录其中最大的子数组和</li></ul><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(dp[i - <span class="hljs-number">1</span>] &lt;= <span class="hljs-number">0</span>) dp[i] = nums[i];<br>            <span class="hljs-keyword">else</span> dp[i] = dp[i - <span class="hljs-number">1</span>] + nums[i];<br>            ans = <span class="hljs-built_in">max</span>(dp[i], ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day45</title>
    <link href="/2024/07/07/leetcode-day45/"/>
    <url>/2024/07/07/leetcode-day45/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674.最长连续递增子序列</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718.最长重复子数组</a> <span class="label label-warning">medium</span></li></ul><h1 id="最长递增子序列">300. 最长递增子序列</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code>是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>思路：</strong></p><p><span class="math inline">\(dp[i]\)</span>表示以<spanclass="math inline">\(nums[i]\)</span>结尾的最长递增子序列长度，强制以<spanclass="math inline">\(nums[i]\)</span>结尾为的是方便状态转移，状态转移方程为：</p><p><span class="math display">\[dp[i]\ =\begin{cases}1, &amp; \text{$i = 1$} \\max(dp[j] + 1, dp[i]), &amp; \text{$i &gt; 1,\ j=0,1,2,……,i-1$}\end{cases}\]</span></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; i;j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[j] + <span class="hljs-number">1</span>, dp[i]);<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最长连续递增子序列">674. 最长连续递增子序列</h1><p><strong>题目：</strong></p><p>给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 <code>l</code> 和<code>r</code>（<code>l &lt; r</code>）确定，如果对于每个<code>l &lt;= i &lt; r</code>，都有<code>nums[i] &lt; nums[i + 1]</code> ，那么子序列<code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code>就是连续递增子序列。</p><p><strong>思路：</strong></p><p>这题感觉就像贪心一样，一直换起点就好，dp换起点就是重新把长度改成1</p><p>dp[i]表示以i结尾的最长连续递增序列长度，状态转换方程为：</p><p><span class="math display">\[dp[i]\ =\begin{cases}1, &amp; \text{$nums[i] ≤ nums[i - 1]$}\\dp[i - 1] + 1, &amp; \text{$nums[i]≥nums[i-1]$}\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-number">1</span>;<br><br>            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最长重复子数组">718. 最长重复子数组</h1><p><strong>题目：</strong></p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度 。</p><p><strong>思路：</strong></p><p>由于两个数组的公共子数组起点可能不一样，所以得用<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>分别表示从<spanclass="math inline">\(nums1\)</span>的<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(nums2\)</span>的<spanclass="math inline">\(j\)</span>开始。</p><p>状态转移方程为：(前提条件都为<code>nums1[i] == nums2[j]</code>)</p><p><span class="math display">\[dp[i][j]\ =\begin{cases}1, &amp; \text{$i=0\ or\ j=0$} \\dp[i-1][j-1]+1, &amp; \text{else}\end{cases}\]</span></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums1.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; nums2.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums1[i] != nums2[j]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) dp[i][j]  = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                ans = <span class="hljs-built_in">max</span>(ans, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day44</title>
    <link href="/2024/07/07/leetcode-day44/"/>
    <url>/2024/07/07/leetcode-day44/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188.买卖股票的最佳时机Ⅳ</a> <span class="label label-danger">hard</span></li><li><a href="">309. 最佳买卖股票时机含冷冻期</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714.买卖股票的最佳时机含手续费</a> <span class="label label-warning">medium</span></li></ul><h1 id="买卖股票的最佳时机ⅳ">188. 买卖股票的最佳时机Ⅳ</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中<code>prices[i]</code> 是某支给定的股票在第 <code>i</code>天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code>笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code>次。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>思路：</strong></p><p>股票题3只能买两次，设置了5个状态，无、1有、1无、2有、2无，迁移到这里就是无 + k组有无，一共<span class="math inline">\(2*k+1\)</span>个状态。</p><p>使用三维dp时空复杂度太过感人，就不写思路了，直接写carl的二维简化版思路：</p><p><span class="math inline">\(dp[i][j]\)</span>表示第<spanclass="math inline">\(i\)</span>天的情况，<spanclass="math inline">\(j\)</span>为状态：</p><ul><li><span class="math inline">\(0\)</span>表示无操作</li><li><span class="math inline">\(1\)</span>表示第一次卖掉</li><li><span class="math inline">\(2\)</span>表示第一次买入</li><li><span class="math inline">\(3\)</span>表示第二次卖掉</li><li><span class="math inline">\(4\)</span>表示第二次买入</li><li>……</li><li><span class="math inline">\(2k-1\)</span>表示第<spanclass="math inline">\(k\)</span>次卖掉</li><li><span class="math inline">\(2k\)</span>表示第<spanclass="math inline">\(k\)</span>次买入</li></ul><p>可见偶数表示买入，奇数表示卖出，详细解释见代码注释：</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt; <span class="hljs-number">2</span> * k;j += <span class="hljs-number">2</span>)<br>      dp[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>];<span class="hljs-comment">//首日买入都是直接减</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>;j += <span class="hljs-number">2</span>) &#123;<br>        dp[i][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j] - prices[i]);<span class="hljs-comment">//i天前交易j+1次不买 = 昨天前交易j+1次没买/昨天前交易j次买了，今天卖掉</span><br>        dp[i][j + <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + prices[i]);<span class="hljs-comment">//i天前交易j+2次买 = 昨天前交易j+1次就买了，今天卖掉/昨天就交易j+2次，已经卖了</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>*k];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最佳买卖股票时机含冷冻期">309. 最佳买卖股票时机含冷冻期</h1><p><strong>题目：</strong></p><p>给定一个整数数组prices，其中第 prices[i] 表示第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>思路：</strong></p><p>没想出来，状态设置出了问题</p><p>卖出后会有冷冻期，由于只有一支股票，所以冷冻期只能无操作，则一天会有4个状态：</p><ul><li>0：无操作</li><li>1：卖出</li><li>2：买入</li><li>3：冷冻期</li></ul><p><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/518d5baaf33f4b2698064f8efb42edbf.png" /></p><p>知道这个就好写代码了</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-comment">//可多次，但不能连续</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//0无操作，1卖，2买，3冷冻</span><br>    dp[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>      dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>      dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] + prices[i]);<br>      dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] - prices[i]);<span class="hljs-comment">//昨天买好/昨天冷冻今天买</span><br>      dp[i][<span class="hljs-number">3</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机含手续费">714. 买卖股票的最佳时机含手续费</h1><p><strong>题目：</strong></p><p>给定一个整数数组 <code>prices</code>，其中<code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数<code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>思路：</strong></p><p>题目的注意指出每组买卖只需要交一次手续费，那设置在卖出时缴纳手续费，其余代码同股票2题一样</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//0buy, 1sell</span><br>    dp[<span class="hljs-number">0</span>] = &#123;-prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] - prices[i]);<br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] + prices[i] - fee);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day43</title>
    <link href="/2024/07/07/leetcode-day43/"/>
    <url>/2024/07/07/leetcode-day43/</url>
    
    <content type="html"><![CDATA[<p>今日内容：股票专题日🤑</p><ul><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121.买卖股票的最佳时机</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122.买卖股票的最佳时机Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123.买卖股票的最佳时机Ⅲ</a> <span class="label label-danger">hard</span></li></ul><h1 id="买卖股票的最佳时机">121. 买卖股票的最佳时机</h1><p><strong>题目：</strong></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素<code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在<strong>未来的某一个不同的日子</strong>卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回<code>0</code> 。</p><p><strong>思路：</strong></p><p>很明显的状态转移，昨天买了和昨天没有买两种情况，昨天买了今天就卖或者持有，昨天没买今天就买或者继续观望，最后返回今天卖了或不卖中的最大值。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = prices.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], -prices[i]);<span class="hljs-comment">//昨天买了；昨天没买今天买</span><br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], prices[i] + dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>]);<span class="hljs-comment">//昨天没买；昨天买了今天卖</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[(len - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<span class="hljs-comment">//卖了肯定比拿手里强，返回卖了的</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机ⅱ">122. 买卖股票的最佳时机Ⅱ</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code>表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候<strong>最多</strong> 只能持有 <strong>一股</strong>股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 你能获得的 <strong>最大</strong> 利润 。</p><p><strong>思路：</strong></p><p>与上一题的区别在于，这题可以多次买卖，如果按贪心来做的话，直接累积上升就可以。</p><p>按dp来做，仍然保留买与没买的状态区别，对于买的状态要修改，上一道题只能买一次，所以买必定是第一次，从0开始算盈亏。这里就需要记录之前的盈亏，因为买不一定是第一次。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-comment">//dp非滚动写法</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    dp[<span class="hljs-number">0</span>] = &#123;-prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//0买，1不买</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-comment">//与上一题的区别：-prices[i]变成了dp[i-1 % 2][1] - prices[i]，在昨天没买的基础上计算</span><br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] - prices[i]); <span class="hljs-comment">//i天买，昨天买了不能再买/昨天没买今天买</span><br>      dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] + prices[i]); <span class="hljs-comment">//i天不买，昨天没买/昨天买了今天卖掉</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机ⅲ">123. 买卖股票的最佳时机Ⅲ</h1><p><strong>题目：</strong></p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第<code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成<strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>思路：</strong></p><p>只能买两次，所以变复杂了很多，<del>不愧是hard，一下给我干趴下了</del>，思路是抄的，没想出来😭</p><p>根据之前的经验，可以分为买和不买两种状态，由于这里只能买卖两次，所以分为四种状态（或者说阶段 ）：</p><ul><li>第一次还没买</li><li>第一次买了在手里</li><li>第二次还没买（第一次已经卖掉了）</li><li>第二次卖掉了</li></ul><p>每个状态都可以如之前一样分别由昨天和今天来得到，取最大值，于是得到如下代码</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<span class="hljs-comment">// 相当于第一天买了卖再买，可不能设成0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>      dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<span class="hljs-comment">//第一次有，昨天就买了；昨天没有，今天才买第一个</span><br>      dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<span class="hljs-comment">//第一次没有，昨天就没有；昨天有，今天才卖掉第一个</span><br>      dp[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<span class="hljs-comment">//第二次有，昨天就有；昨天没有，今天才买第二个</span><br>      dp[i][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);<span class="hljs-comment">//第二次没有，昨天就没有；昨天有，今天才卖掉第二个</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<span class="hljs-comment">//</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day42</title>
    <link href="/2024/07/07/leetcode-day42/"/>
    <url>/2024/07/07/leetcode-day42/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/house-robber/">198.打家劫舍</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/house-robber-ii/description/">213.打家劫舍Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/house-robber-iii/description/">337.打家劫舍Ⅲ</a> <span class="label label-warning">medium</span></li></ul><h1 id="打家劫舍">198. 打家劫舍</h1><p><strong>题目：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><ul><li><p>示例 1：</p></li><li><p>输入：[1,2,3,1]</p></li><li><p>输出：4</p></li><li><p>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。</p></li><li><p>示例 2：</p></li><li><p>输入：[2,7,9,3,1]</p></li><li><p>输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 =9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12。</p></li><li><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 400</li></ul></li></ul><p><strong>思路：</strong></p><p>跟着随想录刷题相当于做题看了tag，所以有思路提示，一开始就知道能够用动态规划来解。</p><p>dp[i]代表打劫[0, i]区间内的房屋的最高金额，状态转换方程如下：</p><p><span class="math display">\[dp[i]\ =\begin{cases}nums[0], &amp; \text{$i\ =\ 0$} \\max(nums[0],\ nums[1]), &amp; \text{$i\ =\ 1$} \\max(dp[i - 2] + nums[i],\ dp[i - 1]), &amp; \text{else}\end{cases}\]</span></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) dp[i] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>      <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>  &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="打家劫舍ⅱ">213. 打家劫舍Ⅱ</h1><p><strong>题目：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈</strong>，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下</strong>，今晚能够偷窃到的最高金额。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>一开始想复杂了：由于循环，所以从某处开始，相当于把上一个给去掉，然后仍然按线性来遍历，于是遍历物品，把每种物品都做一次开头再遍历背包，然后选出最多的一个。这样时间复杂度来到了<spanclass="math inline">\(O(n^2)\)</span></p>          </div><p>实际上这道题和前一道题区别不大，多出的循环机制可以分成两种情况：</p><ul><li>含首不含尾 <imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160821374-20230310134003961.jpg" /></li><li>含尾不含首 <imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160842491-20230310134008133.jpg" /></li></ul><p>所以只需要两种情况都走一遍取最大值就好了。</p><h2 id="代码-1">代码</h2><h3 id="自己过题的复杂代码">自己过题的复杂代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<span class="hljs-comment">//每个nums[i]作起点的初始化</span><br>      dp[i][<span class="hljs-number">0</span>] = nums[i];<br>      dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[i], nums[(i+<span class="hljs-number">1</span>)%nums.<span class="hljs-built_in">size</span>()]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;j &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;j++) &#123;<span class="hljs-comment">//每个i都做一次起点，都打劫一遍，去掉i之前的一个</span><br>        dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">2</span>] + nums[(i + j) % nums.<span class="hljs-built_in">size</span>()], dp[i][j - <span class="hljs-number">1</span>]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>      ans = <span class="hljs-built_in">max</span>(ans, dp[i][nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl的更优代码">carl的更优代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> result1 = <span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>); <span class="hljs-comment">// 情况二</span><br>        <span class="hljs-type">int</span> result2 = <span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 情况三</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result1, result2);<br>    &#125;<br>    <span class="hljs-comment">// 198.打家劫舍的逻辑</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (end == start) <span class="hljs-keyword">return</span> nums[start];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[start] = nums[start];<br>        dp[start + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start + <span class="hljs-number">2</span>; i &lt;= end; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[end];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><ahref="https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 打家劫舍Ⅱ</a></p><h1 id="打家劫舍ⅲ">337. 打家劫舍Ⅲ</h1><p><strong>题目：</strong></p><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为<code>root</code> 。</p><p>除了 <code>root</code>之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong>，房屋将自动报警。</p><p>给定二叉树的 <code>root</code> 。返回<strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额 。</p><p><strong>思路：</strong></p><p><strong>暴力递归：</strong></p><p>跟之前的按监控的题很像，然后思维定势直接后序遍历了，结果美美TLE。又用map来记录已经算过的值防止重复计算，这才AC。</p><p>这个思路和监控题很类似，当前树有两种打劫法：</p><ul><li>打劫儿子，放过根和孙子</li><li>打劫根和孙子，放过儿子</li></ul><p>只要找出最大的就行了。</p><p><strong>树形DP：</strong></p><p>由于是树，还是单向指针，所以不能像之前那样靠dp[i -2]来做到间隔抢劫，得不断上传“抢没抢”的信息，所以每次递归都要返回两个值，抢了当前节点的最大赃款和不抢当前节点的最大赃款。</p><p>递归终止条件自然是遇到null，直接返回0就行，遍历肯定后序遍历，因为处理root得先得到子树的信息，那么单层遍历就是先左再右，最后求出抢root的最大赃款和不抢root的最大赃款，全都返回，再返回最大的一个。</p><h2 id="代码-2">代码</h2><h3 id="暴力递归">暴力递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  unordered_map&lt;TreeNode *, <span class="hljs-type">int</span>&gt; map;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, grandson = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>      <span class="hljs-keyword">return</span> root-&gt;val;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right) &#123;<br>      <span class="hljs-keyword">if</span>(map[root-&gt;right]) right = map[root-&gt;right];<br>      <span class="hljs-keyword">else</span> &#123;<br>        right = <span class="hljs-built_in">rob</span>(root-&gt;right);<br>        map[root-&gt;right] = right;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(!map[root-&gt;right-&gt;left]) &#123;<br>        map[root-&gt;right-&gt;left] = <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;left);<br>      &#125;<br>      grandson += map[root-&gt;right-&gt;left];<br>      <span class="hljs-keyword">if</span>(!map[root-&gt;right-&gt;right]) map[root-&gt;right-&gt;left] = <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;right);<br>      grandson += map[root-&gt;right-&gt;right];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;left)&#123;<br>      <span class="hljs-keyword">if</span>(map[root-&gt;left]) left = map[root-&gt;left];<br>      <span class="hljs-keyword">else</span> &#123;<br>        left = <span class="hljs-built_in">rob</span>(root-&gt;left);<br>        map[root-&gt;left] = left;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(!map[root-&gt;left-&gt;left]) &#123;<br>        map[root-&gt;left-&gt;left] = <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;left);<br>      &#125;<br>      grandson += map[root-&gt;left-&gt;left];<br>      <span class="hljs-keyword">if</span>(!map[root-&gt;left-&gt;right]) map[root-&gt;left-&gt;left] = <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;right);<br>      grandson += map[root-&gt;left-&gt;right];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(root-&gt;val + grandson, left + right);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="树形dp">树形dp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result = <span class="hljs-built_in">robTree</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result[<span class="hljs-number">0</span>], result[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 长度为2的数组，0：不偷，1：偷</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">robTree</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left);<br>        vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right);<br>        <span class="hljs-comment">// 偷cur，那么就不能偷左右节点。</span><br>        <span class="hljs-type">int</span> val1 = cur-&gt;val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况</span><br>        <span class="hljs-type">int</span> val2 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> &#123;val2, val1&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day41</title>
    <link href="/2024/07/06/leetcode-day41/"/>
    <url>/2024/07/06/leetcode-day41/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/coin-change/">322.零钱兑换</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/perfect-squares/description/">279.完全平方数</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/word-break/description/">139.单词拆分</a> <span class="label label-warning">medium</span></li></ul><h1 id="零钱兑换">322. 零钱兑换</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>coins</code>，表示不同面额的硬币；以及一个整数 <code>amount</code>，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong>。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>思路：</strong></p><p>完全背包，dp[j]含义为凑成j需要的最少硬币个数，状态转移方程为：</p><p><span class="math display">\[dp[j]\ =\begin{cases}0, &amp; \text{$j\ =\ 0$} \\min(dp[j\ -\ coin[i]] + 1, dp[j]), &amp; \text{else}\end{cases}\]</span></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; coins.<span class="hljs-built_in">size</span>();i++) &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = coins[i];j &lt;= amount;j++) &#123;<br>        <span class="hljs-keyword">if</span>(dp[j - coins[i]] != INT_MAX) dp[j] = <span class="hljs-built_in">min</span>(dp[j - coins[i]] + <span class="hljs-number">1</span>, dp[j]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount] == INT_MAX ? <span class="hljs-number">-1</span> : dp[amount];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="完全平方数">279. 完全平方数</h1><p><strong>题目：</strong></p><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p><p>完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9和 16 都是完全平方数，而 3 和 11 不是。</p><p><strong>思路：</strong></p><p>其实一开始考虑了数学，但只是记得有相关的数论结论，忘了具体内容，于是果断采用程序员做法————直接dp，很明显的完全背包，只是要求最少数量，把dp含义改一下就好，同时也要根据新的状态转移方程决定新的初始化方式。</p><p>dp[j]表示整数j需要的完全平方数的最少数量</p><p>状态转移方程为：</p><p><span class="math display">\[dp[j]\ =\begin{cases}0, &amp; \text{$j\ =\ 0$} \\min(dp[j], dp[j - i*i] + 1), &amp; \text{$j\ ≥\ i^2, i\ =\ 1,2,3,……$} \\\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-built_in">sqrt</span>(n);i &gt; <span class="hljs-number">0</span>;i--) &#123;<span class="hljs-comment">//稍微剪了剪枝，无伤大雅</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i*i; j &lt;= n;j++) &#123;<br>        <span class="hljs-keyword">if</span>(dp[j - i*i] != INT_MAX) dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - i*i] + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="单词拆分">139. 单词拆分</h1><p><strong>题目：</strong></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code>作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code>则返回 <code>true</code>。</p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>思路：</strong></p><p>把s看成要填满的背包，从dict里一个一个试着装，这时候就不能太死板，要灵活迁移dp的含义：</p><p>dp[j]表示区间[0, j)的s能不能被表示</p><p>那么状态转移方程为：</p><p><span class="math display">\[dp[j] =\begin{cases}true, &amp; \text{$j = 0$} \\dp[j]\ OR\ (dp[j - wordDict[i].size()]\ AND\ s(j\ -\wordDict[i].size())\ ==\ wordDict[i]), &amp; \text{else}\end{cases}\]</span></p><ul><li>还要想到：这里必须先遍历背包容量再遍历字典，不然无法实现拼接，而是一直在判断s的开头。</li><li>还可以对字典去去重</li></ul><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= s.<span class="hljs-built_in">size</span>();j++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; wordDict.<span class="hljs-built_in">size</span>();i++) &#123;<br>          <span class="hljs-keyword">if</span>(j &gt;= wordDict[i].<span class="hljs-built_in">size</span>()) dp[j] = dp[j] || (dp[j - wordDict[i].<span class="hljs-built_in">size</span>()] &amp;&amp; <span class="hljs-built_in">strcmp</span>(s, j - wordDict[i].<span class="hljs-built_in">size</span>(), j, wordDict[i]));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()];<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end, string word)</span> </span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; end;i++) &#123;<br>      <span class="hljs-keyword">if</span>(s[i] != word[j++]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day40</title>
    <link href="/2024/07/05/leetcode-day40/"/>
    <url>/2024/07/05/leetcode-day40/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://www.acwing.com/problem/content/3/">完全背包</a></li><li><a href="https://leetcode.cn/problems/coin-change-ii/">518.零钱兑换Ⅱ</a> <span class="label label-warning">medium</span></li><li><a href="">377. 组合总和Ⅳ</a> <span class="label label-warning">medium</span></li></ul><h1 id="完全背包">完全背包</h1><p><strong>题目：</strong></p><p>有<span class="math inline">\(N\)</span>种物品和一个容量是<spanclass="math inline">\(V\)</span>的背包，每种物品都有无限件可用。</p><p>第<span class="math inline">\(i\)</span>种物品的体积是<spanclass="math inline">\(v_i\)</span>，价值是<spanclass="math inline">\(w_i\)</span>。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><p><strong>输入格式：</strong></p><p>第一行两个整数，<span class="math inline">\(N\)</span>，<spanclass="math inline">\(V\)</span>，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有<span class="math inline">\(N\)</span>行，每行两个整数<spanclass="math inline">\(v_i\)</span>,<spanclass="math inline">\(w_i\)</span>，用空格隔开，分别表示第<spanclass="math inline">\(i\)</span>种物品的体积和价值。</p><p><strong>输出格式:</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p><span class="math inline">\(0&lt;N,V≤1000\)</span></p><p><span class="math inline">\(0&lt;v_i,w_i≤1000\)</span></p><p><strong>思路：</strong></p><p>相对于01背包，物品数量不受限制，可以多次放入，那么就要改动容量倒序遍历，容量倒序遍历原本目的是为了防止多次放入，但现在可以多次放入，不能防止，所以改为顺序遍历，其他不变。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(N)</span>, <span class="hljs-title">w</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i] ;<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i];j &lt;= V;j++) &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[V] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="零钱兑换ⅱ">518. 零钱兑换Ⅱ</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数<code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回<code>0</code> 。</p><p>假设每一种面额的硬币有无限个。</p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>思路：</strong></p><p>硬币无限+凑总金额，很容易看出使用完全背包。题目所求硬币组合数，和昨天的<ahref="https://leetcode.cn/problems/target-sum/">目标和</a>很像，核心代码都是<code>dp[j] += dp[j - nums[i]]</code>，照着样子套就行。</p><p>carl强调：要注意遍历的顺序，首先完全背包遍历背包容量时要顺序遍历以实现多次拿取，其次要先遍历物品再遍历背包容量，不然就会求成排列数而非组合数：</p><ul><li>先物品后容量 ==&gt; 组合数</li><li>先容量后物品 ==&gt; 排列数</li></ul><p>可自推dp数组画图</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-type">int</span> N = coins.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = coins[i];j &lt;= amount;j++) &#123;<br>                dp[j] += dp[j - coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="组合总和ⅳ">377. 组合总和Ⅳ</h1><p><strong>题目：</strong></p><p>给你一个由<strong>不同</strong> 整数组成的数组 <code>nums</code>，和一个目标整数 <code>target</code> 。请你从 <code>nums</code>中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。 <div class="note note-light">            <p><strong>示例 1：</strong></p><p><strong>输入：</strong>nums = [1,2,3], target = 4</p><p><strong>输出：</strong>7</p><p><strong>解释：</strong></p><p>所有可能的组合为：</p><p>(1, 1, 1, 1)</p><p>(1, 1, 2)</p><p>(1, 2, 1)</p><p>(1, 3)</p><p>(2, 1, 1)</p><p>(2, 2)</p><p>(3, 1)</p><p>请注意，顺序不同的序列被视作不同的组合。</p>          </div></p><p><strong>思路：</strong></p><p>有上一道题的经验，安排这题作为下一题非常合适，直接当场体会遍历顺序对结果的影响。</p><p>这道题所求组合个数，但却又在示例中说明顺序不同的序列视作不同组合，与通用概念存在矛盾。不过总之是求通用概念的排列数，先遍历容量再遍历物品即可。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= target;j++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; j) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> dp[j] += dp[j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day38</title>
    <link href="/2024/07/05/leetcode-day38/"/>
    <url>/2024/07/05/leetcode-day38/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/last-stone-weight-ii/description/">1049.最后一块石头的重量Ⅱ</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/ones-and-zeroes/description/">474.一和零</a> <span class="label label-warning">medium</span></li></ul><h1 id="最后一块石头的重量">1049. 最后一块石头的重量</h1><p><strong>题目：</strong></p><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中<code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为<code>x</code> 和 <code>y</code>，且<code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code>的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为<code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头<strong>最小的可能重量</strong> 。如果没有石头剩下，就返回<code>0</code>。</p><p><strong>思路：</strong></p><p><del>一次周赛的Q4，很有档次啊</del></p><p>今天的三道题都是这种类型的题目，01背包的情景应用，我把这种类型概括为“分堆儿”。</p><p>这道题有点难走到“分堆儿”的思路上，卡住我的是这个思想：</p><div class="note note-light">            <p>石块两两粉碎，把所有石头分成两堆，每次分别拿出一块来对碰粉碎，实际上<strong>一次粉碎过程，两堆都损失了相同的重量</strong>。</p>          </div><p>理解到这一点，就能想到将石块分成<strong>尽可能相近的两堆</strong>，其差值就是<strong>最小可能重量</strong>。那问题就变成了昨天的分割等和了，一下就能套上01背包问题</p><ul><li>包容量就是总和sum的一半(两堆尽量相近)</li><li>物品数量就是石头数量，物品价值和体积都是石头重量</li><li>把包装满就是最大重量为sum/2限制下能得到的最重子堆<code>dp[sum/2]</code></li><li>另一堆就是<code>sum - dp[sum/2]</code>，两堆相减即可，可以相减的原因就是上面所说，也可以详见<ahref="https://leetcode.cn/problems/last-stone-weight-ii/solutions/817930/zui-hou-yi-kuai-shi-tou-de-zhong-liang-i-95p9/">力扣官解的前言证明</a></li></ul><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : stones) sum += i;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; stones.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = dp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;j &gt;= stones[i];j--) &#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);<span class="hljs-comment">//套路</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - dp[sum/<span class="hljs-number">2</span>] - dp[sum/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="目标和">494. 目标和</h1><p><strong>题目：</strong></p><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code>。</p><p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code>，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加<code>'+'</code> ，在 <code>1</code> 之前添加<code>'-'</code>，然后串联起来得到表达式 <code>"+2-1"</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同<strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [1,1,1,1,1], target = 3</p><p>输出：5</p><p>解释：一共有 5 种方法让最终目标和为 3 。</p><ul><li>-1 + 1 + 1 + 1 + 1 = 3</li><li>+1 - 1 + 1 + 1 + 1 = 3</li><li>+1 + 1 - 1 + 1 + 1 = 3</li><li>+1 + 1 + 1 - 1 + 1 = 3</li><li>+1 + 1 + 1 + 1 - 1 = 3</li></ul></blockquote><p><strong>思路：</strong></p><p>这题就已经明示要“分堆儿”了，将nums分为正数部分和负数部分，使正数加负数等于target。</p><p>由于01背包求的是<strong>最大价值</strong>，和这里的<strong>最多种类数</strong>不一样，所以不能直接套，得改dp的含义。</p><p>dp[j] 代表总和为j的包有dp[j]种装法</p><p>那么状态转移方程为：</p><p><span class="math display">\[dp[j] =\begin{cases}1, &amp; \text{$j = 0$} \\dp[j], &amp; \text{$j &lt; nums[i]$} \\dp[j] + dp[j - nums[i]], &amp; \text{$else$}\end{cases}\]</span></p><p>dp[0] = 1的原因： 由于会涉及到<code>dp[j - nums[i]]</code>，如果j正好等于nums[i]，那么只能直接装入，只有一种方法。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) sum += i;<br>        <span class="hljs-type">int</span> V = sum + target;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(V % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        V /= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(V &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> N = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">// </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = dp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;j &gt;= nums[i];j--) &#123;<br>                dp[j] += dp[j - nums[i]];<br>            &#125;   <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[V];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="一和零">474. 一和零</h1><p><strong>题目：</strong></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p><strong>思路：</strong></p><p>让选个子集出来，情景已经很贴近01背包模板了，只是背包体积同时有两个维度的限制：0的个数和 1的个数</p><p>那判断两次能不能装下不就好了，多加一个循环。</p><p>这里的物品价值就是串的个数，因为最后看的是长度，所以在状态转移那里是加一。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> N = strs.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">//dp[i][j]表示容量为m个0和n个1的包最多装多少个</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>      <span class="hljs-type">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : strs[i]) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;0&#x27;</span>) zeroNum++;<br>        <span class="hljs-keyword">else</span> oneNum++;<br>      &#125;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j &gt;= zeroNum;j--) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = n;k &gt;= oneNum;k--) &#123;<br>          dp[j][k] = <span class="hljs-built_in">max</span>(dp[j][k], dp[j - zeroNum][k - oneNum] + <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day37</title>
    <link href="/2024/07/04/leetcode-day37/"/>
    <url>/2024/07/04/leetcode-day37/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">01背包问题二维</a></li><li><ahref="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">01背包问题一维</a></li><li><ahref="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416.分割等和子集</a> <span class="label label-warning">medium</span></li></ul><h1 id="背包问题">01背包问题</h1><p><strong>题目：</strong></p><p>有<span class="math inline">\(N\)</span>件物品和一个容量是<spanclass="math inline">\(V\)</span>的背包。每件物品只能使用一次。</p><p>第<span class="math inline">\(i\)</span>件物品的体积是<spanclass="math inline">\(v_i\)</span>，价值是<spanclass="math inline">\(w_i\)</span>。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，<span class="math inline">\(N\)</span>，<spanclass="math inline">\(V\)</span>，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有<span class="math inline">\(N\)</span>行，每行两个整数 <spanclass="math inline">\(v_i\)</span>,<spanclass="math inline">\(w_i\)</span>，用空格隔开，分别表示第<spanclass="math inline">\(i\)</span>件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p><span class="math inline">\(0&lt;N,V≤1000\)</span></p><p><span class="math inline">\(0&lt;vi,wi≤1000\)</span></p><p><strong>思路：</strong></p><p><strong>二维基础版：</strong></p><p>dp[i][j]表示从0-i号物品选，背包容量为j，能装的最大价值。</p><p>对于第i件物品</p><ul><li>若容量不够（<spanclass="math inline">\(j&lt;w[i]\)</span>），则dp[i][j] = dp[i -1][j]，继承价值</li><li>若容量足够：<ul><li>放入后价值为dp[i - 1][j - v[i]] + w[i]</li><li>不放入价值为dp[i - 1][j]，取其中最大值。</li></ul></li></ul><p>可得状态转移方程为：</p><p><span class="math display">\[dp[i][j] =\begin{cases}0, &amp; \text {$j=0$} \\w[i], &amp; \text{$i=0$} \\max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]), &amp; \text{$else$}\end{cases}\]</span></p><p><strong>一维优化版：</strong></p><p>由于只需要最终状态，利用滚动数组优化空间</p><p>dp[j]表示背包容量为j时能装的最大价值</p><div class="note note-warning">            <p>对于j的遍历，即枚举背包容量时需要逆序。</p><p>当进入下一层容量枚举时，新增了物品i，而此时的dp还是对于物品i-1的状态，如果顺序枚举，则枚举到中间就会用到之前的状态，但此时之前的状态已经包含了物品i，会造成重复装入，相当于把dp[i- 1][j - v[i]]用成了dp[i][j - v[i]]。</p>          </div><h2 id="代码">代码</h2><h3 id="二维版">二维版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(V + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[<span class="hljs-number">0</span>];j &lt; V;j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = w[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= V;j++) &#123;<br>            <span class="hljs-keyword">if</span>(j &lt; v[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[N<span class="hljs-number">-1</span>][V] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一维版">一维版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V + <span class="hljs-number">1</span>)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = V;j &gt;= v[i];j--) &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[V] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化输入版">优化输入版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> f[MAXN];  <span class="hljs-comment">// </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;   <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> v, w;<br>        cin &gt;&gt; v &gt;&gt; w;      <span class="hljs-comment">// 边输入边处理</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v; j--)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);<br>    &#125;<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>来源：<a href="https://www.acwing.com/solution/content/1374/">AcWing2. 01背包问题（状态转移方程讲解）</a></p><h1 id="分割等和子集">416. 分割等和子集</h1><p><strong>题目：</strong></p><p>给你一个<strong>只包含正整数</strong>的<strong>非空</strong>数组<code>nums</code>。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>思路：</strong></p><p>提前告诉了要用01背包，不然还看不出来是01背包。</p><p>套用的关键在于搞清楚在当前场景下，物品价值w[i]、物品体积v[i]、背包容量V、物品数量N分别代表什么。</p><p>容易想到要从nums中找到一组数使其和为总和的一半，所以考虑总和的一半作为背包容量，nums中的数的值作为物品的体积</p><p>关于为什么物品的价值也是nums中数的值没想明白，下面是目前的解释，对于价值的解释好像偷换概念了：</p><blockquote><p>由于最后要知道背包到底装满没，所以至少得算到dp[sum/2]，也就是容量为sum/2的包里最多能装多少“价值”，，此时并不知道这个“价值”是不是sum/2,也可能比sum/2小，比如1、5、5、11当容量为6时dp[6]=dp[5]=5，所以得判断dp[j]是不是sum/2，所以dp里的值得是数值。</p></blockquote><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) sum += i;<br><br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        sum /= <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">40001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = sum;j &gt;= nums[i];j--) &#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[sum] == sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day36</title>
    <link href="/2024/07/03/leetcode-day36/"/>
    <url>/2024/07/03/leetcode-day36/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/unique-paths/description/">62.不同路径</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/unique-paths-ii/">63.不同路径Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/integer-break/description/">343.整数拆分</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/unique-binary-search-trees/description/">96.不同的二叉搜索树</a> <span class="label label-warning">medium</span></li></ul><h1 id="不同路径">62. 不同路径</h1><p><strong>题目：</strong></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start”）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>思路：</strong></p><p>由于方向定死只能朝着目标走，不允许走回头路，所以走到一个格子只可能从其左边或上面来到，那么这就不难直接想出递推公式：</p><p><span class="math display">\[dp[i][j] =\begin{cases}1, &amp; \text {$i = 1 or j = 1$} \\dp[i - 1][j] + dp[i][j - 1], &amp; \text {else}\end{cases}\]</span> dp[i][j]表示从起点走到第[i, j]格的所有路径数</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="不同路径ⅱ">63. 不同路径Ⅱ</h1><p><strong>题目：</strong></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start”）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>其实思路差不多，由于笔者追求尽可能少的改动，只加了一行代码就想过关，结果被特殊用例坑了两发WA😭，怎么障碍物会出现在起点和终点啊，落地成盒+通天河老鼋是吧🤡</p>          </div><p>仍然动态规划，只是状态转移方程要改一下，应该遍历整个地图，如果发现障碍物，就把这一格的dp置零表示此路不通，由于笔者代码有点问题，所以还另有改动，在地图边缘的格子不能无脑置1，得继承上一格数值，防止跳过了障碍物。</p><p>carl的代码也有类似思想</p><h2 id="代码-1">代码</h2><h3 id="个人代码">个人代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>(), n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> || obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">1</span>) dp[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) dp[i][j] = i == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="官解代码">官解代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = obstacleGrid.<span class="hljs-built_in">size</span>(), m = obstacleGrid.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>).<span class="hljs-built_in">size</span>();<br>        vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">f</span>(m);<span class="hljs-comment">//压缩了dp数组</span><br><br>        f[<span class="hljs-number">0</span>] = (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>);<span class="hljs-comment">//起点能不能走</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//遇障置零</span><br>                    f[j] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//非首列</span><br>                    f[j] += f[j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>利用滚动数组压缩空间，滚动数组就是上一篇只用3个变量来压缩整个dp数组的思想，抛弃掉之前不用的状态，只获取最终状态，这里也一样，从上到下的路径是继承的，而从左到右的路径是累加的。而外层大循环就是改变行，每行都会继承上一行的结果。</p><h1 id="整数拆分">343. 整数拆分</h1><p><strong>题目：</strong></p><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2），并使这些整数的乘积最大化。</p><p>返回 你可以获得的最大乘积 。</p><p><strong>思路：</strong></p><p>本来该用dp的，但是数学直觉给我指了另一条路，高中学过基本不等式，有口诀为“和定积最大，积定和最小”，而此处就是“和定”，由基本不等式最值条件可知，每个数应该尽量相等（尽量是因为得是整数，不然必须相等），而拆分的数量简单一推就知道先增后减：</p><p>比如12：</p><ul><li>分为2个数：<span class="math inline">\(6*6=36\)</span></li><li>分为3个数：<span class="math inline">\(4 * 4 * 4 = 64\)</span></li><li>分为4个数：<span class="math inline">\(3^4=81\)</span></li><li>分为5个数：<span class="math inline">\(2 * 2 * 2 * 3 * 3 =72\)</span></li><li>分为6个数：<span class="math inline">\(2^6=64\)</span></li></ul><p>先增后减，所以从2开始一直增加拆分数，一旦积开始减少，就说明到达最值点了。</p><p><del>官解的数学证明好复杂，看起来很抽象啊，导数大题只得了6分的我看不懂，还是不等式选修秒杀更舒服</del></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//和定积最大，基本不等式定调均分</span><br>    <span class="hljs-comment">//随便举几个例子可大致知道k先增后减，存在峰值</span><br>    <span class="hljs-comment">//但均分不好实现，如10分为2233或2224，均分应该使方差最小</span><br>    <span class="hljs-comment">//逐步除法也许可以实现最均分，尝试一下</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>;k &lt;= n;k++) &#123;<span class="hljs-comment">//等分数量</span><br>            <span class="hljs-type">int</span> m = n, temp = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k;i &gt; <span class="hljs-number">0</span>;i--) &#123;<span class="hljs-comment">//已经获得的加子数量</span><br>                temp *= m / i;<br>                m -= m / i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(temp &gt; ans) ans = temp;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>均分方法蒙对了，没严格证明，至少能AC</p><h1 id="不同的二叉搜索树">96. 不同的二叉搜索树</h1><p><strong>题目：</strong></p><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>思路：</strong></p><p>有点多项式定理的感觉，<del>沉睡的高中数学之魂复燃？</del>，画图可能比较好理解，但是图书馆要闭馆了，没时间画图了。</p><p>根据其示例可以得到提示：以不同的数做根来分类讨论，以4为例</p><ul><li>若1作根，则剩余3个数形成的BST个数就是当前BST的个数总数，由示例得到为5</li><li>若2作根，则剩余2个数3、4只能在右子树，当前BST总数就是2节点BST的总数2</li><li>若3作根，则4只能在右子树，左子树是2节点BST总数2</li><li>若4作根，则1、2、3都在左子树，就是3节点BST总数，5</li></ul><p>所以4节点BST总数为5+2+2+5。</p><p>由此发散，联想多项式定理，可得状态转移方程：</p><p><span class="math display">\[dp[i] =\begin{cases}1, &amp; \text {$i = 0 or i = 1$} \\\sum_{root=1}^i (dp[root-1]*dp[i-root]), &amp; \text {$i &gt; 1$}\end{cases}\]</span></p><p>dp[i] 代表有i个节点的BST种数;</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++) &#123;<span class="hljs-comment">//节点数</span><br>            <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;root &lt;= i;root++) &#123;<span class="hljs-comment">//谁做根</span><br>                temp += dp[root - <span class="hljs-number">1</span>] * dp[i - root];<br>            &#125;<br>            dp[i] = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day35</title>
    <link href="/2024/07/03/leetcode-day35/"/>
    <url>/2024/07/03/leetcode-day35/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/fibonacci-number/">509.斐波那契数</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/climbing-stairs/description/">70.爬楼梯</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">746.使用最小花费爬楼梯</a> <span class="label label-success">easy</span></li></ul><h1 id="斐波那契数">509. 斐波那契数</h1><p><strong>题目：</strong></p><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code>表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由<code>0</code> 和 <code>1</code>开始，后面的每一项数字都是前面两项数字的和。也就是：</p><blockquote><p>F(0) = 0，F(1) = 1</p><p>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p></blockquote><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>思路：</strong></p><p>由于是dp训练，所以不能直接递归或套公式。</p><p>递推公式题目有，直接dp，没有优化空间复杂度。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="爬楼梯">70. 爬楼梯</h1><p><strong>题目：</strong></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>思路：</strong></p><ol type="1"><li>只有45个数，打表🤓</li><li>直接dp！</li><li>套斐波那契公式🤓</li></ol><p>dp递归公式如下：</p><p><span class="math display">\[dp[n]=\begin{cases}1, &amp; \text {$n=1$} \\2, &amp; \text {$n=2$} \\dp[n-1]+dp[n-2], &amp; \text {$n&gt;3$}\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="使用最小花费爬楼梯">746. 使用最小花费爬楼梯</h1><p><strong>题目：</strong></p><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>思路：</strong></p><p>直接dp！递推公式如下：</p><p><span class="math display">\[dp[n]=\begin{cases}0, &amp; \text {$n = 1 or 0$} \\min(dp[n-1]+cost[n-1], dp[n-2]+cost[n-2]), &amp; \text {$n&gt;1$}\end{cases}\]</span></p><p>没有优化空间复杂度，感觉可有可无，优化也不复杂，具体优化方法见<ahref="https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html">代码随想录| 使用最小花费爬楼梯</a></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(cost.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(cost[<span class="hljs-number">0</span>], cost[<span class="hljs-number">1</span>]);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size() + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= cost.<span class="hljs-built_in">size</span>();i++) &#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[cost.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day34</title>
    <link href="/2024/07/01/leetcode-day34/"/>
    <url>/2024/07/01/leetcode-day34/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/merge-intervals/description/">56.合并区间</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/monotone-increasing-digits/">738.单调递增的数字</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/binary-tree-cameras">968.监控二叉树</a> <span class="label label-danger">hard</span></li></ul><h1 id="合并区间">56. 合并区间</h1><p><strong>题目：</strong></p><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] =[starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p><strong>思路：</strong></p><p>与昨天的重叠区间类型问题一样，按开始点排序，有重合就合并，没重合就新维护</p><div class="note note-light">            <p>忽然诧异怎么这道题显示已解决，查看提交记录发现这道题在几个月前做过，当初WA4发才做出来结果击败5%，真是感慨</p><p>回首向来萧瑟处，也无风雨也无晴，虽然一直感觉在蹉跎人生，但实际上我还是有一点小小的进步，加油共勉！</p>          </div><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; b )</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> left = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], right = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; intervals.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt; right) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;left, right&#125;);<br>                left = intervals[i][<span class="hljs-number">0</span>];<br>                right = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>            right = <span class="hljs-built_in">max</span>(right, intervals[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;left, right&#125;);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="单调递增的数字">738. 单调递增的数字</h1><p><strong>题目：</strong></p><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y时，我们称这个整数是单调递增的。</p><p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>没做出来，做的时候脑子有点不舒服，所以歇逼了</p>          </div><p>此题局部最优策略为，如果数字本身就满足“单调递增”要求，则直接返回该数字即可，若出现反例，即高位大于低位，则将高位减1低位置9</p><p>将此局部最优策略应用至全局即可得到最优解，具体代码实现方式见注释。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>&#123;<br>        string strNum = <span class="hljs-built_in">to_string</span>(N);<br>        <span class="hljs-type">int</span> flag = strNum.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// flag用来标记赋值9从哪里开始</span><br>        <span class="hljs-comment">// 设置为超限默认值，为了防止第二个for循环在flag没有被赋值的情况下执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = strNum.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-comment">//倒序遍历数位，若连续出现高位大于低位，则连续减一高位并记录计划变为9的位数</span><br>            <span class="hljs-keyword">if</span> (strNum[i - <span class="hljs-number">1</span>] &gt; strNum[i] ) &#123;<span class="hljs-comment">//如果出现高位大于低位，则将高位减1，同时记录低位位数为flag</span><br>                flag = i;<br>                strNum[i - <span class="hljs-number">1</span>]--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = flag; i &lt; strNum.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-comment">//由于从后往前，所以最后得到的计划变9位将是最高的，把后面所有数变9只会增大数字从而得到最优解</span><br>            strNum[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span>(strNum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="监控二叉树">968. 监控二叉树</h1><p><strong>题目：</strong></p><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象</strong>。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>思路：</strong></p><p><del>不会做😭，抄了</del></p><p>由于涉及二叉树，可以套路化地想到尝试递归遍历，题目所求最少摄像头数量，最少一般是贪心或者dp，那就得分析状态，考虑局部最优全局最优或者状态之间的转移。</p><p>在这道题中，一个节点的状态有三种：放了摄像头+被覆盖+没覆盖，关于二叉树的状态容易联想到从两个子树的状态得到当前root树的状态，那么又可以想到：如果子树的根left或者right有摄像头+仅仅被覆盖+没被覆盖这三种状态，这三种状态转移到整个树的状态的方式就为：1. 如果left或right有一个没被覆盖，则root需要放置摄像头； 2.如果left或者right有一个有摄像头，则root不需要放置； 3.如果left和right都只是被覆盖，那么root需要补一个摄像头。</p><p>但这并没有取最优化，仅仅只是状态转移，所以不是dp。</p><p>dp做法官方题解和灵神的不太一样，树形dp没看懂，dp做法以后再看吧。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//0:无覆盖，1：有摄像头，2：有覆盖</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) &#123;<br>            result++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) result++;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day33</title>
    <link href="/2024/07/01/leetcode-day33/"/>
    <url>/2024/07/01/leetcode-day33/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452.用最少数量的箭引爆气球</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/non-overlapping-intervals/description/">435.无重叠区间</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/partition-labels/description/">763.划分字母区间</a> <span class="label label-warning">medium</span></li></ul><h1 id="用最少数量的箭引爆气球">452. 用最少数量的箭引爆气球</h1><p><strong>题目：</strong></p><p>有一些球形气球贴在一堵用 XY平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中 $points[i] =[x_{start}, x_{end}] $ 表示水平直径在 <spanclass="math inline">\(x_{start}\)</span> 和<spanclass="math inline">\(x_{end}\)</span>之间的气球。你不知道气球的确切 y坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x处射出一支箭，若有一个气球的直径的开始和结束坐标为<spanclass="math inline">\(x_{start}\)</span>，<spanclass="math inline">\(x_{end}\)</span>， 且满足 <spanclass="math inline">\(x_{start} ≤ x ≤ x_{end}\)</span>，则该气球会被引爆 。可以射出的弓箭的数量 没有限制 。弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p><p><strong>思路：</strong></p><p>按照直观思维，肯定要找重叠部分，再按贪心分析，局部最优是射重叠部分，全局最优是尽可能多射重叠部分来减少箭数</p><p>此时不妨画个图来分析，脑子好也可以直接想象，用线段表示气球直径范围，以下图为例，很容易看出答案是两根箭，但是我们是如何得出答案的呢，背后的依赖逻辑是什么</p><figure><img src="https://s3.bmp.ovh/imgs/2024/07/01/7513d5db99cbc545.png"alt="帮助分析线段图" /><figcaption aria-hidden="true">帮助分析线段图</figcaption></figure><p>此时发散思维，不难想到跟开始和结束点有关，此前做过类似题则更容易想到，以结束点为标准，从左往右开始射，必须照顾到最早结束的气球，否则就会漏掉，那么我们就能得到如下贪心策略：（大白话版）</p><p>按起点排序，记录气球结束点按最近的来，若结束点超过了这个最近结束点，则一支箭就不够了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//按起点排序，记录气球结束点按最近的来，若结束点超过了这个最近结束点，则一支箭就不够了</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> end = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> nextBallon = <span class="hljs-number">0</span>;<span class="hljs-comment">//新的起点</span><br>        <span class="hljs-type">int</span> arrow = <span class="hljs-number">1</span>;<span class="hljs-comment">//箭数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; points.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(end &lt; points[i][<span class="hljs-number">0</span>]) &#123;<br>                nextBallon = i;<br>                arrow++;<br>                end = points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>            end = <span class="hljs-built_in">min</span>(end, points[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arrow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="无重叠区间">435. 无重叠区间</h1><p><strong>题目：</strong></p><p>给定一个区间的集合 intervals ，其中 intervals[i] = [start_i, end_i]。返回需要移除区间的最小数量，使剩余区间互不重叠 。</p><p><strong>思路：</strong></p><p>由于之前做过一道安排活动的题目，大概意思就是有很多活动(区间)，请在不重叠的前提下安排尽可能多的活动。与此题很像</p><p>安排活动题就是按结束时间从早到晚排序，先安排早的，这样就有局部最优：留出更多的时间给之后的活动，如果结束时间相同，则为了多，选择更短的活动，以留出更多时间给更早的活动</p><p>那么这道题也可以迁移这个策略，移除最少就是保留最多嘛。</p><p>这道题比较经典，carl给了很多思路，建议阅读：<ahref="https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 无重叠区间</a></p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] == b[<span class="hljs-number">1</span>] ? a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>] : a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">//移除最少那就保留最多，移除长的，保留短的</span><br>    <span class="hljs-comment">//保留最多就要流出足够多的时间给后面的区间，所以结束时间要早</span><br>    <span class="hljs-comment">//那么应该按结束时间排序，如果结束相同，那么选择开始时间最晚的</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> save = <span class="hljs-number">1</span>;<span class="hljs-comment">//保留的活动数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; intervals.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &lt; end) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                save++;<br>                end = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - save;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="划分字母区间">763. 划分字母区间</h1><p><strong>题目：</strong></p><p>给你一个字符串 s。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是s 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><p><strong>思路：</strong></p><p>一开始有点懵，然后迁移之前的思路想到可以将字母出现的范围视作区间，那就又成了区间不重叠问题。</p><p>但这个思路编码有点复杂，速度也不快</p><p>carl的直截了当思路简直优雅👍:</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20201222191924417.png"alt="太巧妙辣！" /><figcaption aria-hidden="true">太巧妙辣！</figcaption></figure><h2 id="代码-2">代码</h2><h3 id="个人14代码">个人14%代码😭</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//尽可能多的片段，且是分割，是连续的，只在前面出现的字母，统计各字母首次和默次出现构成区间</span><br>    <span class="hljs-comment">//按区间开始排序，目的是分出尽可能多的组，原理相同</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; points;<span class="hljs-comment">//存各字母的区间</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-comment">//获取s中各字母的区间</span><br>        points = <span class="hljs-built_in">getSection</span>(s);<br>        <span class="hljs-comment">//写代码能力太弱，有点费时间啊……</span><br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> right = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; points.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; right) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>                left = points[i][<span class="hljs-number">0</span>];<br>            &#125;<br>            right = <span class="hljs-built_in">max</span>(right, points[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">getSection</span>(string s) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">alpha</span>(<span class="hljs-number">26</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>));<span class="hljs-comment">//全部字母都留出空</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(alpha[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">-1</span>) alpha[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>] = i;<span class="hljs-comment">//起点只记一次</span><br>            alpha[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>] = i;<span class="hljs-comment">//终点不断更新</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; alpha.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(alpha[i][<span class="hljs-number">0</span>] != <span class="hljs-number">-1</span>) res.<span class="hljs-built_in">push_back</span>(alpha[i]);<span class="hljs-comment">//结果只记录出现过的</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl优雅代码">carl优雅代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        <span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// i为字符，hash[i]为字符出现的最后位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 统计每一个字符最后出现的位置</span><br>            hash[S[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            right = <span class="hljs-built_in">max</span>(right, hash[S[i] - <span class="hljs-string">&#x27;a&#x27;</span>]); <span class="hljs-comment">// 找到字符出现的最远边界</span><br>            <span class="hljs-keyword">if</span> (i == right) &#123;<br>                result.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day31</title>
    <link href="/2024/06/30/leetcode-day31/"/>
    <url>/2024/06/30/leetcode-day31/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><a href="https://leetcode.cn/problems/gas-station/description/">134.加油站</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/candy/description/">135.分发糖果</a> <span class="label label-danger">hard</span></li><li><ahref="https://leetcode.cn/problems/lemonade-change/description/">860.柠檬水找零</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406.根据身高重建队列</a> <span class="label label-warning">medium</span></li></ul><h1 id="加油站">134. 加油站</h1><p><strong>题目：</strong></p><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1个加油站需要消耗汽油 cost[i]升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 gas 和 cost，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。如果存在解，则 保证 它是 唯一 的。</p><p><strong>思路：</strong></p><p>贪心算法是从局部最优一直推到整体最优，那么对于解从起点开始的每一小段，肯定油都是有剩的，即<spanclass="math inline">\(∑gas[i] - ∑cost[i] &gt;0\)</span>，如果有一段内的油少于需要，则肯定不是解从开头的段</p><p>开一个数组<span class="math inline">\(loss[]\)</span>表示<spanclass="math inline">\(loss[i] = gas[i] -cost[i]\)</span>，肯定从正数开始，如果加到中间变负了，证明从开始到这里都不行，换下一站做起点，不断搜索即可。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">loss</span><span class="hljs-params">((<span class="hljs-type">int</span>)gas.size())</span></span>;<br>        <span class="hljs-type">int</span> sumg = <span class="hljs-number">0</span>, sumc = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; gas.<span class="hljs-built_in">size</span>();i++) &#123;<br>            loss[i] = gas[i] - cost[i];<br>            sumg += gas[i];<br>            sumc += cost[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sumg &lt; sumc) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//油不够，直接-1</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; loss.<span class="hljs-built_in">size</span>()) &#123;<br>            sum += loss[i++];<br>            <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>) &#123;<br>                sum = <span class="hljs-number">0</span>;<br>                ans = i;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i == ans) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//回到起点</span><br>            <span class="hljs-keyword">if</span>(ans &gt; <span class="hljs-number">0</span> &amp;&amp; i == loss.<span class="hljs-built_in">size</span>()) i = <span class="hljs-number">0</span>;<span class="hljs-comment">//循环，注意起点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="分发糖果">135. 分发糖果</h1><p><strong>题目：</strong></p><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><p><strong>思路：</strong></p><p>个人击败5%思路：</p><ul><li>如果相比上一个更大，则糖果比上一个人多一个，这没得说</li><li>如果相比上一个相同，则先置为1，后续再操作</li><li>如果更小，此时需要往前维护糖果大小关系，细节见代码</li></ul><p>carl思路：</p><p>两次遍历，分别维护两种相邻情况的糖果大小关系，顺序维护递增的加一关系，倒序维护递减的关系，巧妙啊</p><h2 id="代码-1">代码</h2><h3 id="个人5代码">个人5%代码😭</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//需要注意的就是1234321这种例子，不能想当然按照两格滑动窗口解题，也不能左右同时走</span><br>    <span class="hljs-comment">//往前，如果比前一个小，则置位1，同时维护之前的大小关系，直到遇到下降</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candys</span><span class="hljs-params">(ratings.size())</span></span>;<br>        candys[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; ratings.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candys[i] = candys[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ratings[i] == ratings[i - <span class="hljs-number">1</span>]) candys[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ratings[i] &lt; ratings[i - <span class="hljs-number">1</span>]) &#123;<br>                candys[i] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(candys[i - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)  &#123;<span class="hljs-comment">//维护先前的大小关系，必须倒着加回去</span><br>                <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>) &#123;<br>                    candys[j]++;<br>                    <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; candys[j] &lt; candys[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; ratings[j] &gt;= ratings[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span>;<br>                    j--;<br>                &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; candys.<span class="hljs-built_in">size</span>();i++) sum += candys[i];<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl代码">carl代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candyVec</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 从前向后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candyVec[i] = candyVec[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从后向前</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] ) &#123;<br>                candyVec[i] = <span class="hljs-built_in">max</span>(candyVec[i], candyVec[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 统计结果</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candyVec.<span class="hljs-built_in">size</span>(); i++) result += candyVec[i];<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="柠檬水找零">860. 柠檬水找零</h1><p><strong>题目：</strong></p><p>在柠檬水摊上，每一杯柠檬水的售价为 5美元。顾客排队购买你的产品，（按账单 bills支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 bills ，其中 bills[i] 是第 i位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false。</p><p><strong>思路：</strong></p><p>很简单，记住5块有多少，10块有多少，遇到10块补5块，遇到20优先给出10块，没有10块就全给5块，中间给不出就false，能找完就true</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>&#123;<br>        <span class="hljs-type">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : bills) &#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">5</span>) five++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">10</span>) ten++, five--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ten == <span class="hljs-number">0</span>) five -= <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">else</span> ten--, five--;<br>            <span class="hljs-keyword">if</span>(ten &lt; <span class="hljs-number">0</span> || five &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="根据身高重建队列">406. 根据身高重建队列</h1><p><strong>题目：</strong></p><p>假设有打乱顺序的一群人站成一个队列，数组 people表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第i 个人的身高为 hi ，前面 <strong>正好</strong> 有 ki 个身高大于或等于 hi的人。</p><p>请你重新构造并返回输入数组 people所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj,kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p><strong>思路：</strong></p><p>有两个标准，不难想到应该先用身高排序，由高到低，其中相同身高的k由低到高，因为这样才能更便捷地调换位置，满足k的需要。</p><p>然后按照k来插入即可。注意使用list，底层由链表实现，插入效率较高，这题对于语法要求还有点高，得多熟悉这些不那么常用的API。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; p1, vector&lt;<span class="hljs-type">int</span>&gt; &amp; p2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> p1[<span class="hljs-number">0</span>] == p2[<span class="hljs-number">0</span>] ? p1[<span class="hljs-number">1</span>] &lt; p2[<span class="hljs-number">1</span>] : p1[<span class="hljs-number">0</span>] &gt; p2[<span class="hljs-number">0</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que; <span class="hljs-comment">// list底层是链表实现，插入效率比vector高的多</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 插入到下标为position的位置</span><br>            std::list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = que.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">while</span> (position--) &#123;<br>                it++;<br>            &#125;<br>            que.<span class="hljs-built_in">insert</span>(it, people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(que.<span class="hljs-built_in">begin</span>(), que.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day30</title>
    <link href="/2024/06/22/leetcode-day30/"/>
    <url>/2024/06/22/leetcode-day30/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/jump-game/description/">55.跳跃游戏</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/jump-game-ii/description/">45.跳跃游戏II</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/">1005.K次取反后最大化的数组和</a> <span class="label label-success">easy</span></li></ul><h1 id="买卖股票的最佳时机ii">122. 买卖股票的最佳时机II</h1><p><strong>题目：</strong></p><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><p><strong>思路：</strong></p><p>披着medium皮的easy题，统计所有上升就好了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) res += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="跳跃游戏">55. 跳跃游戏</h1><p><strong>题目：</strong></p><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回false 。</p><p><strong>思路：</strong></p><p>从终点倒着走，不断找能跳到当前的点，并将其更新为新的终点，如果最后终点来到了0，就找到了，反之则没有</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> end = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//4</span><br>        <span class="hljs-type">int</span> newend = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;<span class="hljs-comment">//3</span><br>        <span class="hljs-keyword">while</span>(newend &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(end - newend &gt; nums[newend]) newend--;<br>            <span class="hljs-keyword">else</span> &#123;<br>                end = newend;<br>                newend--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(end == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="跳跃游戏ii">45.跳跃游戏II</h1><p><strong>题目：</strong></p><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p><p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><ul><li>0 &lt;= j &lt;= nums[i]</li><li>i + j &lt; n</li></ul><p>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n -1]。</p><p><strong>思路：</strong></p><p>贪心就是贪个最远能到达的距离，当前在一个地方，这个地方前面有一个范围，范围呢每个点又有范围，找的就是有最远范围的下一个点。</p><p>写得感觉有点冗余，过用例的时候错一个改一条，突然就AC了，没细察。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> current = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(current &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> currentMaxRange = current + nums[current];<br>            <span class="hljs-keyword">if</span>(currentMaxRange &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> nextStepMaxRange = currentMaxRange;<br>            <span class="hljs-type">int</span> nextStep = current;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = current + <span class="hljs-number">1</span>;i &lt;= currentMaxRange;i++) &#123;<br>                <span class="hljs-keyword">if</span>(nextStepMaxRange &lt; i + nums[i]) &#123;<br>                    nextStepMaxRange = i + nums[i];<br>                    nextStep = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nextStepMaxRange &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans + <span class="hljs-number">2</span>;<br>            current = nextStep;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="k次取反后最大化的数组和">1005.K次取反后最大化的数组和</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p><ul><li>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。</li></ul><p>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p><p>以这种方式修改数组后，返回数组 可能的最大和 。</p><p><strong>思路：</strong></p><p>见<ahref="https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html">代码随想录</a></p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp);       <span class="hljs-comment">// 第一步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 第二步</span><br>            <span class="hljs-keyword">if</span> (A[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>) &#123;<br>                A[i] *= <span class="hljs-number">-1</span>;<br>                K--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) A[A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>; <span class="hljs-comment">// 第三步</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) result += a;        <span class="hljs-comment">// 第四步</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day29</title>
    <link href="/2024/06/21/leetcode-day29/"/>
    <url>/2024/06/21/leetcode-day29/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/assign-cookies/description/">455.分发饼干</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/wiggle-subsequence/description/">376.摆动序列</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/maximum-subarray/description/">53.最大子数组和</a> <span class="label label-warning">medium</span></li></ul><h1 id="分发饼干">455. 分发饼干</h1><p><strong>题目：</strong></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j分配给孩子 i，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>思路：</strong></p><p>见<ahref="https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 分发饼干</a></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123;<br>                result++;<br>                index--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="摆动序列">376. 摆动序列</h1><p><strong>题目：</strong></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7,3) 是正负交替出现的。</p><p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5]不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度。</p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 1000</li><li>0 &lt;= nums[i] &lt;= 1000</li></ul><p><strong>思路：</strong></p><p>符号转换一次就记一次数。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sign = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(nums[i] - nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                sign = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                sign = <span class="hljs-number">0</span>;<br>            &#125;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最大子数组和">53. 最大子数组和</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><p><strong>思路：</strong></p><p>见<ahref="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录| 最大子数组和</a></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = INT_MIN;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            sum += nums[i];<br>            res = <span class="hljs-built_in">max</span>(res, sum);<br>            <span class="hljs-keyword">if</span>(sum &lt;= <span class="hljs-number">0</span>) sum = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day28</title>
    <link href="/2024/06/19/leetcode-day28/"/>
    <url>/2024/06/19/leetcode-day28/</url>
    
    <content type="html"><![CDATA[<p>期末复习压力大，简单写写，暑假再补</p><p>(已补)</p><p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/non-decreasing-subsequences/description/">491.非递减子序列</a> <span class="label label-warning">medium</span><br /></li><li><a href="https://leetcode.cn/problems/permutations/description/">46.全排列</a> <span class="label label-warning">medium</span><br /></li><li><ahref="https://leetcode.cn/problems/permutations-ii/description/">47.全排列Ⅱ</a> <span class="label label-warning">medium</span><br /></li><li><ahref="https://leetcode.cn/problems/reconstruct-itinerary/description/">332.重新安排行程</a> <span class="label label-danger">hard</span><br /></li><li><a href="https://leetcode.cn/problems/n-queens/description/">51.N皇后</a><span class="label label-danger">hard</span><br /></li><li><ahref="https://leetcode.cn/problems/sudoku-solver/description/">37.解数独</a><span class="label label-danger">hard</span></li></ul><h1 id="非递减子序列">491. 非递减子序列</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素。你可以按 任意顺序 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>思路：</strong></p><p>难点在于去重，例如[1,2,3,1,1]这样的用例，就要注意不要在解空间树第一层重复取1，最后得到重复的[1,1]和[1,1,1]，解空间树单层去重方法为在单层递归中创建一个作用域仅限于单层递归函数内的记录变量数组，用过就记录，之后再用就跳过，具体代码实现方法见下</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">-101</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; nums, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(<span class="hljs-number">210</span>, <span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">//这就是作用域仅在单层的记录变量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; pre) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[nums[i] + <span class="hljs-number">100</span>]) <span class="hljs-keyword">continue</span>;<br>            used[nums[i] + <span class="hljs-number">100</span>] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            pre = nums[i];<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            pre = !temp.<span class="hljs-built_in">empty</span>() ? temp.<span class="hljs-built_in">back</span>() : <span class="hljs-number">-101</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="全排列">46. 全排列</h1><p><strong>题目：</strong></p><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以按任意顺序 返回答案。</p><p><strong>思路：</strong></p><p>在程序设计课上写那么久，之前一直踩坑全局used，这下终于能尽情全局used了，手速题，10min秒了</p><p>carl哥的方法明明和我一样，只是把used下传了，但就是快，也许是语法因素？</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(used[i]) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        used.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">backtrack</span>(nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="全排列ⅱ">47. 全排列Ⅱ</h1><p><strong>题目：</strong></p><p>给定一个可包含重复数字的序列 nums ，按任意顺序返回所有不重复的全排列。</p><p><strong>思路：</strong></p><p>又是去重，由于任意顺序，所以可以排序，对于[1,1,2]这样的用例，需要注意的就是不要来两个[1,1,2]，光把前两个1交换了。</p><p>去重标准可设为：相同元素仅允许最先一个作为开头，之后的相同元素不可做开头，但可做后缀。</p><p>翻译成代码就是<code>if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue;</code></p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[i]) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        used.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">backtrack</span>(nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="重新安排行程">332. 重新安排行程</h1><p><strong>题目：</strong></p><p>给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi]表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><p>所有这些机票都属于一个从JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p><p>例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。假定所有机票至少存在一种合理的行程。且<strong>所有的机票 必须都用一次 且只能用一次</strong>。</p><p><strong>思路：</strong></p><p>首先看懂题目，类似哥尼斯堡七桥问题，也就是欧拉回路，就是要找到一条路，能把所有路走一遍且不重复，而此题还额外要求字典序最小。</p><p>那么可以直观得到如下思路：</p><ol type="1"><li>找到当前节点能够去到的 所有 下一个节点，按字典序由小到大排好序</li><li>从最小字典序节点开始dfs，如果最后没能用光机票而走入死路，则换次小字典序节点继续寻找，直到找到。</li></ol><p>思路其实不难，主要在于代码实现，carl合理选择了适当的容器来做，代码时间打败98%，但我这次独立完成，主要记录个人解题思路，目前最优解仍为carl的题解，详见：<ahref="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E6%80%9D%E8%B7%AF">代码随想录| 重新安排行程</a>。</p><p>对于我的思路，具体代码实现遇到的问题见代码注释，直接叙述效果不佳</p><h2 id="代码-3">代码</h2><h3 id="个人代码可怜的5">个人代码（可怜的5%😭）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<span class="hljs-comment">//存欧拉道路</span><br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<span class="hljs-comment">//记录哪些tickets的下标已经被用过，即用过的机票</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt; &amp;tickets, string start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == tickets.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//根据start得到接下来的目标，选取可用的机票，按字典序从小到大排列</span><br>        <span class="hljs-comment">//按下标存方便used记录，按名称存不好记录哪些机票用过了，后续会出问题，于是两个合在一起存，排序自定义</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, string&gt;&gt; nextPort;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; tickets.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(!used[i] &amp;&amp; tickets[i][<span class="hljs-number">0</span>] == start) &#123;<br>                nextPort.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, string&gt;(i, tickets[i][<span class="hljs-number">1</span>]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nextPort.<span class="hljs-built_in">begin</span>(), nextPort.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-comment">//遍历接下来的机场，如果找到答案，则直接返回，如果没有，则换次小字典序机场再找</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nextPort.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(used[nextPort[i].first]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//超时尝试剪枝，对于相同机票，可失败后跳过后续所有相同机票</span><br>            <span class="hljs-comment">//剪枝后成功AC，但用时仅超过5%，丢人</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nextPort[i].second == nextPort[i - <span class="hljs-number">1</span>].second) <span class="hljs-keyword">continue</span>;<br>            used[nextPort[i].first] = <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nextPort[i].second);<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtrack</span>(tickets, nextPort[i].second)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            used[nextPort[i].first] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果走到这一步，证明走错，返回false</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, string&gt; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, string&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.second.<span class="hljs-built_in">compare</span>(b.second) &lt; <span class="hljs-number">0</span>;<span class="hljs-comment">//按照字典序排序</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        used.<span class="hljs-built_in">resize</span>(tickets.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<span class="hljs-comment">//记录哪些机票已经被用过</span><br>        path.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<span class="hljs-comment">//起点不会被加入，所以提前加入</span><br>        <span class="hljs-built_in">backtrack</span>(tickets, <span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="carl的优质代码个人注释版">carl的优质代码个人注释版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//才注意到carl哥把自己实现的方法都private了，细节！</span><br><span class="hljs-comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span><br>unordered_map&lt;string, map&lt;string, <span class="hljs-type">int</span>&gt;&gt; targets;<span class="hljs-comment">// 起点 -&gt; (目的地，剩余可飞次数)</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == ticketNum + <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//找齐了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//回传成功信号，也算剪枝了吧，不用再遍历后续的target了</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (pair&lt;<span class="hljs-type">const</span> string, <span class="hljs-type">int</span>&gt;&amp; target : targets[result[result.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]]) &#123;<span class="hljs-comment">//细节引用，result[result.size() - 1]就是前一个机场，targets[result[result.size() - 1]]就是要遍历的目的地集合</span><br>        <span class="hljs-keyword">if</span> (target.second &gt; <span class="hljs-number">0</span> ) &#123; <span class="hljs-comment">// 该路线还有余票</span><br>            result.<span class="hljs-built_in">push_back</span>(target.first);<span class="hljs-comment">//回溯模板，看不懂只能去复习了</span><br>            target.second--;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(ticketNum, result)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            result.<span class="hljs-built_in">pop_back</span>();<br>            target.second++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        targets.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//细节clear，防止内存里有脏东西</span><br>        vector&lt;string&gt; result;<span class="hljs-comment">//没开成员变量，提高速度，见 全排列的疑惑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;string&gt;&amp; vec : tickets) &#123;<span class="hljs-comment">//vec就是每张票了，俩元素，起点[0]跟终点[1]</span><br>            targets[vec[<span class="hljs-number">0</span>]][vec[<span class="hljs-number">1</span>]]++; <span class="hljs-comment">// 这里就提前给每个目的地集合按字典序排好序了，之后从头遍历就行</span><br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>); <span class="hljs-comment">// 手动加入起始机场</span><br>        <span class="hljs-built_in">backtracking</span>(tickets.<span class="hljs-built_in">size</span>(), result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="n皇后">51. N皇后</h1><p><strong>题目：</strong></p><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code>个皇后放置在 <code>n×n</code>的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong>的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code>分别代表了皇后和空位。</p><p>提示：</p><p><code>1 &lt;= n &lt;= 9</code></p><p><strong>思路：</strong></p><p>按图的深度优先搜索回溯查找所有放置可能，结束条件就是放到了最后一行仍然合法，放一个就在当前基础上往下搜索，写好判断合法函数，注意有两条斜线，经典问题所以不太难，披着hard的中等题吧。</p><h2 id="代码-4">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<span class="hljs-comment">//存放所有解</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, vector&lt;string&gt; &amp;board)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(row == n) &#123;<span class="hljs-comment">//最后一行放下去了，来到了界外</span><br>            ans.<span class="hljs-built_in">push_back</span>(board);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isVaild</span>(n, row, i, board)) <span class="hljs-keyword">continue</span>;<br>            board[row][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            <span class="hljs-built_in">backtrack</span>(n, row + <span class="hljs-number">1</span>, board);<br>            board[row][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">//尝试下一个放置位</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isVaild</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, vector&lt;string&gt; &amp;board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r &lt; n;r++) &#123;<span class="hljs-comment">//检测[row, col]有无同列Queen</span><br>            <span class="hljs-keyword">if</span>(board[r][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> r = row, c = col;<br>        <span class="hljs-keyword">while</span>(r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//检测左上斜线有无Queen</span><br>            <span class="hljs-keyword">if</span>(board[r--][c--] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        r = row, c = col;<br>        <span class="hljs-keyword">while</span>(r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; n) &#123;<span class="hljs-comment">//检测右上斜线有无Queen</span><br>            <span class="hljs-keyword">if</span>(board[r--][c++] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">board</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        <span class="hljs-built_in">backtrack</span>(n, <span class="hljs-number">0</span>, board);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="解数独">37. 解数独</h1><p><strong>题目：</strong></p><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 遵循如下规则：</p><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3宫内只能出现一次。（请参考示例图）</li></ul><p>数独部分空格内已填入了数字，空白格用 '.' 表示。</p><p>示例一：</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/202011171912586.png"alt="示例一" /><figcaption aria-hidden="true">示例一</figcaption></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],<br><br>[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],<br><br>[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],<br><br>[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br><br>输出：[[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>],<br><br>[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>],<br><br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>],<br><br>[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],<br><br>[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],<br><br>[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],<br><br>[<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>],<br><br>[<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],<br><br>[<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br><br>解释：输入的数独如上图所示，唯一有效的解决方案如下所示：<br></code></pre></td></tr></table></figure><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20201117191340669.png"alt="answer" /><figcaption aria-hidden="true">answer</figcaption></figure><p>图源：<ahref="https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p><p><strong>思路：</strong></p><div class="note note-light">            <p>没写出来，想着用n皇后的思路一个一个回溯暴力填的，结果一堆bug😭</p><p>记录一下错误思路：在回溯函数里我传入了上一个被填位置的row和col，想着每次向下递归就能知道上次在哪里，结果会出现：一行填到最后一个没法填了，退回去清空倒数第二格后再跳过把最后一格填了，留着空格子不管直接下一行……</p><p>问题出在返回false的时机上，其实到没法填的时候就已经可以返回false了，然后会到上一格接着试下一个数字。</p>          </div><p>这道题回溯没有单独设置终止条件，如果有传参的话也许可以加一条到了8行9列就返回，不过也可以不加，循环跑完自然就会结束。</p><h2 id="代码-5">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//先行再列，逐个试错</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r &lt; <span class="hljs-number">9</span>;r++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">9</span>;i++) &#123;<span class="hljs-comment">//先填满row行</span><br>                <span class="hljs-keyword">if</span>(board[r][i] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">9</span>;j++) &#123;<span class="hljs-comment">//为(r, i)尝试所有可能数字</span><br>                    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isValid</span>(board, r, i, j)) <span class="hljs-keyword">continue</span>;<br>                    board[r][i] = <span class="hljs-string">&#x27;0&#x27;</span> + j;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtrack</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    board[r][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//没得填了，返回false</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp; board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;c &lt; <span class="hljs-number">9</span>;c++) <span class="hljs-keyword">if</span>(board[row][c] == <span class="hljs-string">&#x27;0&#x27;</span> + num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r &lt; <span class="hljs-number">9</span>;r++) <span class="hljs-keyword">if</span>(board[r][col] == <span class="hljs-string">&#x27;0&#x27;</span> + num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = row / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;r &lt; (row / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)*<span class="hljs-number">3</span>;r++) &#123;<span class="hljs-comment">//宫格</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c = col / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;c &lt; (col / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)*<span class="hljs-number">3</span>;c++) &#123;<br>                <span class="hljs-keyword">if</span>(board[r][c] == <span class="hljs-string">&#x27;0&#x27;</span> + num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">backtrack</span>(board);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day27</title>
    <link href="/2024/06/18/leetcode-day27/"/>
    <url>/2024/06/18/leetcode-day27/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/restore-ip-addresses/description/">93.复原IP地址</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/subsets/description/">78.子集</a> <span class="label label-warning">medium</span></li><li><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集Ⅱ</a><span class="label label-warning">medium</span></li></ul><h1 id="复原ip地址">93. 复原IP地址</h1><p><strong>题目：</strong></p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255之间组成，且不能含有前导 0），整数之间用 '.' 分隔。</p><p>例如："0.1.2.201" 和 "192.168.1.1" 是 <strong>有效</strong> IP地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是<strong>无效</strong> IP 地址。 给定一个只包含数字的字符串 s，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP地址</strong>，这些地址可以通过在 s 中插入 '.' 来形成。你<strong>不能</strong> 重新排序或删除 s 中的任何数字。你可以按<strong>任何</strong> 顺序返回答案。</p><p><strong>思路：</strong></p><p>回溯做了几天，对于简单的解空间树怎么分支比较熟悉了，这题就先按长度从1到3分割，然后下传起点，如果第四段仍然合法，则找到一个答案，不断递归回溯寻找所有答案即可。</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933.png"alt="解空间树.图源：代码随想录" /><figcaption aria-hidden="true">解空间树.图源：<ahref="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E6%80%9D%E8%B7%AF">代码随想录</a></figcaption></figure><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    string temp;<br>    <span class="hljs-type">int</span> seg = <span class="hljs-number">4</span>;<span class="hljs-comment">//剩余段数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(seg &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(seg == <span class="hljs-number">0</span> &amp;&amp; begin &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() - i &gt; seg * <span class="hljs-number">3</span> &amp;&amp; i - begin &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//后续太多，直接剪枝\提前判断位数剪枝</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, begin, i)) &#123;<br>                <span class="hljs-keyword">if</span>(begin &gt; <span class="hljs-number">0</span>) temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                temp += <span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + begin, s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>                seg--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">backtrack</span>(s, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span>(!temp.<span class="hljs-built_in">empty</span>() &amp;&amp; temp.<span class="hljs-built_in">back</span>() != <span class="hljs-string">&#x27;.&#x27;</span>) temp.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">if</span>(!temp.<span class="hljs-built_in">empty</span>()) temp.<span class="hljs-built_in">pop_back</span>();<br>            seg++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &lt; end &amp;&amp; s[begin] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(begin &lt;= end) &#123;<br>            num *= <span class="hljs-number">10</span>;<br>            num += s[begin++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= num &amp;&amp; num &lt;= <span class="hljs-number">255</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">backtrack</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="子集">78. 子集</h1><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> ，数组中的元素<strong>互不相同</strong>。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 <strong>任意顺序</strong>返回解集。</p><p><strong>思路：</strong></p><p>也是很容易套上模板的回溯，不过<strong>不能不求甚解依赖模板</strong>，还是要想清楚代码逻辑。这题是求子集，高中就学过n个元素的集合有2^n个子集，虽然跟这没啥关系，不过可以认识到求子集就是求元素个数从0~n的关于全集nums的组合，所以可以分别求长度为i，i从0到n，的组合，那就是从nums里抓i个的组合，就变成了该题的上一题：<ahref="https://leetcode.cn/problems/combinations/">77. 组合</a>了。</p><div class="note note-light">            <p>对于错误思路的反思：</p><p>注意到该题的tag里有<strong>位运算</strong>字样，昨天做错的题目里我也尝试使用位运算模拟<code>bool used[]</code>来记录哪些数字已经被使用过，但实际上是多余的。今天又看见位运算，由于其出现在tag里，所以深信不疑，再次尝试，WA，去掉后，AC。下面逐条分析错误核心，搞清楚什么时候用used记录用过，什么时候不用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<span class="hljs-comment">//此处i从begin开始，已经与之前的结果隔开</span><br>    <span class="hljs-keyword">if</span>(used &gt;&gt; nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//这句等同于：如果nums[i]在之前用过就跳过，但此题nums中无重复元素，所以之前出现的元素之后肯定没出现过，多余</span><br>    used |= <span class="hljs-number">1</span> &lt;&lt; nums[i];<span class="hljs-comment">//在used的第nums[i]位置一</span><br>    temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>, len);<br>    temp.<span class="hljs-built_in">pop_back</span>();<br>    used &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; nums[i]);<span class="hljs-comment">//第nums[i]位复位</span><br>&#125;<br></code></pre></td></tr></table></figure><p>看完发现，used的确多余，但好像没有影响啊，其实WA原因在于<code>used &gt;&gt; nums[i] % 2</code>，%运算符优先级高于&gt;&gt;，所以错了。</p><p>当然，改了还是会错，nums里有负数，这样就越来越复杂了。</p>          </div><h2 id="代码-1">代码</h2><p><strong>第一版</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == len) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>, len);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= nums.<span class="hljs-built_in">size</span>();i++) &#123;<br><br>            <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>, i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p><strong>carl的解</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(temp);<span class="hljs-comment">//提前</span><br>        <span class="hljs-keyword">if</span>(begin &gt;= nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="子集ⅱ">90. 子集Ⅱ</h1><p><strong>题目：</strong></p><p>给你一个整数数组 nums，其中可能包含<strong>重复元素</strong>，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按<strong>任意顺序</strong> 排列。</p><p><strong>思路：</strong></p><p>与上一题相比多了重复元素，相当于[1,2,2]的子集注意别回溯出两个[1,2]，可以采用昨天<ahref="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">40.组合总和</a>的相同去重思路。在昨天的blog中已经提到不能简单用used来尝试去重。所以还是乖乖用carl的写法，附图carl的解空间树：</p><figure><imgsrc="https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000918.png"alt="子集Ⅱ解空间树,图源：代码随想录 | 子集Ⅱ" /><figcaption aria-hidden="true">子集Ⅱ解空间树,图源：<ahref="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF">代码随想录| 子集Ⅱ</a></figcaption></figure><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(temp);<br>        <span class="hljs-keyword">if</span>(begin &gt;= nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-comment">//使用这条的前提是要排序哦，不然相同的不挨在一起就麻烦了</span><br>            <span class="hljs-keyword">if</span>(i &gt; begin &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day26</title>
    <link href="/2024/06/17/leetcode-day26/"/>
    <url>/2024/06/17/leetcode-day26/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/combination-sum/description/">39.组合总和</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/combination-sum-ii/description/">40.组合总和Ⅱ</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/palindrome-partitioning/description/">131.分割回文串</a> <span class="label label-warning">medium</span></li></ul><h1 id="组合总和">39. 组合总和</h1><p><strong>题目：</strong></p><p>给你一个<strong>无重复元素</strong>的整数数组 <code>candidates</code>和一个目标整数 <code>target</code> ，找出 <code>candidates</code>中可以使数字和为目标数 <code>target</code> 的 所有<strong>不同组合</strong> ，并以列表形式返回。你可以按<strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以<strong>无限制重复被选取</strong>。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于<code>150</code> 个。</p><p><strong>思路：</strong></p><p>递归挨个选取就行，选了一个之后递归下一个，起点不变，如果和到了target就加入答案，可以在下一步递归前判断当前值是否已经过大了，过大则跳过实现剪枝。比较简单</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidate, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; candidate.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(candidate[i] &gt; target) <span class="hljs-keyword">continue</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(candidate[i]);<br>            <span class="hljs-built_in">backtrack</span>(candidate, target - candidate[i], i);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-keyword">if</span>(candidates.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">backtrack</span>(candidates, target, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="组合总和ⅱ">40. 组合总和Ⅱ</h1><p><strong>题目：</strong></p><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数<code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为<code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用<strong>一次</strong> 。</p><p><strong>注意</strong>：解集不能包含重复的组合。</p><p><strong>提示:</strong></p><p><code>1 &lt;= candidates.length &lt;= 100</code></p><p><code>1 &lt;= candidates[i] &lt;= 50</code></p><p><code>1 &lt;= target &lt;= 30</code></p><p><strong>思路：</strong></p><p>难点主要在于去重，下面举个例子来快速直观体会这道题要去什么重</p><p>对于示例：<code>[10,1,1,7,6,1,5]</code>、<code>target = 8</code>，正确结果应该是<code>[[1,1,1,5],[1,1,6],[1,7]]</code>。题目中<strong>candidate中的每个数字只能用一次</strong>是关键，勿错误理解为每种数字只能用一次，示例<code>[10,1,1,7,6,1,5]</code>中有3个<code>1</code>，当<strong>选中第一个<code>1</code>作为解成员之一</strong>递归下去的时候，由于之前无1，所以已有的解中肯定无1，后面的两个<code>1</code>仍然可用，由答案可见，选中第一个<code>1</code>递归下去已经可以得到全部解了。</p><p>那么<strong>选中第二个<code>1</code>作为解成员之一</strong>递归下去后，后面还有一个<code>1</code>，此时<strong>含有两个<code>1</code>的解</strong>已经出现过了，此时需要去重。</p><p>由上可看出不能简单使用used来阻止使用使用过的下标，因为第一个1把所有解得到后，回溯取消操作会开放used，后面的1又会变得可用，去重失败</p><p>carl哥的代码思路按我理解可以叙述为：<span class="label label-danger">重复元素只能由排前面的重复元素使用</span>，对于上面的示例，就是含有多个1的解只能由第一个1的递归分支得到，后面的如果还是1就不能在解里出现1。</p><p><strong>排前面的重复</strong>即对应carl哥说法的<strong>前一个树枝</strong>，即前一个重复元素的解空间树分支。</p><div class="note note-light">            <p>又瞟了题解才做出来，WA了4发😭😭😭</p><p>脑子抽了没看见<code>1 &lt;= candidates.length &lt;= 100</code>，还乐呵呵地用位运算当used[]用来记录哪些下标被用了，左移右移老半天跟二傻子似的，结果不仅位运算爆longlong，而且用used记录本身就是脱裤子放屁，因为我回溯传了起点begin……</p>          </div><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidate, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; candidate.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(candidate[i] &gt; target) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(i &gt; begin &amp;&amp; candidate[i] == candidate[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//去重关键</span><br>            temp.<span class="hljs-built_in">push_back</span>(candidate[i]);<br>            <span class="hljs-built_in">backtrack</span>(candidate, target - candidate[i], i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-keyword">if</span>(candidates.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtrack</span>(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="分割回文串">131. 分割回文串</h1><p><strong>题目：</strong></p><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回s 所有可能的分割方案。</p><p><strong>思路：</strong></p><div class="note note-light">            <p>没做出来，贴出失败思路：</p><p>分割子串，想到之前做的有关题目了，至少分割操作还是比较熟悉，用迭代器构造新串就好，从首开始分割，分割长度逐渐递增，也就是回溯中的那个for循环，每个分割长度在分割前判断是否是回文串，如果是回文串就分割，不是就接着增大分割长度。</p><p>然后就卡了……没记住或者说想另辟蹊径结果弄巧成拙，没有像模板那样接着回溯下一种可能并取消当前轮次操作继续for循环。</p>          </div><p>接下来是正确思路：</p><p>仍然按照回溯模板，理清递归思路： 1. 递归参数与返回值： 返回值void，参数应该是分割起点，确保能够递归下去接着分割之后的子串 2.递归终止条件，如果真的分割到结尾，那么该条递归调用路线就是正确的，此时temp中即为一个答案，标准就是起点超过了终点，begin大于了string的长度3. 递归操作：逐个尝试分割长度，合法就接着分割，不合法就跳过</p><p>carl哥这次画的解空间树很形象，如下图，失败思路想到了怎么分支，但是没想到怎么判断叶节点，具体的代码写法也写昏了头</p><figure><img src="https://s3.bmp.ovh/imgs/2024/06/17/788a44e4b04795dd.png"alt="解空间树" /><figcaption aria-hidden="true">解空间树</figcaption></figure><h2 id="代码-2">代码</h2><h3 id="一般代码">一般代码</h3><p>之所以叫一般，是因为判断回文串的函数<code>isValid</code>每次调用都要俩指针相向而行，有很多重复操作，提高了时间复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;string&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = begin, right = end;<br>        <span class="hljs-keyword">if</span>(right &gt; s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span>(s[left++] != s[right--]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, begin, i)) &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + begin, s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>));<br>                <span class="hljs-built_in">backtrack</span>(s, i + <span class="hljs-number">1</span>);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-built_in">backtrack</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="动态规划代码">动态规划代码</h3><p>使用动态规划（dynamic programming，DP）直接把所有子串是否是回文串都提前算好，这样后续判断时就只需要O(1)复杂度就可以了</p><p>动态规划状态转移方程为： <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">           ⌜<span class="hljs-number">1</span>, <span class="hljs-selector-tag">i</span> = j <br><br>dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> = +s<span class="hljs-selector-attr">[i]</span>==s<span class="hljs-selector-attr">[j]</span>, <span class="hljs-selector-tag">i</span> = j - <span class="hljs-number">1</span><br><br>           ㇗s<span class="hljs-selector-attr">[i]</span>==s<span class="hljs-selector-attr">[j]</span>ANDdp<span class="hljs-selector-attr">[i+1]</span><span class="hljs-selector-attr">[j-1]</span>,<span class="hljs-keyword">else</span><br></code></pre></td></tr></table></figure><del>不会打latex，好拉的公式，快去配置渲染器！！</del></p><p>(更新：现在会打公式了，留着当耻辱柱😁，提升观感，公式如下) <spanclass="math display">\[dp[i][j]\ =\begin{cases}1,&amp; \text{$i=j$} \\s[i]==s[j],&amp; \text{$i=j-1$} \\s[i] == s[j]\ \and\ dp[i+1][j-1],&amp; \text{$else$}\end{cases}\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;string&gt; temp;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; dp;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = begin;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(dp[begin][i]) &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + begin, s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>));<br>                <span class="hljs-built_in">backtrack</span>(s, i + <span class="hljs-number">1</span>);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string &amp;s)</span> </span>&#123;<br>        dp.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<span class="hljs-comment">//vector还得resize了才能用</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; s.<span class="hljs-built_in">size</span>();j++) &#123;<br>                <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> == j) dp[i][j] = s[i] == s[j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == j) dp[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-built_in">isValid</span>(s);<br>        <span class="hljs-built_in">backtrack</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day24</title>
    <link href="/2024/06/15/leetcode-day24/"/>
    <url>/2024/06/15/leetcode-day24/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><a href="https://leetcode.cn/problems/combinations/">77.组合</a></li><li><ahref="https://leetcode.cn/problems/combination-sum-iii/description/">216.组合总和Ⅲ</a></li><li><ahref="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/">17.电话号码的字母组合</a></li></ul><h1 id="前言">前言</h1><p>进入回溯算法篇章，对递归掌握仍然不熟练，尤其是回溯算法，在左的课上写全排列等题目简直惨不忍睹，趁此机会，再次尝试学会回溯算法，每题务必隔天复习重写熟悉</p><p>卡哥的题解也要仔细看，综合多篇题解学习。</p><blockquote><p><ahref="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">文章讲解</a><br /><a href="https://www.bilibili.com/video/BV1cy4y167mM">视频讲解</a></p></blockquote><h1 id="组合">77. 组合</h1><p><strong>题目：</strong></p><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>思路：</strong></p><p>多重for循环就行，但是由于层数不定，所以不能直接for，需要靠递归来实现任意层数循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;    <span class="hljs-comment">//回溯模板1：总答案</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;           <span class="hljs-comment">//回溯模板2：单个答案暂存</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == k) &#123;  <span class="hljs-comment">//回溯模板3：递归结束条件：遍历到叶子节点</span><br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start;i &lt;= n - k + temp.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(i);  <span class="hljs-comment">//回溯模板4：选择当前，进入下一步</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-comment">//回溯模板5：取消之前操作，回溯</span><br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="组合总和ⅲ">216. 组合总和Ⅲ</h1><p><strong>题目：</strong></p><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em>。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>思路：</strong></p><p>和上一道题很像，卡哥选题还是很有深意的。熟悉模板写法，给出的代码没有剪枝，剪枝写法参见：</p><p><ahref="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">代码随想录| 组合总和iii</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == k) &#123;<br>            <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start;i &lt;= <span class="hljs-number">9</span>;i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(k, n - i, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">backtracking</span>(k, n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="电话号码的字母组合">17. 电话号码的字母组合</h1><p><strong>题目：</strong></p><p>给定一个仅包含数字 2-9的字符串，返回所有它能表示的字母组合。答案可以按<strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1不对应任何字母。</p><p><strong>思路：</strong></p><p>仍然是不定次数for循环，使用递归来解，同样，剪枝写法参见<ahref="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">代码随想录| 电话号码的字母组合</a></p><p>注意打表方式，值得学习，自己打表还用的unordered_map，结果打出来一堆bug，还是string数组聪明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    string temp;<br>    <span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = &#123;<br>    <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 0</span><br>    <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 1</span><br>    <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-comment">// 2</span><br>    <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-comment">// 3</span><br>    <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-comment">// 4</span><br>    <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-comment">// 5</span><br>    <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-comment">// 6</span><br>    <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-comment">// 7</span><br>    <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-comment">// 8</span><br>    <span class="hljs-string">&quot;wxyz&quot;</span>, <span class="hljs-comment">// 9</span><br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string digits, <span class="hljs-type">int</span> begin_for_string)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> digit = digits[begin_for_string] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        string letter = letterMap[digit];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; letter.<span class="hljs-built_in">size</span>();i++) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(letter[i]);<br>            <span class="hljs-built_in">backtracking</span>(digits, begin_for_string + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">backtracking</span>(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day23</title>
    <link href="/2024/06/14/leetcode-day23/"/>
    <url>/2024/06/14/leetcode-day23/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669.修剪二叉搜索树</a> <span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108.将有序数组转换为二叉搜索树</a> <span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">538.把二叉搜索树转换为累加树</a> <span class="label label-warning">medium</span></li></ul><h1 id="修剪二叉搜索树">669. 修剪二叉搜索树</h1><p><strong>题目：</strong></p><p>给你二叉搜索树的根节点 <code>root</code>，同时给定最小边界<code>low</code> 和最大边界<code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树<strong>不应该</strong> 改变保留在树中的元素的相对结构(即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在<strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>思路：</strong></p><p>根据day22的“删除二叉搜索树的节点”，这题就变成了：删除小于low的节点和大于high的节点，那么同样的做法，制定好分类讨论的规则，然后按规则遍历就好</p><h2 id="可以中序遍历吗">可以中序遍历吗？</h2><p>笔者第一版代码惨遭RE和WA，由于是区间，所以笔者“理所应当”地想要中序遍历先把小的全删了，然后再把大的全删了，看似没有问题，就像操作有序数组一样，但笔者实际写出的代码却是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root) &#123;<span class="hljs-comment">//不为空才操作</span><br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);    <span class="hljs-comment">//先左，中序嘛</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; low) &#123;                           <span class="hljs-comment">//然后中，处理当前节点</span><br>            TreeNode * temp = root;                     <span class="hljs-comment">//如果当前的小了</span><br>            root = root-&gt;right;                         <span class="hljs-comment">//让更大一点的右孩子来补位（雷点所在）</span><br>            <span class="hljs-keyword">delete</span> temp;                                <span class="hljs-comment">//删掉当前的</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; high) &#123;                     <span class="hljs-comment">//同理</span><br>            TreeNode * temp = root;<br>            root = root-&gt;left;                          <span class="hljs-comment">//大了就让更小一点的左孩子来补位</span><br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root) root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<span class="hljs-comment">//最后右</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>RE原因：</strong>这题力扣上似乎有点问题，对于<code>[1, null, 2]</code>这个用例，如果delete掉root，就会报错，但本地写好代码run出来是不会报错的，carl对此的解释是：</p><div class="note note-light">            <p>○ 代码加了内存释放，在运行时出错，<code>[1,null,2]</code>这个输入，本地调试时，没有出错。卡哥的代码没有处理内存问题，难道这题不用自己释放内存？把delete的逻辑移除后，就通过了。手动delete反而会出错</p><p>○解答：因为最终答案是删除了原本的根节点，然后返回节点2作为新的根节点也就是答案，为此做了两个实验：1.把right子树的指赋给原本的root，然后最终返回root，可以通过case；2.把root指向right，然后之前用个tmp指向原本root的内存再删除，这次会报错。而报错的原因是释放的内存再次被使用，所以我猜测是LeetCode的判题机在判题的时候应该再次使用了原本子树根节点的那块内存导致的错误，你可以只删除那个会释放根节点的delete语句，其他的释放语句不去掉，结果还是可以通过的，所以你本地输出答案没有错误那说明就是lc自己的问题了，不用太过于纠结。</p>          </div><p>忽略力扣本身原因，关注上述中序代码的逻辑错误，即</p><p><strong>WA原因：</strong></p><p>对于用例[4, 2, 5, null,3]，如下图所示，若范围为[4,5]，那么应该删除2、3，最后得到一棵4、5的链，但是依照上述代码，当递归到节点<code>2</code>时，会发生：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode * temp = root;           <span class="hljs-comment">//记录节点2</span><br>root = root-&gt;right;               <span class="hljs-comment">//将root-&gt;right赋值给root指针变量，意图让右孩子补位</span><br><span class="hljs-keyword">delete</span> temp;                      <span class="hljs-comment">//删掉节点2</span><br></code></pre></td></tr></table></figure><p>问题就出在第二条，原本计划让right来补位，但是实际操作却仅仅是给一个函数里的形式参数赋了值，相当于<strong>用形参root保留了当前的右儿子</strong>，之后递归处理右儿子right实际却处理了右<strong>孙子</strong>，可能会返回右孙子本身或者null，但是最后却返回了右儿子right，相当于跳过了<code>if(root) root-&gt;right = trimBST(root-&gt;right, low, high);</code>语句，会导致修剪不到位，对于上述用例，就会返回[3,4,5]，本应被删除的节点3被保留了。</p><p>看起来被否定的只是代码编写，而中序遍历这个思路似乎仍具有可行性，实际上，硬要保持左中右的教条中序遍历，也是可以的。</p><p>需要改的地方就是：如果根节点被删除，那么就应该返回 <strong>儿子节点的处理结果</strong>，而不仅仅是儿子节点，修改后的中序遍历如下，由于力扣本身原因，省去delete操作避免RE：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-comment">//规则：</span><br>        <span class="hljs-comment">//1. 当前小，删了让右孩子补位</span><br>        <span class="hljs-comment">//2. 当前大，删了让左孩子补位</span><br>        <span class="hljs-comment">//3. 当前合法，处理左右孩子后返回</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//左</span><br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        <span class="hljs-comment">//中</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; low) <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; high) <br>            <span class="hljs-keyword">return</span> root-&gt;left;<br>        <span class="hljs-keyword">else</span><br>            root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>按照官解做完再看这段修改后的“中序”，其实会发现对比下来就是把<code>root-&gt;left = trimBST(root-&gt;left, low, high);</code>这句给摘出来提前了。</p><p><strong>综上</strong></p><p>对于“可以中序吗？”的问题，我的回答是可以，事实上这道题并不需要关注前中后序怎么遍历，这也引出了笔者的一个思维定势：<strong>二叉树的递归都基于前中后序遍历，迭代都基于层序遍历</strong>。不要局限于前中后序遍历，这只是参考，实际就按递归三部曲来就行</p><p><del>这也许是一直看卡哥的代码却没有仔细思考，光看了个大概长相的缘故。😣</del></p><h2 id="正经解答">正经解答</h2><p>对一个小问题想多了，下面给出优雅的正确答案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>            root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="将有序数组转化为二叉搜索树">108. 将有序数组转化为二叉搜索树</h1><blockquote><p>乍一看，想要走捷径，直接拉个有序链表不也是二叉搜索树？</p></blockquote><blockquote><p>实际上题目要求平衡。。切</p></blockquote><p><strong>题目：</strong></p><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵平衡 二叉搜索树。</p><p><strong>思路：</strong></p><p>由于要平衡，所以对半分就行，这样深度差就得到控制，不会退化成链，有点像快排？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>官解整花活，划线方式给整了三种，实际就是一种方法</p>          </div><h1 id="把二叉搜索树转换为累加树">538. 把二叉搜索树转换为累加树</h1><p><strong>题目：</strong></p><p>给出二叉 <strong>搜索</strong>树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater SumTree），使每个节点 <code>node</code> 的新值等于原树中大于或等于<code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>思路：</strong></p><p>把累加树定义看懂就成，就是把一个节点右边的值（比它大的）全加起来变成这个节点的新值。那不就是从右至左累加么，一个右中左顺序遍历，开个int记录前一个节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        root-&gt;right = <span class="hljs-built_in">convertBST</span>(root-&gt;right);<br>        root-&gt;val += pre;<br>        pre = root-&gt;val;<br>        root-&gt;left = <span class="hljs-built_in">convertBST</span>(root-&gt;left);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><del>少有的直接秒杀还和标准答案一模一样，嘿嘿嘿😆</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day22</title>
    <link href="/2024/06/13/leetcode-day22/"/>
    <url>/2024/06/13/leetcode-day22/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">235.二叉搜索树的最近公共祖先</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701.二叉搜索树的插入操作</a><span class="label label-warning">medium</span></li><li><ahref="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450.删除二叉搜索树中的节点</a><span class="label label-warning">medium</span></li></ul><h1 id="二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先</h1><p>与day21的第三题相比，这题多了二叉搜索树这一条件，变得更简单</p><p><strong>题目：</strong></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>思路</strong></p><p>主体思路就是<strong>当root的值在p和q之间时，root就是最近公共祖先了</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == p || root == q || !root) <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//沿用236题的返回条件</span><br>        <span class="hljs-keyword">if</span>(p-&gt;val &gt; q-&gt;val) &#123;<span class="hljs-comment">//先设定p &lt; q</span><br>            TreeNode * temp = p;<br>            p = q;<br>            q = temp;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//如果root在之间，返回</span><br>        <span class="hljs-keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<span class="hljs-comment">//不然就在左子树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<span class="hljs-comment">//不然就在右子树</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树的插入操作">701. 二叉搜索树的插入操作</h1><p><strong>题目：</strong></p><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。你可以返回 任意有效的结果 。</p><p><strong>思路</strong></p><p>不要拘泥于AVL的标准，这只是普通的二叉搜索树，哪怕退化成链都没关系，所以<strong>直接在最底部插入就行</strong></p><p>然后问题转化为:<strong>在二叉搜索树BST中查找val</strong>。当然肯定找不到，但最后会在某个叶子节点处下行碰到null，那么只需要判断走没走到叶子，以及val该插在叶子的左边还是右边</p><p><del>别想着在中途插入了，本菜比卡了一个小时没写出来，看评论区全是“伪装成medium的easy”😭</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) &#123;<br>            TreeNode * node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除二叉搜索树中的节点">450. 删除二叉搜索树中的节点</h1><p><strong>题目：</strong></p><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ul><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ul><p><strong>思路：</strong></p><p>依然别想着AVL的左右旋什么的，别自己给自己上难度，简单暴力地分类讨论就行：</p><ol type="1"><li>没找到<code>val</code>(<code>root</code>是空的)，返回<code>nullptr</code></li><li>要删的是个叶子，直接删了返回<code>nullptr</code></li><li>要删的节点只有一个孩子，删完孩子上来补位，返回这个独生子</li><li>要删的节点有两个孩子，把左子树接到右子树最左边的节点下面当左孩子（这样可以最简单地使树依然合法）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        <span class="hljs-keyword">if</span>(root-&gt;val == key) &#123;<br>            <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>                TreeNode * temp = root-&gt;left;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right &amp;&amp; !root-&gt;left) &#123;<br>                TreeNode * temp = root-&gt;right;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                TreeNode * keeper = root-&gt;right;<br>                <span class="hljs-keyword">while</span>(keeper-&gt;left != <span class="hljs-literal">nullptr</span>) keeper = keeper-&gt;left;<br>                keeper-&gt;left = root-&gt;left;<br>                TreeNode * temp = root-&gt;right;<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day21</title>
    <link href="/2024/06/13/leetcode-day21/"/>
    <url>/2024/06/13/leetcode-day21/</url>
    
    <content type="html"><![CDATA[<p>今日任务：</p><ul><li><ahref="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530.二叉搜索树的最小绝对差</a><span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/">501.二叉搜索树中的众数</a><span class="label label-success">easy</span></li><li><ahref="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236.二叉搜索树的最近公共祖先</a><span class="label label-warning">medium</span></li></ul><h1 id="二叉搜索树的最小绝对差">530. 二叉搜索树的最小绝对差</h1><p><strong>题目：</strong>（仅题干，示例请移步力扣）</p><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回<code>树中任意两不同节点值之间的最小差值</code> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>思路：</strong></p><p>由于是二叉搜索树，时刻牢记<span class="label label-info">中序遍历二叉搜索树相当于遍历有序数组</span>，所以大思路就是中序遍历树，并维护一个最小绝对差</p><p>中序遍历这里采用递归法，递归途中需要记录上一个节点的值以求出两数之差</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> &amp;ans, <span class="hljs-type">int</span> &amp; pre)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root) &#123;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;left, ans, pre);<br>            <span class="hljs-keyword">if</span>(pre == <span class="hljs-number">-1</span>) pre = root-&gt;val;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans = <span class="hljs-built_in">min</span>(ans, root-&gt;val - pre);<br>                pre = root-&gt;val;<br>            &#125;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;right, ans, pre);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = INT_MAX, pre = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">traversal</span>(root, ans, pre);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树中的众数">501. 二叉搜索树中的众数</h1><p><strong>题目：</strong></p><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code>，找出并返回 BST 中的所有<code>众数</code>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <code>小于等于</code> 当前节点的值</li><li>结点右子树中所含节点的值 <code>大于等于</code> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p><strong>思路：</strong></p><p>大思路仍然依靠<span class="label label-info">中序遍历二叉搜索树相当于遍历有序数组</span>，问题转换为求出一个有序数组中的众数，那么在遍历时记录每个数的频率，维护一个最大频率</p><p>若该数最后的频率小于最大频率，则不做操作；等于最大频率，则加入答案中；大于最大频率，则更新最大频率，清空当前答案，并将当前数加入答案</p><p>依然是递归中序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-comment">//答案answer</span><br>    <span class="hljs-type">int</span> max_freq = <span class="hljs-number">0</span>;<span class="hljs-comment">//最大频率</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> &amp;cur, <span class="hljs-type">int</span> &amp;freq)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, cur, freq);<span class="hljs-comment">//中序左</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val == cur) &#123;<span class="hljs-comment">//当前数cur还未遍历完，继续加频率freq</span><br>            freq++;<br>            <span class="hljs-keyword">if</span>(max_freq == freq) &#123;<span class="hljs-comment">//如果已经赶上最大频率，加入答案</span><br>                ans.<span class="hljs-built_in">push_back</span>(cur);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(max_freq &lt; freq) &#123;<span class="hljs-comment">//如果已经超过，更新max，清空答案，重新加入cur作为答案</span><br>                max_freq = freq;<br>                ans.<span class="hljs-built_in">clear</span>();<br>                ans.<span class="hljs-built_in">push_back</span>(cur);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cur = root-&gt;val;<span class="hljs-comment">//当前数cur遍历结束，将cur更新为新的数，频率重置</span><br>            freq = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, cur, freq);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cur = root-&gt;val, freq = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(root, cur, freq);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树的最近公共祖先">236. 二叉搜索树的最近公共祖先</h1><p><strong>题目：</strong></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>思路</strong></p><p>初次尝试越想越复杂，以失败告终，原因是单次递归逻辑和终止条件没想明白，</p><p>按照carl的递归三部曲：</p><ol type="1"><li>确定递归返回值和参数。这一步没问题，就按照力扣给的核心方法的定义就可以，返回公共祖先的指针，参数就是两个节点p、q和根节点</li><li>确定递归终止条件。第一个终止条件想到了：“root等于p或者q时，或者root为空”就返回root。之后就开始混乱了，尝试讨论p、q是root的孩子还是孙子还是更远的孩子，遂失败</li><li>确定单次递归逻辑。失败</li></ol><p>我没有分析出：当递归到<code>最近公共祖先的祖先</code>时，返回值也应该是<code>最近公共祖先</code>，也就是说<code>最近公共祖先</code>是会不断向上传递的，这样就就能保证<code>最近</code>而不会得到深度更浅的公共祖先。</p><p>对于<strong>遍历一条路</strong>还是<strong>遍历整棵树</strong>，carl老师的解释令我耳目一新：</p><div class="note note-light">            <p><strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）。</strong></p><p>搜索一条边的写法： <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">if</span> (递归函数(root-&gt;<span class="hljs-built_in">left</span>)) <span class="hljs-keyword">return</span> ;<br><span class="hljs-keyword">if</span> (递归函数(root-&gt;<span class="hljs-built_in">right</span>)) <span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></table></figure> 搜索整个树写法： <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">left</span> = 递归函数(root-&gt;<span class="hljs-built_in">left</span>);  // 左<br><span class="hljs-built_in">right</span> = 递归函数(root-&gt;<span class="hljs-built_in">right</span>); // 右<br><span class="hljs-built_in">left</span>与<span class="hljs-built_in">right</span>的逻辑处理;         // 中 <br></code></pre></td></tr></table></figure></p>          </div><p>由于返回值确定，所以递归时肯定会有东西接住返回值，又由于，递归的参数是root，返回值也是root，所以当递归root左右孩子时，返回值也应该是左右孩子，即必然会有</p><p><code>left = lowestCommonAncestor(root-&gt;left, p, q);</code></p><p>由于这道题不需要对树进行操作，只需要查找遍历，所以<code>left</code>并不是<code>root-&gt;left</code>，即不需要更新。根据carl的区分，我们可以根据这条语句推断我们之后应该进行left和right的逻辑处理，那么就可以合理推测应该判断left和right是否为空，因为如果没有找到必定返回空，而找到p、q才会返回p或者q，那么如果left和right都返回了，就遇到答案（root）了，向上不断返回即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == p || root == q || root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br><br>        TreeNode * left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode * right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> &amp;&amp; right != <span class="hljs-literal">nullptr</span>) <br>            <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><del>对于想了半小时还WA的我来说，这真是段优雅的代码</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day20</title>
    <link href="/2024/06/11/leetcode-day20/"/>
    <url>/2024/06/11/leetcode-day20/</url>
    
    <content type="html"><![CDATA[<p>今日内容</p><p><ahref="https://leetcode.cn/problems/maximum-binary-tree/description/">●654.最大二叉树</a><br /><ahref="https://leetcode.cn/problems/merge-two-binary-trees/description/">●617.合并二叉树</a><br /><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">●700.二叉搜索树中的搜索</a><br /><ahref="https://leetcode.cn/problems/validate-binary-search-tree/description/">●98.验证二叉搜索树</a></p><h1 id="最大二叉树">最大二叉树</h1><h2 id="一般写法">一般写法</h2><p>题目实际上已经给出了递归逻辑，翻译成代码即可</p><p>给定一个不重复的整数数组<code>nums</code>。<code>最大二叉树</code>可以用下面的算法从<code>nums</code>递归地构建:</p><ol type="1"><li>创建一个根节点，其值为<code>nums</code>中的最大值。</li><li>递归地在最大值<code>左边</code>的<code>子数组前缀上</code>构建左子树。</li><li>递归地在最大值<code>右边</code>的<code>子数组后缀上</code>构建右子树。</li></ol><p>返回<code>nums</code>构建的<code>最大二叉树</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) <br>            <span class="hljs-keyword">if</span>(nums[max] &lt; nums[i]) max = i;<br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[max]);<span class="hljs-comment">// 1创建一个根节点，其值为`nums`中的最大值。</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(nums.begin(), nums.begin() + max)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(nums.begin() + max + <span class="hljs-number">1</span>, nums.end())</span></span>;<br>        root-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(left);<span class="hljs-comment">// 2递归地在最大值`左边`的`子数组前缀上`构建左子树。</span><br>        root-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(right);<span class="hljs-comment">// 3递归地在最大值`右边`的`子数组后缀上`构建右子树。</span><br>        <span class="hljs-keyword">return</span> root;<span class="hljs-comment">// 返回最大二叉树</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="单调栈写法">单调栈写法</h2><p>笔者仅根据题目写出递归写法，未想到单调栈写法，此为<ahref="https://leetcode.cn/problems/maximum-binary-tree/solutions/1759348/zui-da-er-cha-shu-by-leetcode-solution-lbeo/">力扣官方题解</a>启发</p><figure><img src="https://s3.bmp.ovh/imgs/2024/06/11/b6ce26fcf0d47d93.png"alt="总体思想图示" /><figcaption aria-hidden="true">总体思想图示</figcaption></figure><div class="note note-light">            <p>因此，我们的任务变为：找出每一个元素左侧和右侧第一个比它大的元素所在的位置。这就是一个经典的单调栈问题了，可以参考<ahref="https://leetcode.cn/problems/next-greater-element-ii/description/">503.下一个更大元素II</a>。如果左侧的元素较小，那么该元素就是左侧元素的右子节点；如果右侧的元素较小，那么该元素就是右侧元素的左子节点。</p>          </div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;  <span class="hljs-comment">//单调栈</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(len, <span class="hljs-number">-1</span>)</span></span>;  <span class="hljs-comment">//每个节点左侧第一个更大的节点</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(len, <span class="hljs-number">-1</span>)</span></span>;  <span class="hljs-comment">//每个节点右侧第一个更大的节点</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">tree</span><span class="hljs-params">(len)</span></span>;  <span class="hljs-comment">//存储树节点</span><br>        <span class="hljs-comment">//使用单减栈 获取left和right  (题目限制元素是不同的)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            tree[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[i]); <span class="hljs-comment">//构造当前节点</span><br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[stk.<span class="hljs-built_in">top</span>()])&#123;  <span class="hljs-comment">//当前节点比栈中元素大 弹栈并给栈中的小元素赋right</span><br>                right[stk.<span class="hljs-built_in">top</span>()] = i;<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!stk.<span class="hljs-built_in">empty</span>())&#123;  <span class="hljs-comment">//当前节点的左侧更大节点就是单减栈的顶部元素</span><br>                left[i] = stk.<span class="hljs-built_in">top</span>();<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        TreeNode* root = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//将每个节点接到自己的父节点上以构造树形结构</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(left[i] == <span class="hljs-number">-1</span> &amp;&amp; right[i] == <span class="hljs-number">-1</span>)&#123;  <span class="hljs-comment">//当前节点为最大值，其为根</span><br>                root = tree[i];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left[i] == <span class="hljs-number">-1</span> || (right[i] != <span class="hljs-number">-1</span> &amp;&amp; nums[left[i]] &gt; nums[right[i]]))&#123; <br>                tree[right[i]]-&gt;left = tree[i];   <span class="hljs-comment">//左侧没有更大的节点或左侧更大值大于右侧更大值，说明当前节点是右侧更大值的左子树的根节点</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tree[left[i]]-&gt;right = tree[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>该代码中的注释来源于题解评论区<ahref="https://leetcode.cn/u/6ifted-ishi2aka1rd/"><span class="citation"data-cites="健">@健</span></a>，本菜比瞪眼看了十分钟没看懂，抄了，挖坑后面来看</p>          </div><h1 id="合并二叉树">合并二叉树</h1><p>简单递归即可</p><ol type="1"><li>确定返回值和参数：就按力扣给的核心函数递归就行，无需另写函数，返回值就是合并后的节点指针，参数就是要合并的两个节点</li><li>确定递归结束条件：如果一方为空则返回另一方，都不空则相加后返回和节点</li><li>确定递归中途操作：合并当前节点对应的左右孩子</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root1) <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span>(!root2) <span class="hljs-keyword">return</span> root1;<br>        root1-&gt;val += root2-&gt;val;<br>        root1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);<br>        root1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树中的搜索">二叉搜索树中的搜索</h1><p>过于简单，知道什么是二叉搜索树就能做，略</p><h1 id="验证二叉搜索树">验证二叉搜索树</h1><p>示例2就已经给出一个容易犯的陷阱：错误地以为只需要左右节点各比根节点小和大就可以了，实际上二叉搜索树需要整个左右子树都比根节点小和大，所以需要注意在想当然递归的时候不要只比较左右节点，还需注意更上层的节点。</p><p>由于是二叉搜索树，条件比较硬，所以可以充分利用二叉搜索树的特性————利用中序遍历获取序列，然后判断该序列是否单调递增就好，若不单调递增，证明不是二叉搜索树</p><p>二叉排序树左子树-根-右子树严格单调递增，标准地画出一棵二叉排序树，并从上到下作其投影可得到严格序列，该序列即是中序遍历序列，并且该序列单调递增</p><p>附图直观一览</p><figure><img src="https://s3.bmp.ovh/imgs/2024/06/11/8bf9279d365104cd.png"alt="二叉排序树的投影与中序遍历" /><figcaption aria-hidden="true">二叉排序树的投影与中序遍历</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; ans;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root) &#123;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; ans2 = ans;<br>        <span class="hljs-built_in">sort</span>(ans2.<span class="hljs-built_in">begin</span>(), ans2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; ans.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(ans[i] != ans2[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; ans2[i] &lt;= ans2[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day18</title>
    <link href="/2024/06/09/leetcode-day18/"/>
    <url>/2024/06/09/leetcode-day18/</url>
    
    <content type="html"><![CDATA[<p>今日内容</p><ul><li><ahref="https://leetcode.cn/problems/find-bottom-left-tree-value/">513.找树左下角的值</a><br /></li><li><a href="https://leetcode.cn/problems/path-sum/description/">112.路径总和</a></li><li><ahref="https://leetcode.cn/problems/path-sum-ii/">113.路径总和ii</a><br /></li><li><ahref="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106.从中序与后序遍历序列构造二叉树</a><br /></li><li><ahref="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105.从前序与中序遍历序列构造二叉树</a></li></ul><h1 id="找树左下角的值">找树左下角的值</h1><h2 id="递归写法">递归写法</h2><p>递归代表深度优先搜索，所以对于这道题要求的bottom比较好把握，只要维护一个最深深度就行了，对于left，就要在递归逻辑上把握</p><ul><li>当遇到叶子节点，根据深度判断是否维护，注意一定是深度比当前大才维护，不能相等</li><li>当遇到分支节点，先走左再走右</li></ul><p>为什么先走左就能保证最底最左？</p><p>最底可以保证，最左就是第一个遇到，而维护时只维护更深的，就意味着当前答案就是当前深度中第一个遇到的、最左的节点，所以最左也可以保证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; ans = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">findBottomLeftValueHelp</span>(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans.first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findBottomLeftValueHelp</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            <span class="hljs-keyword">if</span>(depth &gt; ans.second) ans = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&#123;root-&gt;val, depth&#125;;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;left) <span class="hljs-built_in">findBottomLeftValueHelp</span>(root-&gt;left, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">findBottomLeftValueHelp</span>(root-&gt;right, depth + <span class="hljs-number">1</span>);<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代写法">迭代写法</h2><p>代表广度优先搜索，或者层序遍历，由于每层从左向右，所以left好把握，对于bottom就要多写点逻辑来把握</p><p>遍历每行时，若遇到叶子节点，则跳过对该层后面节点的判断，仅仅只入队后面节点的子节点，这样就保证了最左。如果队中还有元素，则说明还有更深，继续寻找，最后就会得到答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> ans = root-&gt;val;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>                TreeNode * cur = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                <span class="hljs-keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;<br>                    ans = cur-&gt;val;<br>                    <span class="hljs-keyword">while</span>(++i &lt; size) &#123;<br>                        cur = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                        <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="路径总和">路径总和</h1><p>这题太适合深度优先搜索了，一条路走到头才能判断，那就一条一条走，正符合dfs。</p><p>代码比较简单，注意参数怎么传的，传参步骤减去当前节点值，最后判断是否刚好相等。而非从0加到叶子再判断是否等于target，虽然空间复杂度没变，但是少一个变量更简洁一点</p><p>具体代码不贴，与下一题类似，可同理理解</p><h1 id="路径综合ii">路径综合II</h1><p>仍然是深度优先搜索，只是多了保存答案的步骤，也不难</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">path</span>(root, targetSum, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(), ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">path</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> targetSum, vector&lt;<span class="hljs-type">int</span>&gt; temp, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == targetSum) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        temp.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(root-&gt;left) <span class="hljs-built_in">path</span>(root-&gt;left, targetSum - root-&gt;val, temp, ans);<br>        <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">path</span>(root-&gt;right, targetSum - root-&gt;val, temp, ans);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="从中序和后序构造二叉树">从中序和后序构造二叉树</h1><h2 id="递归写法-1">递归写法</h2><p>经典考题，递归写法核心思想为分割序列为子树的中序和后序，不断分割直到只剩一个，即是叶子节点</p><p>根据后序可以直接确定当前树的根节点，然后在中序中定位左右子树的中序，最后将左右子树的中序和后需继续下传，返回当前根节点</p><p>分割序列采用vector的构造函数，使用迭代器分割</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> size = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> rootval = postorder[size - <span class="hljs-number">1</span>];<br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootval);<br>        <span class="hljs-type">int</span> split;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>            <span class="hljs-keyword">if</span>(inorder[i] == rootval) &#123;<br>                split = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; inleft = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(inorder.<span class="hljs-built_in">begin</span>(), inorder.<span class="hljs-built_in">begin</span>() + split);<br>        vector&lt;<span class="hljs-type">int</span>&gt; inright = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(inorder.<span class="hljs-built_in">begin</span>() + split + <span class="hljs-number">1</span>, inorder.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; postleft = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(postorder.<span class="hljs-built_in">begin</span>(), postorder.<span class="hljs-built_in">begin</span>() + split);<br>        vector&lt;<span class="hljs-type">int</span>&gt; postright = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(postorder.<span class="hljs-built_in">begin</span>() + split, postorder.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>);<br>        root-&gt;left = <span class="hljs-built_in">buildTree</span>(inleft, postleft);<br>        root-&gt;right = <span class="hljs-built_in">buildTree</span>(inright, postright);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="从前序和中序构造二叉树">从前序和中序构造二叉树</h1><h2 id="递归写法-2">递归写法</h2><p>与上一题同理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> rootval = preorder[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> split = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(split;split &lt; preorder.<span class="hljs-built_in">size</span>();split++) &#123;<br>            <span class="hljs-keyword">if</span>(inorder[split] == rootval) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootval);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftpre</span><span class="hljs-params">(preorder.begin() + <span class="hljs-number">1</span>, preorder.begin() + <span class="hljs-number">1</span> + split)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightpre</span><span class="hljs-params">(preorder.begin() + <span class="hljs-number">1</span> + split, preorder.end())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftin</span><span class="hljs-params">(inorder.begin(), inorder.begin() + split)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightin</span><span class="hljs-params">(inorder.begin() + split + <span class="hljs-number">1</span>, inorder.end())</span></span>;<br>        root-&gt;left = <span class="hljs-built_in">buildTree</span>(leftpre, leftin);<br>        root-&gt;right = <span class="hljs-built_in">buildTree</span>(rightpre, rightin);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代写法-1">迭代写法</h2><p>迭代写法思维很巧妙，官方题解写得很严谨，我直接摘抄并加入自己的注解 ：<span class="label label-success">注解格式</span></p><p><ahref="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">原文链接</a></p><p>对于前序遍历中的任意两个连续节点 <code>u</code> 和<code>v</code>，根据前序遍历的流程，我们可以知道 <code>u</code> 和<code>v</code> 只有两种可能的关系：</p><p><code>v</code> 是 <code>u</code> 的左儿子。这是因为在遍历到<code>u</code> 之后，下一个遍历的节点就是 <code>u</code> 的左儿子，即<code>v</code>；</p><p><code>u</code> 没有左儿子，并且 <code>v</code> 是 <code>u</code>的某个祖先节点（或者 <code>u</code> 本身）的右儿子。 <span class="label label-success">可以自己画几个树来验证</span> ​</p><p>举一个例子来说明第二种关系的正确性，并在例子中给出我们的迭代算法。</p><p><strong>例子</strong>:</p><p>我们以树 <figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">        3<br>       / \<br>     <span class="hljs-number"> 9 </span> 20<br>     /  /  \<br>   <span class="hljs-number"> 8 </span><span class="hljs-number"> 15 </span>  7<br>   / \<br> <span class="hljs-number"> 5 </span> 10<br> /<br>4<br></code></pre></td></tr></table></figure> 为例，它的前序遍历和中序遍历分别为</p><p>preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]</p><p>inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]</p><p>我们用一个栈 <code>stack</code>来维护「<strong>当前节点的所有还没有考虑过右儿子的祖先节点</strong>」<span class="label label-success">栈内的元素无论何时都是这一含义，视作未判断过是不是有右孩子的节点</span>，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针<code>index</code> 指向中序遍历的某个位置，初始值为<code>0</code>。<code>index</code>对应的节点是「<strong>当前节点不断往左走达到的最终节点</strong>」，这也是符合中序遍历的，它的作用在下面的过程中会有所体现。</p><p>首先我们将根节点 <code>3</code> 入栈，再初始化 <code>index</code>所指向的节点为<code>4</code>，随后对于前序遍历中的每个节点，我们依次判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p><p>我们遍历 <code>9</code>。<code>9</code> 一定是栈顶节点 <code>3</code>的左儿子。我们使用反证法，假设 <code>9</code> 是 <code>3</code>的右儿子，那么 <code>3</code> 没有左儿子，<code>index</code>应该恰好指向 <code>3</code>，但实际上为<code>4</code>，因此产生了矛盾。所以我们将 <code>9</code> 作为<code>3</code> 的左儿子，并将 <code>9</code> 入栈。</p><p><code>stack = [3, 9]</code></p><p><code>index -&gt; inorder[0] = 4</code></p><p>我们遍历 <code>8</code>，<code>5</code> 和<code>4</code>。同理可得它们都是上一个节点（栈顶节点）的左儿子，所以它们会依次入栈。</p><p><code>stack = [3, 9, 8, 5, 4]</code></p><p><code>index -&gt; inorder[0] = 4</code></p><p>我们遍历 <code>10</code>，这时情况就不一样了。我们发现<code>index</code> 恰好指向当前的栈顶节点 <code>4</code>，也就是说<code>4</code> 没有左儿子，那么 <code>10</code>必须为栈中某个节点的右儿子。那么如何找到这个节点呢？栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的。<span class="label label-success">z左中右与中左右，其中“中”和“左”是相反的</span></p><blockquote><p>这是因为栈中的任意两个相邻的节点，前者都是后者的某个祖先。并且我们知道，栈中的任意一个节点的右儿子还没有被遍历过，说明后者一定是前者左儿子的子树中的节点，那么后者就先于前者出现在中序遍历中。</p></blockquote><p>因此我们可以把 <code>index</code>不断向右移动，并与栈顶节点进行比较。如果 <code>index</code>对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了栈顶节点，所以将<code>index</code> 增加 <code>1</code> 并弹出栈顶节点，直到<code>index</code>对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后一个节点<code>x</code> 就是 <code>10</code> 的双亲节点，这是因为 <code>10</code>出现在了 <code>x</code> 与 <code>x</code>在栈中的下一个节点的中序遍历之间，因此 <code>10</code> 就是<code>x</code> 的右儿子。</p><p>回到我们的例子，我们会依次从栈顶弹出 <code>4</code>，<code>5</code>和 <code>8</code>，并且将 <code>index</code> 向右移动了三次。我们将<code>10</code> 作为最后弹出的节点 <code>8</code>的右儿子<span class="label label-success">栈中没有考虑右孩子</span>，并将 <code>10</code> 入栈。</p><p><code>stack = [3, 9, 10]</code></p><p><code>index -&gt; inorder[3] = 10</code></p><p>我们遍历 <code>20</code>。同理，<code>index</code>恰好指向当前栈顶节点 <code>10</code>，那么我们会依次从栈顶弹出<code>10</code>，<code>9</code> 和 <code>3</code>，并且将<code>index</code> 向右移动了三次。我们将 <code>20</code>作为最后弹出的节点 <code>3</code> 的右儿子，并将 <code>20</code>入栈。</p><p><code>stack = [20]</code></p><p><code>index -&gt; inorder[6] = 15</code></p><p>我们遍历 <code>15</code>，将 <code>15</code> 作为栈顶节点<code>20</code> 的左儿子，并将 <code>15</code> 入栈。</p><p><code>stack = [20, 15]</code></p><p><code>index -&gt; inorder[6] = 15</code></p><p>我们遍历 <code>7</code>。<code>index</code> 恰好指向当前栈顶节点<code>15</code>，那么我们会依次从栈顶弹出 <code>15</code> 和<code>20</code>，并且将 <code>index</code> 向右移动了两次。我们将<code>7</code> 作为最后弹出的节点 <code>20</code> 的右儿子，并将<code>7</code> 入栈。</p><p><code>stack = [7]</code></p><p><code>index -&gt; inorder[8] = 7</code></p><p>此时遍历结束，我们就构造出了正确的二叉树。</p><p><strong>算法</strong></p><p>我们归纳出上述例子中的算法流程：</p><ul><li><p>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p></li><li><p>我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果<code>index</code>恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动<code>index</code>，并将当前节点作为最后一个弹出的节点的右儿子；如果<code>index</code>和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</p></li></ul><p>无论是哪一种情况，我们最后都将当前的节点入栈。</p><p><strong>代码</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!preorder.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        stack&lt;TreeNode*&gt; stk;<br>        stk.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> inorderIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; preorder.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> preorderVal = preorder[i];<br>            TreeNode* node = stk.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;val != inorder[inorderIndex]) &#123;<br>                node-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorderVal);<br>                stk.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>()-&gt;val == inorder[inorderIndex]) &#123;<br>                    node = stk.<span class="hljs-built_in">top</span>();<br>                    stk.<span class="hljs-built_in">pop</span>();<br>                    ++inorderIndex;<br>                &#125;<br>                node-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorderVal);<br>                stk.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day17</title>
    <link href="/2024/06/07/leetcode-day17/"/>
    <url>/2024/06/07/leetcode-day17/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/balanced-binary-tree/description/">110.平衡二叉树</a></li><li><a href="https://leetcode.cn/problems/binary-tree-paths/">257.二叉树的所有路径</a></li><li><ahref="https://leetcode.cn/problems/sum-of-left-leaves/description/">404.左叶子之和</a></li></ul><h1 id="平衡二叉树">平衡二叉树</h1><p>只是判断平衡二叉树，比较简单，按规范化思路来吧，避免一会有感觉秒了，一会没感觉卡了</p><p>递归结束条件：如果左子树不是平衡二叉树 或者 右子树不是平衡二叉树 或者左右子树深度差距大于1</p><p>递归操作：判断左子树是不是平衡二叉树，判断右子树是不是平衡二叉树，获取左右子树深度</p><p>参数及返回值：根节点 + 是否合法的bool值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//空视作平衡</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;right)) &#123;<span class="hljs-comment">//左右都是</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">getDepth</span>(root-&gt;left) - <span class="hljs-built_in">getDepth</span>(root-&gt;right)) &lt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//左右深度是否匹配</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//空树深度0</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getDepth</span>(root-&gt;left), <span class="hljs-built_in">getDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<span class="hljs-comment">//左右子树最大深度加自己</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个时间复杂度较大，<spanclass="math inline">\(O(n^2)\)</span>，对每一个节点都要单独求深度然后判断，自顶向下</p><p>自底向上做法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getDepth</span>(root) != <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">getDepth</span>(root-&gt;left);<br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//只要一个子树不平衡，整个树就不平衡</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">getDepth</span>(root-&gt;right);<br>    <span class="hljs-keyword">if</span>(right == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(left - right) &lt;= <span class="hljs-number">1</span> ? <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="二叉树的所有路径">二叉树的所有路径</h1><p>递归三步：</p><ol type="1"><li>参数&amp;返回值</li></ol><p>无需返回值，参数有根节点和存路径和答案的数组</p><ol start="2" type="1"><li>递归终止条件</li></ol><p>遇到叶节点</p><ol start="3" type="1"><li>递归逻辑</li></ol><p>没遇到就接着往里插</p><p>比较简单，贴代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        string line;<br>        <span class="hljs-built_in">traversal</span>(root, line);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode * root, string s)</span> </span>&#123;<br>        s += <span class="hljs-built_in">to_string</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) ans.<span class="hljs-built_in">push_back</span>(s);<br>        <span class="hljs-keyword">else</span> &#123;<br>            s += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>            <span class="hljs-keyword">if</span>(root-&gt;left) <span class="hljs-built_in">traversal</span>(root-&gt;left, s);<br>            <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">traversal</span>(root-&gt;right, s);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h2 id="迭代写法">迭代写法</h2><p>用一个栈存节点，一个栈存目前已经走过的路径注意push根节点和其他节点的差异</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        stack&lt;string&gt; path;<br>        stack&lt;TreeNode *&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        path.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">to_string</span>(root-&gt;val));<span class="hljs-comment">//only value</span><br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode * cur = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>            string tem = path.<span class="hljs-built_in">top</span>(); path.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span>(cur-&gt;left) &#123;<br>                st.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                path.<span class="hljs-built_in">push</span>(tem + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">to_string</span>(cur-&gt;left-&gt;val));<span class="hljs-comment">//insert the next value</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur-&gt;right) &#123;<br>                st.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                path.<span class="hljs-built_in">push</span>(tem + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">to_string</span>(cur-&gt;right-&gt;val));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;<span class="hljs-comment">//no next value</span><br>                ans.<span class="hljs-built_in">push_back</span>(tem);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="左叶子之和">左叶子之和</h1><p>需要注意，单独一个根节点不能称作左叶子，只是叶子，但不左</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;<br>            ans = root-&gt;left-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个递归看得有点懵，后面再来仔细理解一下吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day16</title>
    <link href="/2024/06/06/leetcode-day16/"/>
    <url>/2024/06/06/leetcode-day16/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><p><ahref="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104.二叉树的最大深度</a></p></li><li><p><ahref="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/">559.n叉树的最大深度</a></p></li><li><p><ahref="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111.二叉树的最小深度</a></p></li><li><p><ahref="https://leetcode.cn/problems/count-complete-tree-nodes/description/">222.完全二叉树的节点个数</a></p></li></ul><h1 id="树的最大深度">树的最大深度</h1><p>最大深度指从根到所有节点的长度中最长的那一个，换言之就是要找离根最远的节点然后返回到它的长度。</p><p>用DFS和BFS都行，分别代表递归前后序遍历和层序遍历，对于n叉树而言，仅仅是多比较几次而已，改写难度不大</p><p>下附对于n叉树的bfs遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>    queue&lt;Node *&gt; q;<br>    <span class="hljs-keyword">if</span>(root) q.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>            Node * cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; cur-&gt;children.<span class="hljs-built_in">size</span>();j++) &#123;<br>                q.<span class="hljs-built_in">push</span>(cur-&gt;children[j]);<br>            &#125;<br>        &#125;<br>        ans++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的最小深度">二叉树的最小深度</h1><p>最小深度需要注意，是从根到最近的<strong>叶子节点</strong>的距离，<strong>叶子节点</strong>指没有左右孩子的节点</p><p>所以在遍历时需要注意结束条件，对于层序遍历则判断当前节点是否是叶子，如果是就维护最小深度</p><p>对于递归遍历则根据子节点个数来分类处理，如果左右双全或双无，则直接递归；如果只有一个，就单独递归</p><p>下附递归遍历代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">minDepth</span>(root-&gt;left);<br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">minDepth</span>(root-&gt;right);<br><br>    <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + right;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;right == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;left) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(left, right);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>留坑，lc的最快执行代码中在最后<code>return</code>前把<code>root</code>的左右都指<code>null</code>，意义不明，但是就是快，没想出来为什么</em></p><h1 id="完全二叉树的节点个数">完全二叉树的节点个数</h1><p>用普通二叉树的遍历当然能做，只是不太好，还是用好完全二叉树的特性：<strong>非底层全满，底层从左往右堆</strong></p><p>所以完全二叉树的左右子树深度肯定是一样的，如果不一样，那么再递归，直到递归到完全二叉树或者细粒度足够小时的空节点</p><p>代码贴的carl的，原文链接：<ahref="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录| 完全二叉树的节点个数</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    TreeNode* left = root-&gt;left;<br>    TreeNode* right = root-&gt;right;<br>    <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里初始为0是有目的的，为了下面求指数方便</span><br>    <span class="hljs-keyword">while</span> (left) &#123;  <span class="hljs-comment">// 求左子树深度</span><br>        left = left-&gt;left;<br>        leftDepth++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (right) &#123; <span class="hljs-comment">// 求右子树深度</span><br>        right = right-&gt;right;<br>        rightDepth++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (leftDepth == rightDepth) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day15</title>
    <link href="/2024/06/05/leetcode-day15/"/>
    <url>/2024/06/05/leetcode-day15/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102.层序遍历</a><br /></li><li><ahref="https://leetcode.cn/problems/invert-binary-tree/">226.翻转二叉树</a><br /></li><li><ahref="https://leetcode.cn/problems/symmetric-tree/">101.对称二叉树</a></li></ul><h1 id="层序遍历">层序遍历</h1><p>思路就是用队列记录逐层，这样顺序不会变。进入一层时最好记录队列初长度，然后根据长度遍历该层，避免根据队列是否空而判断该层是否遍历结束，便于即时将子节点入队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    TreeNode * cur = root;<br>    queue&lt;TreeNode*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(cur);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            temp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span> (cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(temp);<br>        temp.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="翻转二叉树">翻转二叉树</h1><p>递归版比较简单，太过简单，所以skip</p><p>迭代版就看作在遍历，而且是前序遍历那种单循环，出栈后把左右节点交换，然后压栈左右节点继续就行，给出循环部分的核心代码<del>本来就是核心代码模式，又再核心……</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>    TreeNode* node = st.<span class="hljs-built_in">top</span>();              <span class="hljs-comment">// 中</span><br>    st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>    <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);   <span class="hljs-comment">// 右</span><br>    <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);     <span class="hljs-comment">// 左</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对称二叉树">对称二叉树</h1><p>递归版很简单，写一个辅助函数判断左右节点是不是相等，是树就接着递归，然后从根开始对每一个分支节点的左右孩子判断就行<br />代码没写，偷了个懒😜</p><p>迭代版要难一点，仅限于手写层面，思路不难</p><p>迭代需要用队列或者栈等来存，但是不是按左右顺序挨个入队，而是左右<strong>对应交替</strong>入队，这样方便判断是否相等</p><p>下附carl的漂亮含注释代码，<ahref="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">carl原文链接</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root-&gt;left);   <span class="hljs-comment">// 将左子树头结点加入队列</span><br>        que.<span class="hljs-built_in">push</span>(root-&gt;right);  <span class="hljs-comment">// 将右子树头结点加入队列</span><br>        <br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">// 接下来就要判断这两个树是否相互翻转</span><br>            TreeNode* leftNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            TreeNode* rightNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;  <span class="hljs-comment">// 左节点为空、右节点为空，此时说明是对称的</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span><br>            <span class="hljs-keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;left);   <span class="hljs-comment">// 加入左节点左孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;right); <span class="hljs-comment">// 加入右节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;right);  <span class="hljs-comment">// 加入左节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;left);  <span class="hljs-comment">// 加入右节点左孩子</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day14</title>
    <link href="/2024/06/04/leetcode-day14/"/>
    <url>/2024/06/04/leetcode-day14/</url>
    
    <content type="html"><![CDATA[<p>今日内容：<br />- 递归遍历<br />- 迭代遍历<br />- 统一迭代</p><p>三道例题：</p><p><ahref="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">前序遍历二叉树</a><br /><ahref="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">中序遍历二叉树</a><br /><ahref="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">后续遍历二叉树</a></p><h1 id="递归遍历">递归遍历</h1><p>太过简单，skip</p><h1 id="迭代遍历非统一版">迭代遍历（非统一版）</h1><p>使用栈模拟递归过程：</p><p>前序就是先访问当前节点值，然后压栈右左孩子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    stack&lt;TreeNode*&gt; st;<br>    TreeNode * cur = root;<br>    st.<span class="hljs-built_in">push</span>(cur);<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        cur = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        <span class="hljs-keyword">if</span>(cur-&gt;right) st.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left) st.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>中序就是先存所有左节点，直到遇<code>null</code>再出栈栈顶，访问值后压栈右节点（压栈的所有节点均不为空）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    stack&lt;TreeNode*&gt; st;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    TreeNode * cur = root;<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(cur);<br>            cur = cur-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cur = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>后序比较讨巧，左右中倒序就是中右左，把前序的压栈顺序调换，最后翻转结果就行，就不贴代码了</p><h1 id="统一迭代遍历">统一迭代遍历</h1><p>形式统一的迭代遍历，主要思想是压栈<code>null</code>来<strong>标记</strong>下一个节点需要访问，这样写出来的代码在压栈部分就可以只调换顺序实现三种遍历</p><p>个人感觉比较好理解，最好记住写法，下面以后序为例给出代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; st;<br>    TreeNode * cur = root;<br>    <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)st.<span class="hljs-built_in">push</span>(cur);<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        cur = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br><br>            st.<span class="hljs-built_in">push</span>(cur);<br>            st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-comment">//中</span><br><br>            <span class="hljs-keyword">if</span>(cur-&gt;right) st.<span class="hljs-built_in">push</span>(cur-&gt;right);<span class="hljs-comment">//右</span><br><br>            <span class="hljs-keyword">if</span>(cur-&gt;left) st.<span class="hljs-built_in">push</span>(cur-&gt;left);<span class="hljs-comment">//左</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>            cur = st.<span class="hljs-built_in">top</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day13</title>
    <link href="/2024/06/03/leetcode-day13/"/>
    <url>/2024/06/03/leetcode-day13/</url>
    
    <content type="html"><![CDATA[<p>今日内容：</p><ul><li><ahref="https://leetcode.cn/problems/sliding-window-maximum/description/">239.滑动窗口最大值</a></li><li><a href="">347.前 K 个高频元素</a></li></ul><h1 id="滑动窗口最大值">239.滑动窗口最大值</h1><p>考验对于<code>priority_queue</code>数据结构的了解和掌握程度，不过不能当API选手，得知道怎么手写堆，不求随手手撕出大小顶堆，但是得知道大概写法。</p><h2id="关于priority_queue的感性理解">关于<code>priority_queue</code>的感性理解</h2><p>在lc上看见了评论区大佬，关于<code>priority_queue</code>的比喻描述很形象，特引用至此：</p><blockquote><p>单调队列真是一种让人感到五味杂陈的数据结构，它的维护过程更是如此.....就拿此题来说，队头最大，往队尾方向单调......有机会站在队头的老大永远心狠手辣，当它从队尾杀进去的时候，如果它发现这里面没一个够自己打的，它会毫无人性地屠城，把原先队里的人头全部丢出去，转身建立起自己的政权，野心勃勃地准备开创一个新的王朝.....这时候，它的人格竟发生了一百八十度大反转，它变成了一位胸怀宽广的慈父！它热情地请那些新来的“小个子”们入住自己的王国......然而，这些小个子似乎天性都是一样的——嫉妒心强，倘若见到比自己还小的居然更早入住王国，它们会心狠手辣地找一个夜晚把它们通通干掉，好让自己享受更大的“蛋糕”；当然，遇到比自己强大的，它们也没辙，乖乖夹起尾巴做人。像这样的暗杀事件每天都在上演，虽然王国里日益笼罩上白色恐怖，但是好在没有后来者强大到足以干翻国王，江山还算能稳住。直到有一天，闯进来了一位真正厉害的角色，就像当年打江山的国王一样，手段狠辣，野心膨胀，于是又是大屠城......历史总是轮回的。</p></blockquote><p>似乎没办法贴评论的链接，去description下找吧，应该挺靠前的。</p><p>叛军屠城 = 遇到新最值，<strong>全弹出</strong>; 慈悲为怀 =后续小值有序堆在队头之后;</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; pq;<span class="hljs-comment">//存pair，得带上值得下标方便确定是不是该出队</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">empty</span>()) pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<span class="hljs-comment">//空的直接存</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] &gt;= pq.<span class="hljs-built_in">top</span>().first) &#123;<span class="hljs-comment">//新最值，全出队</span><br>                <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>()) pq.<span class="hljs-built_in">pop</span>();<br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &gt;= k) &#123;<span class="hljs-comment">//已满</span><br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<br>                <span class="hljs-keyword">while</span>(pq.<span class="hljs-built_in">top</span>().second + k &lt;= i)<span class="hljs-comment">//出队已经晚了的,注意得是while</span><br>                    pq.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(nums[i], i));<br>            <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &gt;= k) ans.<span class="hljs-built_in">push_back</span>(pq.<span class="hljs-built_in">top</span>().first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="前k个高频元素">347.前k个高频元素</h1><p>感觉思路比较简单暴力，用map来记“值-频率”，然后根据“频率数组”建堆排序来降低时间复杂度到O(nlogn)以下。总之是先记再排序。</p><p>不过carl的反其道而行很巧妙，采用小根堆，这样就可以简单地根据队列盈满来出队队头，官解也是小根堆，不过没有简单出队，而是判断当前的和队头的哪个更小，如果队头更小才出队。</p><p>对于pq自定义排序标准的语法不了解，是看过之后才写的，对于这道题</p><p><code>priority_queue</code>的模板类型参数有三，1.要存的类型；2.要存的类型的vector；3.自定义比较方法所在类，自定义比较需重载<code>()</code>运算符</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">cmp</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//用map记录值-频率，通过优先队列或者堆来对前k个频率排序，最后输出前k个元素</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) map[i]++;<br><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, cmp&gt; pq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : map) &#123;<br>            pq.<span class="hljs-built_in">push</span>(it);<br>            <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &gt; k) pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span> (k--)&#123;<br>            <span class="hljs-type">int</span> t = pq.<span class="hljs-built_in">top</span>().first;<br>            ans.<span class="hljs-built_in">push_back</span>(t);<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day11</title>
    <link href="/2024/06/01/leetcode-day11/"/>
    <url>/2024/06/01/leetcode-day11/</url>
    
    <content type="html"><![CDATA[<p>今日内容： - <ahref="https://leetcode.cn/problems/valid-parentheses/description/">20.有效的括号</a><br />- <ahref="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">1047.删除字符串中所有相邻重复项</a><br />- <ahref="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150.逆波兰表达式求值</a></p><h1 id="有效的括号">20.有效的括号</h1><p>其实这题跟最后一个逆波兰表达式有关，最后一题是逆波兰表达式求值，但是根据中缀表达式生成逆波兰表达式的算法里就会用到栈来处理中缀中的括号问题。</p><p>所以一个栈直接秒了，思路打开，碰到左括号别傻傻push左括号，而得push右括号，这样就可以直接判断<code>top()</code>了，而不用碰到右括号的时候再来个转换。</p><p><del>没错，我这次就push的左括号，碰到右括号的时候还用ASCII码去算对应的左括号值</del></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stack&lt;<span class="hljs-type">char</span>&gt; b;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) b.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) b.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span>) b.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b.<span class="hljs-built_in">empty</span>() || s[i] != b.<span class="hljs-built_in">top</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> b.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> b.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除字符串中所有相邻重复项">1047.删除字符串中所有相邻重复项</h1><p>如果不告诉用栈做的话，貌似还挺复杂的，不过用栈就很简单了</p><p>压栈前判断栈顶是不是重复，重复就pop，不重复就push，建议从尾到头遍历s，这样全pop出来时顺序还是对的。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(;i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() != s[i]) st.<span class="hljs-built_in">push</span>(s[i]);<br>            <span class="hljs-keyword">else</span> st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        string ans;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;!st.<span class="hljs-built_in">empty</span>();i++) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(st.<span class="hljs-built_in">top</span>());<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="逆波兰表达式求值">105.逆波兰表达式求值</h1><p>笔者大一下的Qt课设就是写一个大数计算器，对这逆波兰表达式还是比较熟悉，有了式子，求值就比较简单了，这个题还确保了int不炸。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; tokens.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;+&quot;</span> || tokens[i] == <span class="hljs-string">&quot;-&quot;</span> || tokens[i] == <span class="hljs-string">&quot;*&quot;</span> || tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>                <span class="hljs-type">int</span> num1 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> num2 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;+&quot;</span>) st.<span class="hljs-built_in">push</span>(num1 + num2);<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;-&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 - num1);<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;*&quot;</span>) st.<span class="hljs-built_in">push</span>(num1 * num2);<br>                <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 / num1);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(tokens[i]));<br>        &#125;<br>        <span class="hljs-type">int</span> res = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day10</title>
    <link href="/2024/05/31/leetcode-day10/"/>
    <url>/2024/05/31/leetcode-day10/</url>
    
    <content type="html"><![CDATA[<p>此帖仅作打卡用，过于简单，建议跳过</p><h1 id="用栈实现队列"><ahref="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232.用栈实现队列</a></h1><p>根据题意，用俩栈来回倒就行</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; q1;<br>    stack&lt;<span class="hljs-type">int</span>&gt; q2;<br>    <span class="hljs-built_in">MyQueue</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q2.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> pipe = q2.<span class="hljs-built_in">top</span>();<br>            q2.<span class="hljs-built_in">pop</span>();<br>            q1.<span class="hljs-built_in">push</span>(pipe);<br>        &#125;<br>        q1.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> pipe = q1.<span class="hljs-built_in">top</span>();<br>            q1.<span class="hljs-built_in">pop</span>();<br>            q2.<span class="hljs-built_in">push</span>(pipe);<br>        &#125;<br>        <span class="hljs-type">int</span> ans = q2.<span class="hljs-built_in">top</span>();<br>        q2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> pipe = q1.<span class="hljs-built_in">top</span>();<br>            q1.<span class="hljs-built_in">pop</span>();<br>            q2.<span class="hljs-built_in">push</span>(pipe);<br>        &#125;<br>        <span class="hljs-keyword">return</span> q2.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">empty</span>() &amp;&amp; q2.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="用队列实现栈"><ahref="https://leetcode.cn/problems/implement-stack-using-queues/">225.用队列实现栈</a></h1><p>一个双端队列完事</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    deque&lt;<span class="hljs-type">int</span>&gt; d1;<br>    <span class="hljs-built_in">MyStack</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        d1.<span class="hljs-built_in">push_front</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> p = d1.<span class="hljs-built_in">front</span>();<br>        d1.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> d1.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> d1.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day6</title>
    <link href="/2024/05/30/leetcode-day6/"/>
    <url>/2024/05/30/leetcode-day6/</url>
    
    <content type="html"><![CDATA[<h1 id="有效的字母异位词"><ahref="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">有效的字母异位词</a></h1><p>哈希表新手题，不过可以直接排序再判断，剑走偏锋不用哈希</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() != t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> s == t;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="两个数组的交集"><ahref="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">两个数组的交集</a></h1><p>这个也可以排序然后双指针，不用哈希，时间复杂度 <spanclass="math inline">\(O(mlogm+nlogn)\)</span>，主要是排序的复杂度，空间复杂度<span class="math inline">\(O(mlogm+nlogn)\)</span> 也是排序造成的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> len1 = nums1.<span class="hljs-built_in">size</span>(), len2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> index1 = <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span>(index1 &lt; len1 &amp;&amp; index2 &lt; len2) &#123;<br>            <span class="hljs-keyword">if</span>(nums1[index1] == nums2[index2]) &#123;<br>                <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || nums1[index1] != ans.<span class="hljs-built_in">back</span>()) ans.<span class="hljs-built_in">push_back</span>(nums1[index1]);<br>                index1++;<br>                index2++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[index1] &lt; nums2[index2]) index1++;<br>            <span class="hljs-keyword">else</span> index2++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="快乐数"><ahref="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">快乐数</a></h1><p>这题和<ahref="https://leetcode.cn/problems/linked-list-cycle-ii/description/">环形链表II</a>有点异曲同工之妙，笔者的做法是用一个set来记录每次计算的结果，重复就false，等于1就true。</p><p>但看过评论区后发现，这样只是走了int限制的捷径，有可能会爆栈，所以不能记录，而应该采取环形链表中检查环的方法——追及问题。</p><p>用快慢指针，不过指的是计算结果，如果fast最终等于slow，则有环，false，这样空间复杂度就成了<spanclass="math inline">\(O(1)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitSquareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> bit = n % <span class="hljs-number">10</span>;<br>            sum += bit * bit;<br>            n = n / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slow = n, fast = n;<br>        <span class="hljs-keyword">do</span>&#123;<br>            slow = <span class="hljs-built_in">bitSquareSum</span>(slow);<br>            fast = <span class="hljs-built_in">bitSquareSum</span>(fast);<br>            fast = <span class="hljs-built_in">bitSquareSum</span>(fast);<br>        &#125;<span class="hljs-keyword">while</span>(slow != fast);<br>        <br>        <span class="hljs-keyword">return</span> slow == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><ahref="https://leetcode.cn/problems/happy-number/solutions/21454/shi-yong-kuai-man-zhi-zhen-si-xiang-zhao-chu-xun-h/">该题解来源</a></p><h1 id="两数之和"><ahref="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">两数之和</a></h1><p>思路还记得，用哈希来记录target -x，利用set查找的O(1)复杂度来优化查找过程。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">find</span>(target - nums[i]);<br>            <span class="hljs-keyword">if</span>(it != map.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> &#123;it-&gt;second, i&#125;;<br>            map[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="unordered_set">unordered_set</h1><ul><li>无序存储</li><li>元素独一无二，即键值key唯一</li></ul><p>## 常用方法</p><ul><li><code>unorder_set&lt;string&gt; first</code>容器定义</li><li><code>first.empty()</code>判断容器是否是空，是空返回<code>true</code>，反之为<code>false</code></li><li><code>first.size()</code>返回容器大小</li><li><code>first.maxsize()</code>返回容器最大尺寸</li><li><code>first.begin()</code>返回迭代器开始</li><li><code>first.end()</code>返回迭代器结束</li><li><code>first.find(value)</code>返回<code>value</code>在迭代器的位置，没找到会返回<code>end()</code></li><li><code>first.count(key)</code>返回key在容器的个数</li><li><code>first.insert(value)</code>将value插入到容器中</li><li><code>first.erase(key)</code>通过key删除</li><li><code>first.clear()</code>清空容器 <ahref="https://cplusplus.com/reference/unordered_map/unordered_map/">详细文档</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day4</title>
    <link href="/2024/05/30/leetcode-day4/"/>
    <url>/2024/05/30/leetcode-day4/</url>
    
    <content type="html"><![CDATA[<h1 id="两两交换链表中的节点"><ahref="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24.两两交换链表中的节点</a></h1><p>​链表貌似就是虚头+双指针+遍历，回到老家的感觉，注意对空节点的检查就好，题不难</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode * virhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        virhead-&gt;next = head;<br>        ListNode * left = virhead;<br>        ListNode * right = head;<br>        <span class="hljs-keyword">while</span>(right &amp;&amp; right-&gt;next) &#123;<br>            left-&gt;next = right-&gt;next;<br>            right-&gt;next = right-&gt;next-&gt;next;<br>            left-&gt;next-&gt;next = right;<br>            left = right;<br>            right = right-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> virhead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除链表的倒数第n个节点"><ahref="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19.删除链表的倒数第n个节点</a></h1><p>算脑筋急转弯吧，不过之前做过，已经没有难度了，思路就是让fast先走n步，再和slow一起走，这样fast走到最后slow就是倒数第n个了。</p><blockquote><p>​评论区在diss官解的“一次遍历”说法，去搜了一下，看见了宫水三叶前辈的帖，下为结论：</p><p>我们应该用「对数组的访问次数」来定义遍历多少次，而不是「利用 for循环的个数」来定义。 上述无论那种方法，对数组访问次数都是一样的。</p><p>出处：<ahref="https://developer.aliyun.com/article/905822">为什么「一次遍历」要比「两次遍历」慢（含小实验代码） | Java 刷题打卡-阿里云开发者社区 (aliyun.com)</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode * vir = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        vir-&gt;next = head;<br>        ListNode * fast = vir;<br>        ListNode * slow = vir;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        ListNode * t = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> t;<br>        <span class="hljs-keyword">return</span> vir-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="链表相交"><ahref="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">链表相交</a></h1><p>思路比较原始，都走一遍，把屁股对齐，长的先走几步把优势消耗，然后一起走找交点。</p><p>官解的追及思路更优雅，不过复杂度相同。<ahref="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solutions/1395092/lian-biao-xiang-jiao-by-leetcode-solutio-2kne/">官解</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode * vir = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        vir-&gt;next = head;<br>        ListNode * fast = vir;<br>        ListNode * slow = vir;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        ListNode * t = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> t;<br>        <span class="hljs-keyword">return</span> vir-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="环形链表ii"><ahref="https://leetcode.cn/problems/linked-list-cycle-ii/description/">环形链表II</a></h1><p>数学题，刚开始没推出来，注意把环分成走过的b段和没走过的c段，这样就很直观了，贴个图帮助理解</p><figure><img src="https://s3.bmp.ovh/imgs/2024/05/31/868052041ecc7ee9.jpg"alt="环形链表示意图" /><figcaption aria-hidden="true">环形链表示意图</figcaption></figure><p><em>公式中a对应图中x，y对应b，z对应c</em></p><p>求的是a，slow被碰到时离入口还差c，所以此时再来个指针从头开始一起走，碰到的时候刚好就是等式两边，即入口。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode * fast = head;<br>        ListNode * slow = head;<br>        <span class="hljs-keyword">while</span>(fast) &#123;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(!fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast == slow) &#123;<br>                ListNode * ans = head;<br>                <span class="hljs-keyword">while</span>(ans != slow) &#123;<br>                    ans = ans-&gt;next;<br>                    slow = slow-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>不太难，链表问题不大，注意空指针检查就行。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day3</title>
    <link href="/2024/05/30/leetcode-day3/"/>
    <url>/2024/05/30/leetcode-day3/</url>
    
    <content type="html"><![CDATA[<h1 id="移除链表元素"><ahref="https://leetcode.cn/problems/remove-linked-list-elements/description/">203.移除链表元素</a></h1><p>看见链表跟回家一样，大一走来就研究链表，被<code>-&gt;</code>和<code>.</code>的用法confuse了好久，然后链表操作信手拈来，现在实现个线性表、栈、队列都是拿链表来实现，数组都不会写了……</p><p>题很简单，拿java练练语法好了，就连java都是一把过： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        h.next = head;<br>        ListNode cur = h;<br>        <span class="hljs-keyword">while</span>(cur.next != null) &#123;<br>            <span class="hljs-keyword">if</span>(cur.next.val == val) &#123;<br>                cur.next = cur.next.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>                cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="设计链表"><ahref="https://leetcode.cn/problems/design-linked-list/description/">707.设计链表</a></h1><p>群友遇到问题，跟着debug了一会，本来不想做的，给出修改后的群友代码吧，收获也有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(index--)<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; index;i++)<br></code></pre></td></tr></table></figure><p>就是这上面俩是等效的，不够之前知道，算加深印象吧，毕竟while(index--)这样的写法不常见，但是字少。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;<br>        <span class="hljs-type">int</span> val;<br>        LNode* next;<br>        <span class="hljs-built_in">LNode</span>(<span class="hljs-type">int</span> v):<span class="hljs-built_in">val</span>(v),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125; <span class="hljs-comment">//构造函数</span><br>       <span class="hljs-comment">// LNode(int v)&#123; val=v,next=nullptr;&#125;</span><br>    &#125;;<br>    <span class="hljs-built_in">MyLinkedList</span>() &#123;<br>        <span class="hljs-comment">//建立空链表</span><br>        lsize=<span class="hljs-number">0</span>;<br>        lhead=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;=lsize) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        LNode* p=lhead;<br>        <span class="hljs-comment">//从第一个实际数据开始遍历，当循环结束，一定是p指向了Index位置</span><br>        <span class="hljs-keyword">while</span>(index--)<br>            p=p-&gt;next;<br>        p=p-&gt;next;<br>        <span class="hljs-keyword">return</span> p-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//将val插入作为第一个节点，即头结点的下一个</span><br>        LNode* np=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(val);<br>        np-&gt;next=lhead-&gt;next;<br>        lhead-&gt;next=np;<br>        lsize++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//在最后增加节点</span><br>        LNode* np=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(val);<br>        LNode* p=lhead;<br>        <span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            p=p-&gt;next;<br>        &#125;<br>        np-&gt;next=p-&gt;next;<br>        p-&gt;next=np;<br>        lsize++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&gt;lsize) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(index == lsize) &#123;<br>            <span class="hljs-built_in">addAtTail</span>(val);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        LNode* np=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LNode</span>(val);<br>        LNode* p=lhead;<br>        <span class="hljs-keyword">while</span>(index--)<br>            p=p-&gt;next;<br>        np-&gt;next=p-&gt;next;<br>        p-&gt;next=np;<br>        lsize++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;=lsize) <span class="hljs-keyword">return</span>;<br>        LNode* p=lhead;<br>        <span class="hljs-keyword">while</span>(index--)<br>            p=p-&gt;next;<br>        LNode* tmp=p-&gt;next;<br>           p-&gt;next=p-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        lsize--;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> lsize;<br>    LNode* lhead;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="反转链表"><ahref="https://leetcode.cn/problems/reverse-linked-list/description/">206.反转链表</a></h1><p>主要看了下递归做法，对于递归还是很迷，这次也没有一次写出来。</p><p>将后续部分看作已经反转完成，所以当前节点的下一个节点的下一个应该变成当前，即：</p><p><code>cur-&gt;next-&gt;next = cur;</code></p><p>对于头节点，再加一个next指null，就完成了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode * virHead = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> virHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day8</title>
    <link href="/2024/05/29/leetcode_day8/"/>
    <url>/2024/05/29/leetcode_day8/</url>
    
    <content type="html"><![CDATA[<h1 id="反转字符串ii"><ahref="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">反转字符串II</a></h1><p>按题意模拟即可，重写reverse方法，方便直接根据下标反转<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i += k) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span>*k == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">reverse</span>(s, begin, i / <span class="hljs-number">2</span>);<br>                begin = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= end) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">while</span>(begin &lt; end)&#123;<br>            <span class="hljs-type">char</span> c = s[begin];<br>            s[begin] = s[end];<br>            s[end] = c;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="替换数字"><ahref="https://programmercarl.com/kama54.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html">替换数字</a></h1><p>预先扩充好空间，然后<strong>从后向前</strong>扫描 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>        <span class="hljs-type">int</span> sOldIndex = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计数字的个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 扩充字符串s的大小，也就是将每个数字替换成&quot;number&quot;之后的大小</span><br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + count * <span class="hljs-number">5</span>);<br>        <span class="hljs-type">int</span> sNewIndex = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 从后往前将数字替换为&quot;number&quot;</span><br>        <span class="hljs-keyword">while</span> (sOldIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (s[sOldIndex] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[sOldIndex] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;r&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;e&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;m&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;u&#x27;</span>;<br>                s[sNewIndex--] = <span class="hljs-string">&#x27;n&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                s[sNewIndex--] = s[sOldIndex];<br>            &#125;<br>            sOldIndex--;<br>        &#125;<br>        cout &lt;&lt; s &lt;&lt; endl;       <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="反转单词"><ahref="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">反转单词</a></h1><p>思路比较巧，全部反转，然后再反转单词，这样就得到了词序反转，注意删除空格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">auto</span> it1 = s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">auto</span> it2 = s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(it2 != s.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">while</span>(*it2 != <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; it2 != s.<span class="hljs-built_in">end</span>()) it2++;<br>            <span class="hljs-built_in">reverse</span>(it1, it2);<br>            <span class="hljs-keyword">while</span>(*it2 == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; it2 != s.<span class="hljs-built_in">end</span>()) it2++;<br>            it1 = it2;<br>        &#125;<br>        it1=s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(it1!=s.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(it1==s.<span class="hljs-built_in">begin</span>() &amp;&amp; *it1 == <span class="hljs-string">&#x27; &#x27;</span>) s.<span class="hljs-built_in">erase</span>(it1);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*it1 == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; *<span class="hljs-built_in">next</span>(it1) == <span class="hljs-string">&#x27; &#x27;</span>) s.<span class="hljs-built_in">erase</span>(it1);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">next</span>(it1) == s.<span class="hljs-built_in">end</span>() &amp;&amp; *it1 == <span class="hljs-string">&#x27; &#x27;</span>) s.<span class="hljs-built_in">erase</span>(it1);<br>            <span class="hljs-keyword">else</span> it1++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="右旋字符串"><ahref="https://programmercarl.com/kama55.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html">右旋字符串</a></h1><p>思路与反转单词差不多，整体局部反转活用就行 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    string s;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//获取长度</span><br><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 整体反转</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + n); <span class="hljs-comment">// 先反转前一段，长度n</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + n, s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 再反转后一段</span><br><br>    cout &lt;&lt; s &lt;&lt; endl;<br><br>&#125; <br></code></pre></td></tr></table></figure>字符串和数组很像，后面的<spanclass="math inline">\(KMP\)</span>上难度，前面的比较简单，略过即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day7</title>
    <link href="/2024/05/28/leetcode_day7/"/>
    <url>/2024/05/28/leetcode_day7/</url>
    
    <content type="html"><![CDATA[<h1 id="四数相加"><ahref="https://leetcode.cn/problems/4sum-ii/description/">454.四数相加</a></h1><blockquote><p>视频讲解: <ahref="https://www.bilibili.com/video/BV1Md4y1Q7Yh/">学透哈希表，map使用有技巧！LeetCode：454.四数相加II</a></p><p>文章讲解：<ahref="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html">454.四数相加</a></p></blockquote><p>之前做过，知道用map，但是太久没用过map，一时间不知道怎么用map，干瞪眼十几分钟，最后看了题解，思路有，但是map的用法限制了我……</p><h2id="unordered_map怎么在算法题中使用">unordered_map怎么在算法题中使用</h2><p>unordered_map是std命名空间下的，所以自己写ACM模式的时候记得加<code>std::</code></p><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td><code>map</code></td><td>红黑树</td><td>key有序</td><td>key不重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td><code>multimap</code></td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td><code>unordered_map</code></td><td>哈希表</td><td>key无序</td><td>key不重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>由该表能看出，unordered_map查找的效率最高，但是内部元素无序</p><p>适用于：当作记录型变量用于需要多次查找的场合</p><p><strong>创建unordered_map</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//注意给出两个模板类型变量</span><br>unordered_map&lt;type1, type2&gt; map;<br><span class="hljs-comment">//设定初值方法</span><br>unordered_map&lt;t1, t2&gt; map = &#123;&#123;key1, value1&#125;, &#123;key2, value2&#125;, ……&#125;;<br>vector&lt;pair&lt;t1, t2&gt;&gt; v = &#123;&#123;key1, value1&#125;, &#123;key2, value2&#125;, ……&#125;;  <br><span class="hljs-comment">//使用既有pair数组初始化</span><br><span class="hljs-function">unordered_map&lt;<span class="hljs-type">int</span>, string&gt; <span class="hljs-title">map</span><span class="hljs-params">(v.begin(), v.end())</span></span>;<br></code></pre></td></tr></table></figure><p><strong>插入一个元素进map</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果要记录的是&lt;key, value&gt;</span><br>map[key] = value;<br><span class="hljs-comment">//或者复杂点</span><br>map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;type1, type2&gt;(key, value));<br><span class="hljs-comment">//如果记录key出现几次</span><br>map[key]++;<span class="hljs-comment">//[]被重载过，即使没有key也会创建一个并赋值1</span><br></code></pre></td></tr></table></figure><p><strong>map的迭代器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用迭代器访问key和value</span><br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map;<br><span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">begin</span>();<br>it-&gt;first = key;<span class="hljs-comment">//it视作一个pair&lt;int, string&gt;元素，用-&gt;访问key和value</span><br>it-&gt;second = value;<span class="hljs-comment">//说白了就是用first和second</span><br></code></pre></td></tr></table></figure><p><strong>map的增删改查方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> type1&amp; key)</span>    <span class="hljs-comment">//返回key在map中的位置，没有就指end()</span></span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">const</span> type1&amp; key)</span>    <span class="hljs-comment">//返回哈希桶中关键码为key的键值对的个数</span></span><br><span class="hljs-function">insert    <span class="hljs-comment">//插入键值对</span></span><br><span class="hljs-function">erase     <span class="hljs-comment">//删除键值对</span></span><br></code></pre></td></tr></table></figure><p>注意<code>erase</code>方法是使用迭代器删除元素，传入的参数指向目标的迭代器，而返回下一个元素的迭代器，用<code>for</code>遍历删除时不要 <code>iter++</code>，应该使用<code>iter = map.erase(iter)</code></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : nums1) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b : nums2) &#123;<br>                <span class="hljs-type">int</span> sum = a + b;<br>                map1[sum]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : nums3) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b : nums4) &#123;<br>                <span class="hljs-keyword">if</span>(map1.<span class="hljs-built_in">count</span>(-a-b)) <br>                    ans += map1[-a-b];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="赎金信"><ahref="https://leetcode.cn/problems/ransom-note/description/">383.赎金信</a></h1><blockquote><p>Carl文章&amp;视频链接：<ahref="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html">代码随想录| 383.赎金信</a></p></blockquote><p>看覆不覆盖就完了，用 <code>char alpha[26]</code>或者开一个<code>map</code>都行，一次遍历 ++，一次遍历 --，缺了就 false，不缺就true</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : magazine) &#123;<br>            map[c]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : ransomNote) &#123;<br>            <span class="hljs-keyword">if</span>(map[c]) map[c]--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="三数之和双指针"><ahref="https://leetcode.cn/problems/3sum/description/">15.三数之和（双指针）</a></h1><blockquote><p>Carl文章&amp;视频链接：<ahref="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录| 三数之和</a></p></blockquote><p>该题看起来是<ahref="https://leetcode.cn/problems/two-sum/description/">两数之和</a>的拓展，所以自然想到用双指针，但是有3个数，得3个指针，所以拆分子问题，一个指针在大循环里移动，小循环内使用两数之和的方法查找。</p><p>还得去重操作，没有关注，WA了几发，哈希做法需要大量剪枝没看。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">2</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> target = -nums[i];<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>                <span class="hljs-type">int</span> sum = nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>(sum == target) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    left++;<br>                    right--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target) &#123;<br>                    left++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <br>                    right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="四数之和双指针"><ahref="https://leetcode.cn/problems/4sum/description/">四数之和（双指针）</a></h1><blockquote><p>Carl文章&amp;视频链接：<ahref="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录| 四数之和</a></p></blockquote><p>跟三数之和差不多，继续拆分子问题套循环，不过又多了剪枝操作</p><p>还得注意范围，此题会爆 <code>int</code>，得用<code>long long</code></p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>      <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">3</span>;i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) &#123;<span class="hljs-comment">//已经太大</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<span class="hljs-comment">//已经太小</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;j &lt; n - <span class="hljs-number">2</span>;j++) &#123;<br>                <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) &#123;<span class="hljs-comment">//已经太大</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>) nums[i] + nums[j] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<span class="hljs-comment">//已经太小</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> left = j + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[left] + nums[right] + nums[i] + nums[j];<br>                    <span class="hljs-keyword">if</span>(sum == target) &#123;<br>                        ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt; &#123;nums[i], nums[j], nums[left], nums[right]&#125;);<br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                        left++;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) &#123;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <br>                        left++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迷迭香的记事本：怎么写博客</title>
    <link href="/2024/05/27/%E8%BF%B7%E8%BF%AD%E9%A6%99%E7%9A%84%E8%AE%B0%E4%BA%8B%E6%9C%AC%EF%BC%9A%E6%80%8E%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/05/27/%E8%BF%B7%E8%BF%AD%E9%A6%99%E7%9A%84%E8%AE%B0%E4%BA%8B%E6%9C%AC%EF%BC%9A%E6%80%8E%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1><p>目前，如果misery想要写一篇博客，本地步骤为： 1.打开创建在<code>D:</code>的<code>blog</code>文件夹 2.右键，<code>git bash here</code>，输入<code>hexo new blog 'YOUR_BLOG_NAME'</code>3.进入<code>source\_post</code>文件夹中，找到step2创建的YOUR_BLOG_NAME.md文件，用vscode打开，进行编辑4.回到bash，输入<code>hexo g</code>重新生成静态页面，选择性输入<code>hexo s</code>预览效果5. 输入<code>hexo d</code>上传到github</p><h1id="hexo-d后博客未发生变化"><code>hexo d</code>后博客未发生变化?</h1><p>如果step5执行后，repository中看得见变化，能找到博客，但是网页并未发生变化，则回到<code>/blog</code>下的bash中输入<code>hexo clean</code>清除缓存（删除<code>/public</code>文件夹），重新从step4执行即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day2</title>
    <link href="/2024/05/23/leetcode-day2/"/>
    <url>/2024/05/23/leetcode-day2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第二天就有所松懈了，拖到晚上才写，拓展题也没写完，今天的没那么无脑，所以用老本行C++写</p></blockquote><h1 id="有序数组的平方"><ahref="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组的平方</a></h1><p>打眼一瞧，这题就是拿正负数平方之后大小不定来考人，结合卡哥想练的双指针，不难想到左右指针比绝对值大小一个一个插入，虽然这样是从大到小，不过有<code>reverse()</code>可以用，比较方便，也没有增加时间复杂度，还是<spanclass="math inline">\(O(n)\)</span>，下附代码，不甚完美，可点击链接去看官解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(nums[left]) &lt; <span class="hljs-built_in">abs</span>(nums[right])) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums[right] * nums[right]);<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(nums[left]) &gt;= <span class="hljs-built_in">abs</span>(nums[right])) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums[left] * nums[left]);<br>                left++;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="长度最小的子数组"><ahref="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a></h1><p><strong>题目</strong></p><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其总和大于等于 <code>target</code>的长度最小的 连续子数组<code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>这题是滑动窗口，由于做过多次，所以记得比较清楚，直接写了，结果遇到不少问题，WA了一发才解决，对于区间开闭的把握还不纯熟……<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> target &lt;= nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">1</span>, sum = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right &lt;= nums.<span class="hljs-built_in">size</span>() &amp;&amp; left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span>(sum &lt; target &amp;&amp; right &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>                sum += nums[right++];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt;= target &amp;&amp; left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>) ans = right - left;<br>                <span class="hljs-keyword">else</span> ans = <span class="hljs-built_in">min</span>(ans, right - left);<br>                sum -= nums[left++];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="拓展水果成篮">拓展——<ahref="https://leetcode.cn/problems/fruit-into-baskets/">水果成篮</a></h1><p>这题是卡哥关于滑动窗口的拓展题1，小生不才，WA了五发才过，思路一直不清，将思路转换为代码语言也不准确。</p><blockquote><p>大概描述思路：</p><p>俩篮子我用俩变量bucket1、bucket2来模拟，含左右顺序，俩指针做滑动窗口代表当前能摘的树。一个ans作为结果一直维护一个最大值，每遇到新树，则将left前进到第二种水果第一次出现的地方，right重新从left处开始走。至于第一次出现的位置我用一个<code>pair</code>来存。</p></blockquote><p>下附代码，官解与我不同，使用了哈希表，我也想用，苦于set和map系列语法掌握不牢，没写出来……<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fruits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(fruits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; bucket1, bucket2;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">1</span>;<br>        bucket1.first = fruits[left];<br>        bucket1.second = left;<br>        bucket2.first = <span class="hljs-number">-1</span>;<br>        bucket2.second = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; right &lt; fruits.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(fruits[right] == bucket1.first) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fruits[right] == bucket2.first) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bucket2.first == <span class="hljs-number">-1</span>)&#123;<br>                bucket2.first = fruits[right];<br>                bucket2.second = right;<br>                ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                left = bucket2.second;<br>                bucket1.first = bucket2.first;<br>                bucket1.second = left;<br>                bucket2.first = <span class="hljs-number">-1</span>;<br>                bucket2.second = <span class="hljs-number">-1</span>;<br>                right = left;<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>leetcode 官方题解：<ahref="https://leetcode.cn/problems/fruit-into-baskets/solutions/1893352/shui-guo-cheng-lan-by-leetcode-solution-1uyu/">水果成篮</a></p><h1 id="拓展最小覆盖子串">拓展——<ahref="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></h1><p>吐了，写的全没了，不记了，直接抛出灵神题解算了，哈希方法的确妙，还有less对于检索的优化。</p><p><ahref="https://leetcode.cn/problems/minimum-window-substring/solutions/2713911/liang-chong-fang-fa-cong-o52mn-dao-omnfu-3ezz/">灵茶山艾府题解</a></p><h1 id="螺旋矩阵ii"><ahref="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵II</a></h1><p>这题经典模拟，之前做过多次，这次一把过，左sir讲过优雅的四循环，评论区也是优雅的四循环，所以我也优雅的四循环，但还是不够优雅。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, bottom = n - <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> map[n][n];<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(k &lt;= n*n) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = left;t &lt;= right;t++) <br>                map[top][t] = k++;<br>            top++;<br>            <span class="hljs-keyword">if</span>(k &gt; n*n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = top;r &lt;= bottom;r++) <br>                map[r][right] = k++;<br>            right--;<br>            <span class="hljs-keyword">if</span>(k &gt; n*n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b = right;b &gt;= left;b--)<br>                map[bottom][b] = k++;<br>            bottom--;<br>            <span class="hljs-keyword">if</span>(k &gt; n*n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = bottom;l &gt;= top;l--)<br>                map[l][left] = k++;<br>            left++;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; t;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) &#123;<br>                t.<span class="hljs-built_in">push_back</span>(map[i][j]);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(t);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>数组部分总体不难，主要是双指针和滑动窗口思想，双指针有快慢指针和左右指针，滑动窗口偏贪心一点，大体是right向前去满足条件，满足之后收紧left寻找最优，最后综合所有最优选出整体最优。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_day1</title>
    <link href="/2024/05/22/leetcode-day1/"/>
    <url>/2024/05/22/leetcode-day1/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><ahref="https://leetcode.cn/problems/binary-search/">二分查找</a></h1><p>之前用C++刷过不止一遍，所以这次用java重写，没想到遇到了语法问题，尴尬……</p><ul><li>参数给的<code>int[] nums</code>，跟C的普通数组一样吗？那我怎么得到长度呢？java有<code>sizeof()</code>吗？</li><li>我第一时间想递归，但是怎么传被分割后的数组呢？</li></ul><p>搜索学习一波后了解到，java的<code>int[]</code>类型可以获取长度，具体见下：</p><h2 id="java数组语法小记">java数组语法小记</h2><h3 id="length属性">length属性</h3><ul><li><code>length</code>是数组的一个属性，用于获取数组的长度。</li><li>这是数组对象的一个公共属性，不是类的成员。</li></ul><p>例如： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <br>System.out.println(nums.length); <span class="hljs-comment">// 输出数组的长度：5</span><br></code></pre></td></tr></table></figure> ### 其他可用的操作</p><p>虽然length是唯一一个直接通过点符号<code>.</code>访问的数组属性，但数组对象还可以通过一些标准的类库方法进行操作。例如：</p><ol type="1"><li><p><strong>Arrays 类：</strong></p><p>Arrays 类提供了许多静态方法来操作数组，例如排序、搜索、比较、填充等。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays; <br><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;; <br>Arrays.sort(nums); <span class="hljs-comment">// 对数组进行排序</span><br>System.out.println(Arrays.toString(nums)); <span class="hljs-comment">// 将数组转换为字符串并输出：[1, 1, 3, 4, 5]</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>System 类：</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System 类提供了一些方法来进行数组的复制等操作。<br><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <br><span class="hljs-type">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>System.arraycopy(nums, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>, nums.length); <span class="hljs-comment">// 复制数组</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>Collections 类（适用于对象数组）：</strong>对于对象数组，可以使用 Collections类的方法进行排序、搜索等操作，但对于基本类型数组（如 int[]），需要使用Arrays 类的方法。</p></li></ol><h3 id="数组的其他特性">数组的其他特性</h3><ul><li><p><strong>数组是对象：</strong><br />在Java中，所有的数组类型都是对象，并且继承自<code>java.lang.Object</code> 类。</p></li><li><p><strong>多维数组：</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] matrix = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125; &#125;;<br>System.out.println(matrix.length); <span class="hljs-comment">// 输出二维数组的行数：3 </span><br>System.out.println(matrix[<span class="hljs-number">0</span>].length); <span class="hljs-comment">// 输出二维数组的第一行的列数：3</span><br></code></pre></td></tr></table></figure></p><ul><li>Java支持多维数组，通过嵌套数组的方式实现。</li></ul></li><li><p><strong>无法改变大小：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <br>list.add(<span class="hljs-number">1</span>); list.add(<span class="hljs-number">2</span>); <br>System.out.println(list.size()); <span class="hljs-comment">// 输出列表的大小：2</span><br></code></pre></td></tr></table></figure></p></li><li><p>数组一旦创建，其大小是固定的。如果需要一个可以动态调整大小的数组，可以使用ArrayList 或其他集合类。</p></li></ul><h2 id="代码实现递归版">代码实现（递归版）</h2><p>至于具体算法细节，仍然是carl所教的左闭右开和左闭右闭</p><p><strong>左闭右开</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchHelp(<span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, nums, target);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchHelp</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span>(begin == end) &#123;<br>            <span class="hljs-keyword">return</span> target == nums[begin] ? begin : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end - begin) / <span class="hljs-number">2</span> + begin;<br>        <span class="hljs-keyword">if</span>(target &lt;= nums[mid]) <span class="hljs-keyword">return</span> searchHelp(begin, mid, nums, target);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> searchHelp(mid + <span class="hljs-number">1</span>, end, nums, target);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <strong>左闭右闭</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchHelp(<span class="hljs-number">0</span>, nums.length, nums, target);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchHelp</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span>(begin &gt;= end - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(begin &gt; end - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> target == nums[begin] ? begin : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end - begin) / <span class="hljs-number">2</span> + begin;<br>        <span class="hljs-keyword">if</span>(target &lt; nums[mid]) <span class="hljs-keyword">return</span> searchHelp(begin, mid, nums, target);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> searchHelp(mid , end, nums, target);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> # 二分拓展——在排序数组中查找元素的第一个和最后一个位置</p><p><ahref="https://leetcode.cn/problems/binary-search/">题目链接</a></p><p>还没做此题时，算法群中有人讨论，瞄到了“二分定位然后发散找边界”的思路，窃以为很有道理，然另一群友diss：“全是一样的就成了<spanclass="math inline">\(O(n)\)</span>了”，有道理哈。</p><p>自己做的时候的确直觉想到"二分定位然后发散"的思路，但是有意避免，于是想到两次二分分别定左右边界。下附代码，与官方题解区别在于，官方使用了一个<code>lower</code>标志位来区分左右边界，把两次二分合成一个方法。而我的代码直接写了两次，把等号换地方。记得第一次二分后把right弄回去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt;= target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left &gt;= nums.length || nums[left] != target) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">else</span> ans[<span class="hljs-number">0</span>] = left;<br>        right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt;= target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        ans[<span class="hljs-number">1</span>] = right;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="移除元素"><ahref="https://leetcode.cn/problems/remove-element/">移除元素</a></h1><p>此题貌似是力扣新手村的一道题，以前错过多次，感叹于自己的菜，于是这次还记得解法，但仍然没有一把AC，在去重的时候没有考虑好只有一个元素和空表的情况。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">while</span>(right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[right] == val) right--;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span>(nums[right] == val &amp;&amp; left &lt; right) right--;<br>            <span class="hljs-keyword">while</span>(nums[left] != val &amp;&amp; left &lt; right) left++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = temp;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>第一天打卡，希望能够坚持下去，同时笔者还在看dolphinscheduler，看不懂啊……想参加开源之夏，但是好像截止前连项目都看不懂，抓紧时间，加油加油！</p><p>(更新：想peach了，没参加成，申请书都没写完，明年一定)</p><p><strong>ps</strong>算法群里遇到一个问题，在遍历数组的时候，<code>fast &lt; nums.size()</code>就AC，<code>fast &lt;= nums.size() - 1</code>就RE，原来是因为：</p><p>vector的size方法返回的是无符号整数，减一之后不会变-1，而是变大，条件就无效了。</p><p>空vector才会碰见的坑，长见识了。</p><p>​</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
